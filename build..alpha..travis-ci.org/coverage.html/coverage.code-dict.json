{"/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/test.js":"/* istanbul instrument in package npmtest_claudia_bot_builder */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/lib.npmtest_claudia_bot_builder.js":"/* istanbul instrument in package npmtest_claudia_bot_builder */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_claudia_bot_builder = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_claudia_bot_builder = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-claudia-bot-builder && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_claudia_bot_builder */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_claudia_bot_builder\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_claudia_bot_builder.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_claudia_bot_builder.rollup.js'] =\n            local.assetsDict['/assets.npmtest_claudia_bot_builder.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_claudia_bot_builder.__dirname + '/lib.npmtest_claudia_bot_builder.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/index.js":"module.exports = require('./lib/bot-builder');\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/bot-builder.js":"'use strict';\n\nconst ApiBuilder = require('claudia-api-builder');\nconst fbSetup = require('./facebook/setup');\nconst slackSetup = require('./slack/setup');\nconst telegramSetup = require('./telegram/setup');\nconst skypeSetup = require('./skype/setup');\nconst twilioSetup = require('./twilio/setup');\nconst kikSetup = require('./kik/setup');\nconst groupmeSetup = require('./groupme/setup');\nconst lineSetup = require('./line/setup');\nconst viberSetup = require('./viber/setup');\nconst alexaSetup = require('./alexa/setup');\nconst fbTemplate = require('./facebook/format-message');\nconst slackTemplate = require('./slack/format-message');\nconst telegramTemplate = require('./telegram/format-message');\nconst viberTemplate = require('./viber/format-message');\nconst skypeTemplate = require('./skype/format-message');\nconst AlexaTemplate = require('alexa-message-builder');\nconst slackDelayedReply = require('./slack/delayed-reply');\n\nlet logError = function (err) {\n  console.error(err);\n};\n\nmodule.exports = function botBuilder(messageHandler, options, optionalLogError) {\n  logError = optionalLogError || logError;\n\n  const api = new ApiBuilder(),\n    messageHandlerPromise = function (message, originalApiBuilderRequest) {\n      return Promise.resolve(message).then(message => messageHandler(message, originalApiBuilderRequest));\n    };\n\n  api.get('/', () => 'Ok');\n\n  let isEnabled = function isEnabled(platform) {\n    return !options || !options.platforms || options.platforms.indexOf(platform) > -1;\n  };\n\n  if (isEnabled('facebook')) {\n    fbSetup(api, messageHandlerPromise, logError);\n  }\n  if (isEnabled('slackSlashCommand')) {\n    slackSetup(api, messageHandlerPromise, logError);\n  }\n  if (isEnabled('telegram')) {\n    telegramSetup(api, messageHandlerPromise, logError);\n  }\n  if (isEnabled('skype')) {\n    skypeSetup(api, messageHandlerPromise, logError);\n  }\n  if (isEnabled('twilio')) {\n    twilioSetup(api, messageHandlerPromise, logError);\n  }\n  if (isEnabled('kik')) {\n    kikSetup(api, messageHandlerPromise, logError);\n  }\n  if (isEnabled('groupme')) {\n    groupmeSetup(api, messageHandlerPromise, logError);\n  }\n  if (isEnabled('line')) {\n    lineSetup(api, messageHandlerPromise, logError);\n  }\n  if (isEnabled('viber')) {\n    viberSetup(api, messageHandlerPromise, logError);\n  }\n  if (isEnabled('alexa')) {\n    alexaSetup(api, messageHandlerPromise, logError);\n  }\n\n  return api;\n};\n\nmodule.exports.fbTemplate = fbTemplate;\nmodule.exports.slackTemplate = slackTemplate;\nmodule.exports.telegramTemplate = telegramTemplate;\nmodule.exports.viberTemplate = viberTemplate;\nmodule.exports.skypeTemplate = skypeTemplate;\nmodule.exports.AlexaTemplate = AlexaTemplate;\nmodule.exports.slackDelayedReply = slackDelayedReply;\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/facebook/setup.js":"'use strict';\n\nconst crypto = require('crypto');\nconst prompt = require('souffleur');\nconst rp = require('minimal-request-promise');\nconst fbReply = require('./reply');\nconst fbParse = require('./parse');\nconst validateFbRequestIntegrity = require('./validate-integrity');\nconst color = require('../console-colors');\n\nmodule.exports = function fbSetup(api, bot, logError, optionalParser, optionalResponder) {\n  let parser = optionalParser || fbParse;\n  let responder = optionalResponder || fbReply;\n\n  api.get('/facebook', request => {\n    if (request.queryString['hub.verify_token'] === request.env.facebookVerifyToken)\n      return request.queryString['hub.challenge'];\n\n    logError(`Facebook can't verify the token. It expected '${request.env.facebookVerifyToken}', but got '${request.queryString['hub.verify_token']}'. Make sure you are using the same token you set in 'facebookVerifyToken' stage env variable.`);\n    return 'Error';\n  }, {success: {contentType: 'text/plain'}});\n\n  api.post('/facebook', request => {\n    // We are doing verification if FB Secret exist in env because we don't want to break old bots that forgot to add it\n    if (request.env.facebookAppSecret && !validateFbRequestIntegrity(request))\n      return Promise.reject('X-Hub-Signatures does not match');\n\n    let arr = [].concat.apply([], request.body.entry.map(entry => entry.messaging));\n    let fbHandle = parsedMessage => {\n      if (parsedMessage) {\n        var recipient = parsedMessage.sender;\n\n        return Promise.resolve(parsedMessage).then(parsedMessage => bot(parsedMessage, request))\n          .then(botResponse => responder(recipient, botResponse, request.env.facebookAccessToken))\n          .catch(logError);\n      }\n    };\n\n    return Promise.all(arr.map(message => fbHandle(parser(message))))\n      .then(() => 'ok');\n  });\n\n  api.addPostDeployStep('facebook', (options, lambdaDetails, utils) => {\n    return Promise.resolve().then(() => {\n      return utils.apiGatewayPromise.getStagePromise({\n        restApiId: lambdaDetails.apiId,\n        stageName: lambdaDetails.alias\n      }).then(data => {\n        if (options['configure-fb-bot']) {\n          let token, pageAccessToken;\n\n          return Promise.resolve().then(() => {\n            if (data.variables && data.variables.facebookVerifyToken)\n              return data.variables.facebookVerifyToken;\n\n            return crypto.randomBytes(8);\n          })\n          .then(rawToken => {\n            token = rawToken.toString('base64').replace(/[^A-Za-z0-9]/g, '');\n            return utils.apiGatewayPromise.createDeploymentPromise({\n              restApiId: lambdaDetails.apiId,\n              stageName: lambdaDetails.alias,\n              variables: {\n                facebookVerifyToken: token\n              }\n            });\n          })\n          .then(() => {\n            console.log(`\\n\\n${color.green}Facebook Messenger setup${color.reset}\\n`);\n            console.log(`\\nFollowing info is required for the setup, for more info check the documentation.\\n`);\n            console.log(`\\nYour webhook URL is: ${color.cyan}${lambdaDetails.apiUrl}/facebook${color.reset}\\n`);\n            console.log(`Your verify token is: ${color.cyan}${token}${color.reset}\\n`);\n\n            return prompt(['Facebook page access token', 'Facebook App Secret']);\n          })\n          .then(results => {\n            console.log('\\n');\n            pageAccessToken = results['Facebook page access token'];\n            const deployment = {\n              restApiId: lambdaDetails.apiId,\n              stageName: lambdaDetails.alias,\n              variables: {\n                facebookAccessToken: pageAccessToken,\n                facebookAppSecret: results['Facebook App Secret']\n              }\n            };\n\n            if (!data.variables || !data.variables.facebookAppSecret)\n              console.log(`\\n${color.yellow}Deprecation warning:${color.reset} your bot is not using facebook validation. Please re-run with --configure-fb-bot to set it. This will become mandatory in the next major version. See https://github.com/claudiajs/claudia-bot-builder/blob/master/docs/API.md#message-verification for more information.\\n`);\n\n            return utils.apiGatewayPromise.createDeploymentPromise(deployment);\n          })\n          .then(() => rp.post(`https://graph.facebook.com/v2.6/me/subscribed_apps?access_token=${pageAccessToken}`));\n        }\n      });\n    })\n      .then(() => `${lambdaDetails.apiUrl}/facebook`);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/facebook/reply.js":"'use strict';\n\nconst rp = require('minimal-request-promise'),\n  breakText = require('../breaktext');\n\nmodule.exports = function fbReply(recipient, message, fbAccessToken) {\n  var sendSingle = function sendSingle (message) {\n      if (typeof message === 'object' && typeof message.claudiaPause === 'number') {\n        return new Promise(resolve => setTimeout(resolve, parseInt(message.claudiaPause, 10)));\n      }\n      const messageBody = {\n        recipient: {\n          id: recipient\n        }\n      };\n      if (message.hasOwnProperty('notification_type')) {\n        messageBody.notification_type = message.notification_type;\n        delete message.notification_type;\n      }\n      if (message.hasOwnProperty('sender_action')) {\n        messageBody.sender_action = message.sender_action;\n      } else {\n        messageBody.message = message;\n      }\n      const options = {\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(messageBody)\n      };\n      return rp.post(`https://graph.facebook.com/v2.6/me/messages?access_token=${fbAccessToken}`, options);\n    },\n    sendAll = function () {\n      if (!messages.length) {\n        return Promise.resolve();\n      } else {\n        return sendSingle(messages.shift()).then(sendAll);\n      }\n    },\n    messages = [];\n\n  function breakTextAndReturnFormatted(message) {\n    return breakText(message, 640).map(m => ({ text: m }));\n  }\n\n  if (typeof message === 'string') {\n    messages = breakTextAndReturnFormatted(message);\n  } else if (Array.isArray(message)) {\n    message.forEach(msg => {\n      if (typeof msg === 'string') {\n        messages = messages.concat(breakTextAndReturnFormatted(msg));\n      } else {\n        messages.push(msg);\n      }\n    });\n  } else if (!message) {\n    return Promise.resolve();\n  } else {\n    messages = [message];\n  }\n  return sendAll();\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/breaktext.js":"/*global module*/\nvar chunk = function (tx, callback) {\n  var prev = 0,\n    re = /\\s/gi,\n    chunk;\n  while (re.exec(tx)) {\n    chunk = tx.slice(prev, re.lastIndex - 1);\n    callback(chunk);\n    prev = re.lastIndex - 1;\n  }\n  if (prev < tx.length) {\n    callback(tx.slice(prev));\n  }\n};\n\nmodule.exports = function (text, limit) {\n  'use strict';\n  var lines = [],\n    currentLine = [],\n    currentLineLength = 0,\n    closeLine = function () {\n      if (currentLineLength) {\n        lines.push(currentLine.join('').trim());\n        currentLine = [];\n        currentLineLength = 0;\n      }\n    },\n    processChunk = function (chunk) {\n      var index;\n      if (currentLineLength + chunk.length > limit) {\n        closeLine();\n      }\n      if (chunk.length > limit) {\n        for (index = 0; index < chunk.length; index += limit) {\n          processChunk(chunk.slice(index, index + limit));\n        }\n      } else {\n        currentLineLength += chunk.length;\n        currentLine.push(chunk);\n      }\n    };\n\n  if (text === '') {\n    return [''];\n  }\n\n  chunk(text, processChunk);\n  closeLine();\n\n  return lines;\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/facebook/parse.js":"'use strict';\n\nmodule.exports = function(messageObject) {\n  if (messageObject && messageObject.sender && messageObject.sender.id && messageObject.message && messageObject.message.text && !messageObject.message.quick_reply &&\n    (typeof messageObject.delivery !== 'object' && typeof messageObject.read !== 'object' && (!messageObject.message || !messageObject.message.is_echo))) { // Disable delivery and read reports and message echos\n    return {\n      sender: messageObject.sender.id,\n      text: messageObject.message.text,\n      originalRequest: messageObject,\n      type: 'facebook'\n    };\n  }\n  else if (messageObject && messageObject.sender && messageObject.sender.id && messageObject.postback && messageObject.postback.payload) {\n    return {\n      sender: messageObject.sender.id,\n      text: messageObject.postback.payload,\n      originalRequest: messageObject,\n      postback: true,\n      type: 'facebook'\n    };\n  }\n  else if (messageObject && messageObject.sender && messageObject.sender.id && messageObject.message && messageObject.message.quick_reply && messageObject.message.quick_reply.payload) {\n    return {\n      sender: messageObject.sender.id,\n      text: messageObject.message.quick_reply.payload,\n      originalRequest: messageObject,\n      postback: true,\n      type: 'facebook'\n    };\n  }\n  else if (messageObject && messageObject.sender && messageObject.sender.id &&\n    (typeof messageObject.delivery !== 'object' && typeof messageObject.read !== 'object' && (!messageObject.message || !messageObject.message.is_echo))) { // Disable delivery and read reports and message echos\n    return {\n      sender: messageObject.sender.id,\n      text: (messageObject.message && messageObject.message.text) ? messageObject.message.text : '',\n      originalRequest: messageObject,\n      type: 'facebook'\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/facebook/validate-integrity.js":"'use strict';\n\nconst crypto = require('crypto');\nconst tsscmp = require('tsscmp');\n\nmodule.exports = function validateFbRequestIntegrity(request) {\n  const xHubSignature = request.headers['X-Hub-Signature'] || request.headers['x-hub-signature'];\n  const parsedXHubSignature = xHubSignature.split('=');\n  const serverSignature = crypto.createHmac(parsedXHubSignature[0], request.env.facebookAppSecret).update(request.rawBody).digest('hex');\n  return tsscmp(parsedXHubSignature[1], serverSignature);\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/console-colors.js":"module.exports = {\n  reset: '\\x1b[0m',\n  default: '\\x1b[39m',\n  dim: '\\x1b[2m',\n  blue: '\\x1b[34m',\n  cyan: '\\x1b[36m',\n  green: '\\x1b[32m',\n  magenta: '\\x1b[35m',\n  red: '\\x1b[31m',\n  yellow: '\\x1b[33m'\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/slack/setup.js":"'use strict';\n\nconst prompt = require('souffleur');\nconst rp = require('minimal-request-promise');\nconst qs = require('querystring');\nconst slackReply = require('./reply');\nconst slackParse = require('./parse');\nconst color = require('../console-colors');\n\nmodule.exports = function slackSetup(api, bot, logError, optionalParser, optionalResponder) {\n  let parser = optionalParser || slackParse;\n  let responder = optionalResponder || slackReply;\n\n  // Hanlde Slack ssl_check GET request, info: https://api.slack.com/slash-commands#ssl\n  api.get('/slack/slash-command', () => 'OK');\n\n  api.post('/slack/slash-command', request => {\n    if ((request.post.command &&\n          (request.post.token === request.env.slackToken || request.post.token === request.env.slackVerificationToken))\n        ||\n        (request.post.trigger_word && request.post.token === request.env.slackWebhookToken))\n      return bot(parser(request.post), request)\n        .then(responder)\n        .catch(logError);\n    else\n      return responder('unmatched token' + ' ' + request.post.token);\n  });\n\n  api.post('/slack/message-action', request => {\n    const payload = JSON.parse(request.post.payload);\n    if (payload.token === request.env.slackVerificationToken || payload.token === request.env.slackToken)\n      return bot(parser(payload), request)\n        .then(responder)\n        .catch(logError);\n    else\n      return responder('unmatched token' + ' ' + payload.token);\n  });\n\n  api.get('/slack/landing', request => {\n    return rp.post('https://slack.com/api/oauth.access', {\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      body: qs.encode({\n        client_id: request.env.slackClientId,\n        client_secret: request.env.slackClientSecret,\n        code: request.queryString.code,\n        redirect_uri: request.env.slackRedirectUrl\n      })\n    })\n      .then(() => request.env.slackHomePageUrl);\n  }, {\n    success: 302\n  });\n\n  api.addPostDeployStep('slackSlashCommand', (options, lambdaDetails, utils) => {\n    return Promise.resolve().then(() => {\n      if (options['configure-slack-slash-command']) {\n        console.log(`\\n\\n${color.green}Slack slash command setup${color.reset}\\n`);\n        console.log(`\\nFollowing info is required for the setup, for more info check the documentation.\\n`);\n        console.log(`\\nNote that you can add one token for a slash command, and a second token for an outgoing webhook.\\n`);\n        console.log(`\\nYour Slack slash command Request URL (POST only) is ${color.cyan}${lambdaDetails.apiUrl}/slack/slash-command${color.reset}\\n`);\n        console.log(`${color.dim}If you are building full-scale Slack app instead of just a slash command for your team, restart with --configure-slack-slash-app${color.reset} \\n`);\n\n        return prompt(['Slack token', 'Outgoing webhook token'])\n          .then(results => {\n            const deployment = {\n              restApiId: lambdaDetails.apiId,\n              stageName: lambdaDetails.alias,\n              variables: {\n                slackToken: results['Slack token'],\n                slackWebhookToken: results['Outgoing webhook token']\n              }\n            };\n\n            console.log(`\\n`);\n\n            return utils.apiGatewayPromise.createDeploymentPromise(deployment);\n          });\n      }\n\n      if (options['configure-slack-slash-app']) {\n        console.log(`\\n\\n${color.green}Slack App slash command setup${color.reset}\\n`);\n        console.log(`\\nFollowing info is required for the setup, for more info check the documentation.\\n`);\n        console.log(`\\nYour Slack redirect URL is ${color.cyan}${lambdaDetails.apiUrl}/slack/landing${color.reset}\\n`);\n        console.log(`\\nYour Slack slash command Request URL (POST only) is ${color.cyan}${lambdaDetails.apiUrl}/slack/slash-command${color.reset}\\n`);\n        console.log(`\\nIf you are using buttons, your Action URL is ${color.cyan}${lambdaDetails.apiUrl}/slack/message-action${color.reset}\\n`);\n        console.log(`${color.dim}If you are building just a slash command integration for your team and you don't need full-scale Slack app restart with --configure-slack-slash-command${color.reset} \\n`);\n\n        return prompt(['Slack Client ID', 'Slack Client Secret', 'Slack verification token', 'Home page URL'])\n          .then(results => {\n            const deployment = {\n              restApiId: lambdaDetails.apiId,\n              stageName: lambdaDetails.alias,\n              variables: {\n                slackClientId: results['Slack Client ID'],\n                slackClientSecret: results['Slack Client Secret'],\n                slackVerificationToken: results['Slack verification token'],\n                slackHomePageUrl: results['Home page URL'],\n                slackRedirectUrl: `${lambdaDetails.apiUrl}/slack/landing`\n              }\n            };\n\n            console.log(`\\n`);\n\n            return utils.apiGatewayPromise.createDeploymentPromise(deployment);\n          });\n      }\n    })\n      .then(() => `${lambdaDetails.apiUrl}/slack/slash-command`);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/slack/reply.js":"'use strict';\n\nmodule.exports = function slackReply(botResponse) {\n  if (typeof botResponse === 'string')\n    return {\n      text: botResponse\n    };\n\n  return botResponse;\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/slack/parse.js":"'use strict';\n\nmodule.exports = function(messageObject) {\n  if (messageObject && messageObject.user_id)\n    return {\n      sender: messageObject.user_id,\n      text: messageObject.text || '',\n      originalRequest: messageObject,\n      type: 'slack-slash-command'\n    };\n\n  if (messageObject && messageObject.user && messageObject.actions)\n    return {\n      sender: messageObject.user.id,\n      text: '',\n      originalRequest: messageObject,\n      type: 'slack-message-action',\n      postback: true\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/telegram/setup.js":"'use strict';\n\nconst rp = require('minimal-request-promise');\nconst prompt = require('souffleur');\nconst tlReply = require('./reply');\nconst tlParse = require('./parse');\nconst color = require('../console-colors');\n\nmodule.exports = function tlSetup(api, bot, logError, optionalParser, optionalResponder) {\n  let parser = optionalParser || tlParse;\n  let responder = optionalResponder || tlReply;\n\n  api.post('/telegram', request => {\n    let tlMessage = request.body;\n\n    let parsedMessage = parser(tlMessage);\n    if (!parsedMessage){\n      return Promise.resolve('ok');\n    }\n    return Promise.resolve(parsedMessage).then(parsedMessage => bot(parsedMessage, request))\n      .then(botResponse => responder(parsedMessage, botResponse, request.env.telegramAccessToken))\n      .catch(logError);\n  });\n\n  api.addPostDeployStep('telegram', (options, lambdaDetails, utils) => {\n    return Promise.resolve()\n      .then(() => {\n        if (options['configure-telegram-bot']) {\n          console.log(`\\n\\n${color.green}Telegram setup${color.reset}\\n`);\n          console.log(`\\nFollowing info is required for the setup, for more info check the documentation.\\n`);\n          console.log(`\\nYour Telegram bot Request URL (POST only) is ${color.cyan}${lambdaDetails.apiUrl}/telegram${color.reset}\\n`);\n          console.log(`\\nIf you want your bot to receive inline queries\\n just send /setinline to the @BotFather on your Telegram client and choose your bot\\n`);\n\n          return prompt(['Telegram Access Token'])\n            .then(results => {\n              const deployment = {\n                restApiId: lambdaDetails.apiId,\n                stageName: lambdaDetails.alias,\n                variables: {\n                  telegramAccessToken: results['Telegram Access Token']\n                }\n              };\n\n              return utils.apiGatewayPromise.createDeploymentPromise(deployment)\n                .then(() => {\n                  let options = {\n                    headers: {\n                      'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                      url: `${lambdaDetails.apiUrl}/telegram`\n                    })\n                  };\n                  return rp.post(`https://api.telegram.org/bot${deployment.variables.telegramAccessToken}/setWebhook`, options);\n                });\n            });\n        }\n      })\n      .then(() => `${lambdaDetails.apiUrl}/telegram`);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/telegram/reply.js":"'use strict';\n\nconst rp = require('minimal-request-promise');\nconst REQUEST_THROTTLE = 1000/30;\nconst RETRIABLE_ERRORS = ['ECONNRESET', 'ENOTFOUND', 'ESOCKETTIMEDOUT', 'ETIMEDOUT', 'ECONNREFUSED', 'EHOSTUNREACH', 'EPIPE', 'EAI_AGAIN'];\nconst NUMBER_OF_RETRIES = 20;\n\nmodule.exports = function tlReply(messageObject, message, tlAccessToken) {\n\n  var sendHttpRequest = function sendApiRequest(tlAccessToken, method, options, numberOfRetries) {\n      return rp.post(`https://api.telegram.org/bot${tlAccessToken}/${method}`, options)\n        .catch(e => {\n          let httpCode = parseInt(e.statusCode, 10);\n          if (numberOfRetries-- > 0 && (RETRIABLE_ERRORS.indexOf(e.statusMessage) >= 0 || httpCode == 429 || httpCode == 420 || httpCode >= 500 && httpCode < 600)) {\n            return sendHttpRequest(tlAccessToken, method, options, numberOfRetries);\n          }\n          throw e;\n        });\n    },\n    sendSingle = function sendSingle (message) {\n      var method, body;\n\n      if (typeof message === 'object' && typeof message.claudiaPause === 'number') {\n        return new Promise(resolve => setTimeout(resolve, parseInt(message.claudiaPause, 10)));\n      } else if (typeof message !== 'string') {\n        method = message.method ? message.method : messageObject.originalRequest.inline_query ?\n          'answerInlineQuery' : 'sendMessage';\n        body = message.body ? message.body : message;\n        if (!body.chat_id)\n          body.chat_id = messageObject.sender;\n      } else if (messageObject.originalRequest.inline_query && typeof message === 'string') {\n        method = 'answerInlineQuery';\n        body = {\n          inline_query_id: messageObject.sender,\n          results: [{\n            type: 'article',\n            id: `${new Date().getTime()}`,\n            title: messageObject.text,\n            input_message_content: {\n              message_text: messageObject.text\n            }\n          }]\n        };\n      } else {\n        method = 'sendMessage';\n        body = {\n          chat_id: messageObject.sender,\n          text: message\n        };\n      }\n\n      let numberOfRetries = NUMBER_OF_RETRIES;\n\n      const options = {\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(body)\n      };\n\n      return sendHttpRequest(tlAccessToken, method, options, numberOfRetries);\n    },\n\n    sendAll = function () {\n      if (!messages.length) {\n        return Promise.resolve();\n      } else {\n        return sendSingle(messages.shift())\n        .then(() => {\n          return new Promise((resolve) => {\n            if (!messages.length)\n              resolve();\n            else\n              setTimeout(resolve, REQUEST_THROTTLE);\n          });\n        })\n        .then(sendAll);\n      }\n    },\n\n    messages = Array.isArray(message) ? message : [message];\n\n  return sendAll();\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/telegram/parse.js":"'use strict';\n\nmodule.exports = function(messageObject) {\n\n  if (messageObject && messageObject.inline_query && messageObject.inline_query.id){\n    var inlineQuery = messageObject.inline_query;\n    return {\n      sender: inlineQuery.id,\n      text: inlineQuery.query,\n      originalRequest: messageObject,\n      type: 'telegram'\n    };\n  }\n\n  if (messageObject && messageObject.message && messageObject.message.chat && messageObject.message.chat.id ){\n    var message = messageObject.message;\n    return {\n      sender: message.chat.id,\n      text: message.text || '',\n      originalRequest: messageObject,\n      type: 'telegram'\n    };\n  }\n\n  if (messageObject && messageObject.callback_query && messageObject.callback_query.message.chat &&\n    messageObject.callback_query.message.chat.id ){\n    var callback_query = messageObject.callback_query;\n    return {\n      sender: callback_query.message.chat.id,\n      text: callback_query.data || '',\n      originalRequest: messageObject,\n      type: 'telegram'\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/skype/setup.js":"'use strict';\n\nconst prompt = require('souffleur');\nconst skReply = require('./reply');\nconst skParse = require('./parse');\nconst color = require('../console-colors');\n\nmodule.exports = function skSetup(api, bot, logError, optionalParser, optionalResponder) {\n  let parser = optionalParser || skParse;\n  let responder = optionalResponder || skReply;\n\n\n  api.post('/skype', request => {\n    let arr = request.body instanceof Array ? [].concat.apply([], request.body) : [request.body],\n      skContextId = request.headers.contextid;\n\n    let skHandle = parsedMessage => {\n      if (!parsedMessage) return;\n      return Promise.resolve(parsedMessage).then(parsedMessage => bot(parsedMessage, request))\n        .then(botResponse => responder(request.env.skypeAppId, request.env.skypePrivateKey, parsedMessage.sender, botResponse, skContextId))\n        .catch(logError);\n    };\n\n    return Promise.all(arr.map(message => skHandle(parser(message))))\n      .then(() => 'ok');\n  });\n\n  api.addPostDeployStep('skype', (options, lambdaDetails, utils) => {\n    return Promise.resolve().then(() => {\n      if (options['configure-skype-bot']) {\n        console.log(`\\n\\n${color.green}Skype setup${color.reset}\\n`);\n        console.log(`\\nFollowing info is required for the setup, for more info check the documentation.\\n`);\n\n        return prompt(['Skype App ID', 'Skype Private key'])\n          .then(results => {\n            const deployment = {\n              restApiId: lambdaDetails.apiId,\n              stageName: lambdaDetails.alias,\n              variables: {\n                skypeAppId: results['Skype App ID'],\n                skypePrivateKey: results['Skype Private key']\n              }\n            };\n\n            return utils.apiGatewayPromise.createDeploymentPromise(deployment);\n          });\n      }\n    })\n      .then(() => `${lambdaDetails.apiUrl}/skype`);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/skype/reply.js":"'use strict';\nconst rp = require('minimal-request-promise');\nconst skBearerToken = require('./token');\nconst retry = require('oh-no-i-insist');\n\nconst retryTimeout = 500;\nconst numRetries = 2;\n\nfunction sendReply(conversationId, message, contextId, authToken){\n  if (typeof message === 'string')\n    message = {\n      type: 'message/text',\n      text: message\n    };\n\n  const options = {\n    headers: {\n      'Authorization': 'Bearer ' + authToken,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(message)\n  };\n\n  if (contextId){\n    options.headers['ContextId'] = contextId;\n  }\n  return rp.post(`https://apis.skype.com/v3/conversations/${conversationId}/activities`, options);\n}\n\nmodule.exports = function skReply(skypeAppId, skypePrivateKey, conversationId, message, contextId) {\n  return retry(\n    () => {\n      return skBearerToken.getToken(skypeAppId, skypePrivateKey)\n      .then((token) => sendReply(conversationId, message, contextId, token));\n    },\n    retryTimeout,\n    numRetries,\n    error => error.statusCode === 401, // expired / invalid token error status code\n    skBearerToken.clearToken\n  );\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/skype/token.js":"'use strict';\n\nconst rp = require('minimal-request-promise');\nconst qs = require('querystring');\n\nvar token;\n\nfunction requestToken(appId, appSecret) {\n  \n  var data = qs.encode({\n    grant_type: 'client_credentials',\n    client_id: appId,\n    client_secret: appSecret,\n    scope: 'https://api.botframework.com/.default'\n  });\n  \n  const options = {\n    headers: {\n      'cache-control': 'no-cache',\n      'content-type': 'application/x-www-form-urlencoded',\n      'content-length': Buffer.byteLength(data)\n    },\n    body: data\n  };\n\n  return rp.post('https://login.microsoftonline.com/botframework.com/oauth2/v2.0/token', options);\n}\n\nmodule.exports = {\n  getToken (appId, appSecret){\n    if (!token){\n      return requestToken(appId, appSecret)\n        .then(response => {\n          var body = JSON.parse(response.body);\n          token = body.access_token;\n          return token;\n        });\n    }\n    return Promise.resolve(token);\n  },\n  clearToken () {\n    token = undefined;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/skype/parse.js":"'use strict';\n\nmodule.exports = function(messageObject, contextId) {\n\n  if (messageObject && typeof messageObject.text !== 'undefined')\n    return {\n      sender: messageObject.conversation.id,\n      text: messageObject.text,\n      originalRequest: messageObject,\n      contextId: contextId,\n      type: 'skype'\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/twilio/setup.js":"'use strict';\n\nconst prompt = require('souffleur');\nconst twilioReply = require('./reply');\nconst twilioParse = require('./parse');\nconst color = require('../console-colors');\n\nmodule.exports = function twilioSetup(api, bot, logError, optionalParser, optionalResponder) {\n  let parser = optionalParser || twilioParse;\n  let responder = optionalResponder || twilioReply;\n\n\n  api.post('/twilio', request => {\n    let arr = request.body instanceof Array ? [].concat.apply([], request.body) : [request.body];\n\n    let twilioHandle = parsedMessage => {\n      if (!parsedMessage) return;\n      return Promise.resolve(parsedMessage).then(parsedMessage => bot(parsedMessage, request))\n        .then(botResponse => responder(request.env.TWILIO_ACCOUNT_SID, request.env.TWILIO_AUTH_TOKEN, new Buffer(request.env.TWILIO_NUMBER, 'base64').toString('ascii'), parsedMessage.sender, botResponse))\n        .catch(logError);\n    };\n\n    return Promise.all(arr.map(message => parser(message)).map(twilioHandle))\n      .then(() => '<Response></Response>');\n  }, { success: { contentType: 'text/xml' }});\n\n  api.addPostDeployStep('twilio', (options, lambdaDetails, utils) => {\n    return Promise.resolve().then(() => {\n      if (options['configure-twilio-sms-bot']) {\n        console.log(`\\n\\n${color.green}Twilio SMS setup${color.reset}\\n`);\n        console.log(`\\nFollowing info is required for the setup, for more info check the documentation.\\n`);\n\n        return prompt(['Twilio Account ID', 'Twilio Auth Token', 'Twilio Number used for Sending'])\n          .then(results => {\n            const deployment = {\n              restApiId: lambdaDetails.apiId,\n              stageName: lambdaDetails.alias,\n              variables: {\n                TWILIO_ACCOUNT_SID: results['Twilio Account ID'],\n                TWILIO_AUTH_TOKEN: results['Twilio Auth Token'],\n                TWILIO_NUMBER: new Buffer(results['Twilio Number used for Sending']).toString('base64')\n              }\n            };\n\n            return utils.apiGatewayPromise.createDeploymentPromise(deployment);\n          });\n      }\n    })\n      .then(() => `${lambdaDetails.apiUrl}/twilio`);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/twilio/reply.js":"'use strict';\nconst rp = require('minimal-request-promise');\nconst qs = require('querystring');\n\nfunction twilioReply(twilioAccountSid, twilioAuthToken, twilioSendingNumber, toNumber, message){\n\n  var data = qs.encode({\n    To: typeof message === 'string' ? toNumber : message.sender,\n    From: twilioSendingNumber,\n    Body: typeof message === 'string' ?  message : message.text\n  });\n\n  const options = {\n    headers: {\n      'Authorization': `Basic ${new Buffer(twilioAccountSid + ':' + twilioAuthToken).toString('base64')}`,\n      'content-type': 'application/x-www-form-urlencoded',\n      'content-length': Buffer.byteLength(data)\n    },\n    body: data\n  };\n\n  return rp.post(`https://api.twilio.com/2010-04-01/Accounts/${twilioAccountSid}/Messages.json`, options);\n}\n\n\nmodule.exports = twilioReply;","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/twilio/parse.js":"'use strict';\nconst qs = require('querystring');\n\nmodule.exports = function(messageObject) {\n\n  messageObject = qs.parse(messageObject);\n  if (messageObject && typeof messageObject.Body !== 'undefined' && messageObject.Body.length > 0 &&\n    typeof messageObject.From !== 'undefined' && messageObject.From.length > 0){\n    return {\n      sender: messageObject.From,\n      text: messageObject.Body,\n      originalRequest: messageObject,\n      type: 'twilio'\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/kik/setup.js":"'use strict';\n\nconst rp = require('minimal-request-promise');\nconst prompt = require('souffleur');\nconst kReply = require('./reply');\nconst kParse = require('./parse');\nconst color = require('../console-colors');\n\nmodule.exports = function kSetup(api, bot, logError, optionalParser, optionalResponder) {\n  let parser = optionalParser || kParse;\n  let responder = optionalResponder || kReply;\n\n  api.post('/kik', request => {\n    let arr = [].concat.apply([], request.body.messages);\n    let kikHandle = parsedMessage => {\n      if (parsedMessage){\n        return Promise.resolve(parsedMessage).then(parsedMessage => bot(parsedMessage, request))\n          .then(botResponse => responder(parsedMessage, botResponse, request.env.kikUserName, request.env.kikApiKey))\n          .catch(logError);\n      }\n    };\n\n    return Promise.all(arr.map(message => kikHandle(parser(message))))\n      .then(() => 'ok');\n  });\n\n  api.addPostDeployStep('kik', (options, lambdaDetails, utils) => {\n    return Promise.resolve()\n      .then(() => {\n        if (options['configure-kik-bot']) {\n          console.log(`\\n\\n${color.green}Kik setup${color.reset}\\n`);\n          console.log(`\\nFollowing info is required for the setup, for more info check the documentation.\\n`);\n          console.log(`\\nYour Kik bot Request URL (POST only) is ${color.cyan}${lambdaDetails.apiUrl}/kik${color.reset}\\n`);\n\n          return prompt(['Kik Bot Username', 'Kik Api Key'])\n            .then(results => {\n              const deployment = {\n                restApiId: lambdaDetails.apiId,\n                stageName: lambdaDetails.alias,\n                variables: {\n                  kikUserName: results['Kik Bot Username'],\n                  kikApiKey: results['Kik Api Key']\n                }\n              };\n\n              return utils.apiGatewayPromise.createDeploymentPromise(deployment)\n                .then(() => {\n\n                  let options = {\n                    headers: {\n                      'Content-Type': 'application/json',\n                      'Authorization': `Basic ${new Buffer(deployment.variables.kikUserName + ':' + deployment.variables.kikApiKey).toString('base64')}`\n                    },\n                    body: JSON.stringify({\n                      webhook: `${lambdaDetails.apiUrl}/kik`,\n                      features: {\n                        receiveReadReceipts: false,\n                        receiveIsTyping: false,\n                        manuallySendReadReceipts: false,\n                        receiveDeliveryReceipts: false\n                      }\n                    })\n                  };\n                  return rp.post(`https://api.kik.com/v1/config`, options);\n                });\n            });\n        }\n      })\n      .then(() => `${lambdaDetails.apiUrl}/kik`);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/kik/reply.js":"'use strict';\nconst rp = require('minimal-request-promise');\n\nfunction kikReply(messageObject, message, username, kikApiKey) {\n  var data = { messages: [{\n    body: typeof message === 'string' ?  message : message.text,\n    to: messageObject.sender,\n    type: messageObject.kikType,\n    chatId: messageObject.chatId\n  }]};\n  \n  const options = {\n    headers: {\n      'Authorization': `Basic ${new Buffer(username + ':' + kikApiKey).toString('base64')}`,\n      'content-type': 'application/json'\n    },\n    body: JSON.stringify(data)\n  };\n\n  return rp.post('https://api.kik.com/v1/message', options);\n}\n\nmodule.exports = kikReply;","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/kik/parse.js":"'use strict';\n\nmodule.exports = function(messageObject) {\n\n  if (messageObject && messageObject.type == 'text' && messageObject.chatId){\n    return {\n      sender: messageObject.from,\n      text: messageObject.body,\n      chatId: messageObject.chatId,\n      kikType: messageObject.type,\n      originalRequest: messageObject,\n      type: 'kik'\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/groupme/setup.js":"'use strict';\n\nconst prompt = require('souffleur');\nconst gmReply = require('./reply');\nconst gmParse = require('./parse');\nconst color = require('../console-colors');\n\nmodule.exports = function gmSetup(api, bot, logError, optionalParser, optionalResponder) {\n  let parser = optionalParser || gmParse;\n  let responder = optionalResponder || gmReply;\n\n  api.post('/groupme', request => {\n    let arr = request.body instanceof Array ? [].concat.apply([], request.body) : [request.body];\n\n    let gmHandle = parsedMessage => {\n      if (!parsedMessage) return;\n      return Promise.resolve(parsedMessage).then(parsedMessage => bot(parsedMessage, request))\n        .then(botResponse => responder(botResponse, request.env.GROUPME_BOT_ID))\n        .catch(logError);\n    };\n\n    return Promise.all(arr.map(message => gmHandle(parser(message))))\n      .then(() => 'ok');\n  });\n\n  api.addPostDeployStep('groupme', (options, lambdaDetails, utils) => {\n    return Promise.resolve()\n      .then(() => {\n        if (options['configure-groupme-bot']) {\n          console.log(`\\n\\n${color.green}GroupMe setup${color.reset}\\n`);\n          console.log(`\\nFollowing info is required for the setup, for more info check the documentation.\\n`);\n          console.log(`\\nYour GroupMe bot Request URL (POST only) is ${color.cyan}${lambdaDetails.apiUrl}/groupme${color.reset}\\n`);\n\n          return prompt(['GroupMe Bot Id'])\n            .then(results => {\n              const deployment = {\n                restApiId: lambdaDetails.apiId,\n                stageName: lambdaDetails.alias,\n                variables: {\n                  GROUPME_BOT_ID: results['GroupMe Bot Id']\n                }\n              };\n\n              return utils.apiGatewayPromise.createDeploymentPromise(deployment);\n            });\n        }\n      })\n      .then(() => `${lambdaDetails.apiUrl}/groupme`);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/groupme/reply.js":"'use strict';\nconst rp = require('minimal-request-promise');\n\nfunction gmReply(message, botId) {\n  var data = {\n    bot_id: botId,\n    text: typeof message === 'string' ? message : message.text\n  };\n  \n  const options = {\n    headers: {\n      'content-type': 'application/json'\n    },\n    body: JSON.stringify(data)\n  };\n\n  return rp.post('https://api.groupme.com/v3/bots/post', options);\n}\n\nmodule.exports = gmReply;","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/groupme/parse.js":"'use strict';\n\nmodule.exports = function(messageObject) {\n  if (messageObject && messageObject.text !== undefined &&\n    messageObject.group_id !== undefined && messageObject.sender_type !== 'bot'){\n    return {\n      sender: messageObject.group_id,\n      text: messageObject.text,\n      originalRequest: messageObject,\n      type: 'groupme'\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/line/setup.js":"'use strict';\n\nconst prompt = require('souffleur');\nconst lnReply = require('./reply');\nconst lnParse = require('./parse');\nconst color = require('../console-colors');\n\nmodule.exports = function lnSetup(api, bot, logError, optionalParser, optionalResponder) {\n  let parser = optionalParser || lnParse;\n  let responder = optionalResponder || lnReply;\n\n  api.post('/line', request => {\n    let arr = [].concat.apply([], request.body.events);\n    let lnHandle = parsedMessage => {\n      if (parsedMessage) {\n        let replyToken = parsedMessage.replyToken;\n\n        return Promise.resolve(parsedMessage).then(parsedMessage => bot(parsedMessage, request))\n        .then(botResponse => responder(replyToken, botResponse, new Buffer(request.env.lineChannelAccessToken, 'base64').toString('ascii')))\n        .catch(logError);\n      }\n    };\n\n    return Promise.all(arr.map(message => lnHandle(parser(message))))\n  .then(() => 'ok');\n  });\n\n  api.addPostDeployStep('line', (options, lambdaDetails, utils) => {\n    return Promise.resolve()\n      .then(() => {\n        if (options['configure-line-bot']) {\n          console.log(`\\n\\n${color.green}Line setup${color.reset}\\n`);\n          console.log(`\\nFollowing info is required for the setup, for more info check the documentation.\\n`);\n          console.log(`\\nYour LINE bot Request URL (POST only) is ${color.cyan}${lambdaDetails.apiUrl}/line${color.reset}\\n`);\n\n          return prompt(['LINE Channel Access Token'])\n            .then(results => {\n              const deployment = {\n                restApiId: lambdaDetails.apiId,\n                stageName: lambdaDetails.alias,\n                variables: {\n                  lineChannelAccessToken: new Buffer(results['LINE Channel Access Token']).toString('base64')\n                }\n              };\n              console.log(`\\n`);\n\n              return utils.apiGatewayPromise.createDeploymentPromise(deployment);\n            });\n        }\n      })\n      .then(() => `${lambdaDetails.apiUrl}/line`);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/line/reply.js":"'use strict';\nconst rp = require('minimal-request-promise');\n\nfunction lineReply(replyToken, message, lineChannelAccessToken) {\n  var messages = [];\n  if (typeof message === 'string') {\n    messages = [{\n      text: message,\n      type: 'text'\n    }];\n  } else if (Array.isArray(message)) {\n    message.forEach(msg => {\n      if (typeof msg === 'string') {\n        let singleMessage = {\n          text: msg,\n          type: 'text'\n        };\n        messages.push(singleMessage);\n      } else {\n        messages.push(msg);\n      }\n    });\n  } else {\n    if(!message || !message.type) throw new Error('Your LINE message is required to have a type');\n    messages = [message];\n  }\n\n  let data = {\n    replyToken: replyToken,\n    messages: messages\n  };\n\n\n  const options = {\n    headers: {\n      'Authorization': `Bearer ${lineChannelAccessToken}`,\n      'Content-Type': 'application/json; charset=utf-8',\n      'Content-Length': Buffer.byteLength(JSON.stringify(data), 'utf8')\n    },\n    body: JSON.stringify(data)\n  };\n\n  return rp.post('https://api.line.me/v2/bot/message/reply', options);\n}\n\nmodule.exports = lineReply;\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/line/parse.js":"'use strict';\n\nmodule.exports = function(messageObject) {\n  if (messageObject && messageObject.type && messageObject.replyToken &&\n    messageObject.source && messageObject.source.userId){\n    return {\n      sender: messageObject.source.userId,\n      replyToken: messageObject.replyToken,\n      text: messageObject.type == 'message' ? messageObject.message.text : '',\n      originalRequest: messageObject,\n      type: 'line'\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/viber/setup.js":"'use strict';\n\nconst rp = require('minimal-request-promise');\nconst prompt = require('souffleur');\nconst vbReply = require('./reply');\nconst vbParse = require('./parse');\nconst color = require('../console-colors');\n\nmodule.exports = function vbSetup(api, bot, logError, optionalParser, optionalResponder) {\n  let parser = optionalParser || vbParse;\n  let responder = optionalResponder || vbReply;\n\n  api.post('/viber', request => {\n    let vbMessage = request.body;\n\n    let parsedMessage = parser(vbMessage);\n\n    if (!parsedMessage){\n      return Promise.resolve('ok');\n    }\n    return Promise.resolve(parsedMessage)\n      .then(parsedMessage => bot(parsedMessage, request))\n      .then(botResponse => responder(parsedMessage.sender, botResponse, request.env.viberAccessToken))\n      .catch(logError);\n  });\n\n  api.addPostDeployStep('viber', (options, lambdaDetails, utils) => {\n    return Promise.resolve()\n      .then(() => {\n        if (options['configure-viber-bot']) {\n          console.log(`\\n\\n${color.green}Viber setup${color.reset}\\n`);\n          console.log(`\\nFollowing info is required for the setup, for more info check the documentation.\\n`);\n          console.log(`\\nYour Viber bot Request URL (POST only) is ${color.cyan}${lambdaDetails.apiUrl}/viber${color.reset}\\n`);\n\n          return prompt(['Viber Access Token'])\n            .then(results => {\n              const deployment = {\n                restApiId: lambdaDetails.apiId,\n                stageName: lambdaDetails.alias,\n                variables: {\n                  viberAccessToken: results['Viber Access Token']\n                }\n              };\n\n              return utils.apiGatewayPromise.createDeploymentPromise(deployment)\n                .then(() => {\n                  let body = JSON.stringify({\n                    auth_token: deployment.variables.viberAccessToken,\n                    url: `${lambdaDetails.apiUrl}/viber`,\n                    event_types: ['delivered', 'seen']\n                  });\n                  let options = {\n                    headers: {\n                      'Content-Type': 'application/json',\n                      'Content-Length': Buffer.byteLength(body, 'utf8')\n                    },\n                    body: body\n                  };\n                  return rp.post(`https://chatapi.viber.com/pa/set_webhook`, options);\n                });\n            });\n        }\n      })\n      .then(() => `${lambdaDetails.apiUrl}/viber`);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/viber/reply.js":"'use strict';\nconst rp = require('minimal-request-promise');\n\nfunction sendSingle(receiver, authToken, messageObj) {\n  let message;\n\n  if (typeof messageObj === 'string') {\n    message = {\n      type: 'text',\n      auth_token: authToken,\n      text: messageObj,\n      receiver: receiver\n    };\n  } else {\n    message = messageObj;\n    if (!message.auth_token)\n      message.auth_token = authToken;\n    if (!message.receiver)\n      message.receiver = receiver;\n  }\n  const body = JSON.stringify(message);\n  const options = {\n    headers: {\n      'Content-Type': 'application/json',\n      'Content-Length': Buffer.byteLength(body, 'utf8')\n    },\n    body: body\n  };\n\n  return rp.post('https://chatapi.viber.com/pa/send_message', options);\n}\n\nfunction sendAll(receiver, authToken, messages) {\n  if (!messages.length) {\n    return Promise.resolve();\n  } else {\n    return sendSingle(receiver, authToken, messages.shift())\n      .then(() => sendAll(receiver, authToken, messages));\n  }\n}\n\nfunction sendReply(receiver, messages, authToken) {\n  if (!Array.isArray(messages))\n    messages = [messages];\n\n  return sendAll(receiver, authToken, messages);\n}\n\nmodule.exports = sendReply;\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/viber/parse.js":"'use strict';\n\nmodule.exports = function(messageObject) {\n\n  if (messageObject && messageObject.message){\n    return {\n      sender: messageObject.sender.id,\n      text: (typeof messageObject.message === 'object' && messageObject.message.type === 'text')  ? messageObject.message.text : '',\n      originalRequest: messageObject,\n      type: 'viber'\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/alexa/setup.js":"'use strict';\n\nconst prompt = require('souffleur');\nconst alexaParse = require('./parse');\nconst alexaReply = require('./reply');\nconst color = require('../console-colors');\nconst envUtils = require('../utils/env-utils');\n\nmodule.exports = function alexaSetup(api, bot, logError, optionalParser, optionalResponder) {\n  let parser = optionalParser || alexaParse;\n  let responder = optionalResponder || alexaReply;\n\n  api.post('/alexa', request => {\n    return bot(parser(request.body), request)\n      .then(botReply => responder(botReply, envUtils.decode(request.env.alexaAppName)))\n      .catch(logError);\n  });\n\n  api.addPostDeployStep('alexa', (options, lambdaDetails, utils) => {\n    return Promise.resolve().then(() => {\n      if (options['configure-alexa-skill']) {\n        console.log(`\\n\\n${color.green}Alexa skill command setup${color.reset}\\n`);\n        console.log(`\\nConfigure your Alexa Skill endpoint to HTTPS and set this URL:.\\n`);\n        console.log(`\\n${color.cyan}${lambdaDetails.apiUrl}/alexa${color.reset}\\n`);\n        console.log(`\\nIn the SSL Certificate step, select \"${color.dim}My development endpoint is a sub-domain of a domain that has a wildcard certificate from a certificate authority${color.reset}\".\\n`);\n\n        return prompt(['Alexa bot name'])\n          .then(results => {\n            const deployment = {\n              restApiId: lambdaDetails.apiId,\n              stageName: lambdaDetails.alias,\n              variables: {\n                alexaAppName: envUtils.encode(results['Alexa bot name'])\n              }\n            };\n\n            console.log(`\\n`);\n\n            return utils.apiGatewayPromise.createDeploymentPromise(deployment);\n          });\n      }\n    })\n      .then(() => `${lambdaDetails.apiUrl}/alexa`);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/alexa/parse.js":"'use strict';\n\nfunction getSlotValues(slots) {\n  if (!slots) return '';\n  return Object.keys(slots).map(key => slots[key].value || '').join(' ');\n}\n\nmodule.exports = function alexaParse(messageObject) {\n  if (messageObject && messageObject.request && messageObject.request.intent && messageObject.request.intent.name\n    && messageObject.session && messageObject.session.user) {\n    return {\n      sender: messageObject.session.user.userId,\n      text: getSlotValues(messageObject.request.intent.slots) || '',\n      originalRequest: messageObject,\n      type: 'alexa-skill'\n    };\n  }\n\n  if (messageObject && messageObject.session && messageObject.session.user) {\n    return {\n      sender: messageObject.session.user.userId,\n      text: '',\n      originalRequest: messageObject,\n      type: 'alexa-skill'\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/alexa/reply.js":"'use strict';\n\nmodule.exports = function alexaReply(botResponse, botName) {\n  if (typeof botResponse === 'string' && botName)\n    return {\n      response: {\n        outputSpeech: {\n          type: 'PlainText',\n          text: botResponse\n        },\n        card: {\n          type: 'Simple',\n          title: botName || '',\n          content: botResponse\n        },\n        shouldEndSession: true\n      }\n    };\n\n  return botResponse;\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/utils/env-utils.js":"'use strict';\n\nmodule.exports = {\n  encode(str) {\n    return new Buffer(str).toString('base64').replace(/\\+/g, '-');\n  },\n  decode(str) {\n    return new Buffer(str.replace(/\\-/g, '+'), 'base64').toString('utf8');\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/facebook/format-message.js":"'use strict';\n\nconst isUrl = require('../is-url');\nconst breakText = require('../breaktext');\n\nfunction isNumber(number) {\n  return !isNaN(parseFloat(number)) && isFinite(number);\n}\n\nclass FacebookTemplate {\n  constructor() {\n    this.template = {};\n  }\n\n  setNotificationType(type) {\n    if (type !== 'REGULAR' && type !== 'SILENT_PUSH' && type !== 'NO_PUSH')\n      throw new Error('Notification type must be one of REGULAR, SILENT_PUSH, or NO_PUSH');\n    this.template.notification_type = type;\n    return this;\n  }\n\n  addQuickReply(text, payload, imageUrl) {\n    if (!text || !payload)\n      throw new Error('Both text and payload are required for a quick reply');\n\n    if (payload.length > 1000)\n      throw new Error('Payload can not be more than 1000 characters long');\n    if (imageUrl && !isUrl(imageUrl))\n      throw new Error('Image has a bad url');\n\n    if (!this.template.quick_replies)\n      this.template.quick_replies = [];\n\n    if (this.template.quick_replies.length === 11)\n      throw new Error('There can not be more than 11 quick replies');\n\n    if (text.length > 20)\n      text = breakText(text, 20)[0];\n\n    let quickReply = {\n      content_type: 'text',\n      title: text,\n      payload: payload\n    };\n\n    if (imageUrl) quickReply.image_url = imageUrl;\n\n    this.template.quick_replies.push(quickReply);\n\n    return this;\n  }\n\n  addQuickReplyLocation() {\n    if (!this.template.quick_replies)\n      this.template.quick_replies = [];\n\n    if (this.template.quick_replies.length === 11)\n      throw new Error('There can not be more than 11 quick replies');\n\n    let quickReply = {\n      content_type: 'location'\n    };\n\n    this.template.quick_replies.push(quickReply);\n\n    return this;\n  }\n\n  get() {\n    return this.template;\n  }\n}\n\nclass Text extends FacebookTemplate {\n  constructor(text) {\n    super();\n\n    if (!text)\n      throw new Error('Text is required for text template');\n\n    this.template = {\n      text: text\n    };\n  }\n}\n\nclass Attachment extends FacebookTemplate {\n  constructor(url, type) {\n    super();\n\n    if (!url || !isUrl(url))\n      throw new Error('Attachment template requires a valid URL as a first parameter');\n\n    this.template = {\n      attachment: {\n        type: type || 'file',\n        payload: {\n          url: url\n        }\n      }\n    };\n  }\n}\n\nclass Image extends FacebookTemplate {\n  constructor(url) {\n    super();\n\n    if (!url || !isUrl(url))\n      throw new Error('Image template requires a valid URL as a first parameter');\n\n    this.template = {\n      attachment: {\n        type: 'image',\n        payload: {\n          url: url\n        }\n      }\n    };\n  }\n}\n\nclass Audio extends FacebookTemplate {\n  constructor(url) {\n    super();\n\n    if (!url || !isUrl(url))\n      throw new Error('Audio template requires a valid URL as a first parameter');\n\n    this.template = {\n      attachment: {\n        type: 'audio',\n        payload: {\n          url: url\n        }\n      }\n    };\n  }\n}\n\nclass Video extends FacebookTemplate {\n  constructor(url) {\n    super();\n\n    if (!url || !isUrl(url))\n      throw new Error('Video template requires a valid URL as a first parameter');\n\n    this.template = {\n      attachment: {\n        type: 'video',\n        payload: {\n          url: url\n        }\n      }\n    };\n  }\n}\n\nclass File extends FacebookTemplate {\n  constructor(url) {\n    super();\n\n    if (!url || !isUrl(url))\n      throw new Error('File attachment template requires a valid URL as a first parameter');\n\n    this.template = {\n      attachment: {\n        type: 'file',\n        payload: {\n          url: url\n        }\n      }\n    };\n  }\n}\n\nclass Generic extends FacebookTemplate {\n  constructor() {\n    super();\n\n    this.bubbles = [];\n\n    this.template = {\n      attachment: {\n        type: 'template',\n        payload: {\n          template_type: 'generic',\n          elements: []\n        }\n      }\n    };\n  }\n\n  useSquareImages() {\n    this.template.attachment.payload.image_aspect_ratio = 'square';\n\n    return this;\n  }\n\n  getLastBubble() {\n    if (!this.bubbles || !this.bubbles.length)\n      throw new Error('Add at least one bubble first!');\n\n    return this.bubbles[this.bubbles.length - 1];\n  }\n\n  addBubble(title, subtitle) {\n    if (this.bubbles.length === 10)\n      throw new Error('10 bubbles are maximum for Generic template');\n\n    if (!title)\n      throw new Error('Bubble title cannot be empty');\n\n    if (title.length > 80)\n      throw new Error('Bubble title cannot be longer than 80 characters');\n\n    if (subtitle && subtitle.length > 80)\n      throw new Error('Bubble subtitle cannot be longer than 80 characters');\n\n    let bubble = {\n      title: title\n    };\n\n    if (subtitle)\n      bubble['subtitle'] = subtitle;\n\n    this.bubbles.push(bubble);\n\n    return this;\n  }\n\n  addUrl(url) {\n    if (!url)\n      throw new Error('URL is required for addUrl method');\n\n    if (!isUrl(url))\n      throw new Error('URL needs to be valid for addUrl method');\n\n    this.getLastBubble()['item_url'] = url;\n\n    return this;\n  }\n\n  addImage(url) {\n    if (!url)\n      throw new Error('Image URL is required for addImage method');\n\n    if (!isUrl(url))\n      throw new Error('Image URL needs to be valid for addImage method');\n\n    this.getLastBubble()['image_url'] = url;\n\n    return this;\n  }\n\n  addButtonByType(title, value, type, options) {\n    if (!title)\n      throw new Error('Button title cannot be empty');\n\n    const bubble = this.getLastBubble();\n\n    bubble.buttons = bubble.buttons || [];\n\n    if (bubble.buttons.length === 3)\n      throw new Error('3 buttons are already added and that\\'s the maximum');\n\n    if (!title)\n      throw new Error('Button title cannot be empty');\n\n    const button = {\n      title: title,\n      type: type || 'postback'\n    };\n\n    if (type === 'web_url') {\n      button.url = value;\n    } else if (type === 'account_link') {\n      delete button.title;\n      button.url = value;\n    } else if (type === 'phone_number') {\n      button.payload = value;\n    } else if (type === 'payment') {\n      button.payload = value;\n      button.payment_summary = options.paymentSummary;\n    } else if (type === 'element_share' || type === 'account_unlink') {\n      delete button.title;\n      if (type === 'element_share' && options && typeof options.shareContent)\n        button.share_contents = options.shareContent;\n    } else {\n      button.type = 'postback';\n      button.payload = value;\n    }\n\n    bubble.buttons.push(button);\n\n    return this;\n  }\n\n  addButton(title, value) {\n    // Keeping this to prevent breaking change\n    if (!title)\n      throw new Error('Button title cannot be empty');\n\n    if (!value)\n      throw new Error('Button value is required');\n\n    if (isUrl(value)) {\n      return this.addButtonByType(title, value, 'web_url');\n    } else {\n      return this.addButtonByType(title, value, 'postback');\n    }\n  }\n\n  addCallButton(title, phoneNumber) {\n    if (!/^\\+[0-9]{4,20}$/.test(phoneNumber))\n      throw new Error('Call button value needs to be a valid phone number in following format: +1234567...');\n\n    return this.addButtonByType(title, phoneNumber, 'phone_number');\n  }\n\n  addShareButton(shareContent) {\n    return this.addButtonByType('Share', null, 'element_share', {\n      shareContent: shareContent || null\n    });\n  }\n\n  addBuyButton(title, value, paymentSummary) {\n    if (!value)\n      throw new Error('Button value is required');\n\n    if (typeof paymentSummary !== 'object')\n      throw new Error('Payment summary is required for buy button');\n\n    return this.addButtonByType(title, value, 'payment', {\n      paymentSummary: paymentSummary\n    });\n  }\n\n  addLoginButton(url) {\n    if (!isUrl(url))\n      throw new Error('Valid URL is required for Login button');\n\n    return this.addButtonByType('Login', url, 'account_link');\n  }\n\n  addLogoutButton() {\n    return this.addButtonByType('Logout', null, 'account_unlink');\n  }\n\n  get() {\n    if (!this.bubbles || !this.bubbles.length)\n      throw new Error('Add at least one bubble first!');\n\n    this.template.attachment.payload.elements = this.bubbles;\n\n    return this.template;\n  }\n}\n\nclass Button extends FacebookTemplate {\n  constructor(text) {\n    super();\n\n    if (!text)\n      throw new Error('Button template text cannot be empty');\n\n    if (text.length > 640)\n      throw new Error('Button template text cannot be longer than 640 characters');\n\n    this.template = {\n      attachment: {\n        type: 'template',\n        payload: {\n          template_type: 'button',\n          text: text,\n          buttons: []\n        }\n      }\n    };\n  }\n\n  addButtonByType(title, value, type, options) {\n    if (!title)\n      throw new Error('Button title cannot be empty');\n\n    if (this.template.attachment.payload.buttons.length === 3)\n      throw new Error('3 buttons are already added and that\\'s the maximum');\n\n    const button = {\n      title: title,\n      type: type || 'postback'\n    };\n\n    if (type === 'web_url') {\n      button.url = value;\n    } else if (type === 'account_link') {\n      delete button.title;\n      button.url = value;\n    } else if (type === 'phone_number') {\n      button.payload = value;\n    } else if (type === 'payment') {\n      button.payload = value;\n      button.payment_summary = options.paymentSummary;\n    } else if (type === 'element_share' || type === 'account_unlink') {\n      delete button.title;\n      if (type === 'element_share' && options && typeof options.shareContent)\n        button.share_contents = options.shareContent;\n    } else {\n      button.type = 'postback';\n      button.payload = value;\n    }\n\n    this.template.attachment.payload.buttons.push(button);\n\n    return this;\n  }\n\n  addButton(title, value) {\n    // Keeping this to prevent breaking change\n    if (!title)\n      throw new Error('Button title cannot be empty');\n\n    if (!value)\n      throw new Error('Button value is required');\n\n    if (isUrl(value)) {\n      return this.addButtonByType(title, value, 'web_url');\n    } else {\n      return this.addButtonByType(title, value, 'postback');\n    }\n  }\n\n  addCallButton(title, phoneNumber) {\n    if (!/^\\+[0-9]{4,20}$/.test(phoneNumber))\n      throw new Error('Call button value needs to be a valid phone number in following format: +1234567...');\n\n    return this.addButtonByType(title, phoneNumber, 'phone_number');\n  }\n\n  addShareButton(shareContent) {\n    return this.addButtonByType('Share', null, 'element_share', {\n      shareContent: shareContent || null\n    });\n  }\n\n  addBuyButton(title, value, paymentSummary) {\n    if (!value)\n      throw new Error('Button value is required');\n\n    if (typeof paymentSummary !== 'object')\n      throw new Error('Payment summary is required for buy button');\n\n    return this.addButtonByType(title, value, 'payment', {\n      paymentSummary: paymentSummary\n    });\n  }\n\n  addLoginButton(url) {\n    if (!isUrl(url))\n      throw new Error('Valid URL is required for Login button');\n\n    return this.addButtonByType('Login', url, 'account_link');\n  }\n\n  addLogoutButton() {\n    return this.addButtonByType('Logout', null, 'account_unlink');\n  }\n\n  get() {\n    if (this.template.attachment.payload.buttons.length === 0)\n      throw new Error('Add at least one button first!');\n\n    return this.template;\n  }\n}\n\nclass Receipt extends FacebookTemplate {\n  constructor(name, orderNumber, currency, paymentMethod) {\n    super();\n\n    if (!name)\n      throw new Error('Recipient\\'s name cannot be empty');\n\n    if (!orderNumber)\n      throw new Error('Order number cannot be empty');\n\n    if (!currency)\n      throw new Error('Currency cannot be empty');\n\n    if (!paymentMethod)\n      throw new Error('Payment method cannot be empty');\n\n    this.template = {\n      attachment: {\n        type: 'template',\n        payload: {\n          template_type: 'receipt',\n          recipient_name: name,\n          order_number: orderNumber,\n          currency: currency,\n          payment_method: paymentMethod,\n          elements: [],\n          summary: {}\n        }\n      }\n    };\n  }\n\n  addTimestamp(timestamp) {\n    if (!timestamp)\n      throw new Error('Timestamp is required for addTimestamp method');\n\n    if (!(timestamp instanceof Date))\n      throw new Error('Timestamp needs to be a valid Date object');\n\n    this.template.attachment.payload.timestamp = timestamp.getTime();\n\n    return this;\n  }\n\n  addOrderUrl(url) {\n    if (!url)\n      throw new Error('Url is required for addOrderUrl method');\n\n    if (!isUrl(url))\n      throw new Error('Url needs to be valid for addOrderUrl method');\n\n    this.template.attachment.payload.order_url = url;\n\n    return this;\n  }\n\n  getLastItem() {\n    if (!this.template.attachment.payload.elements || !this.template.attachment.payload.elements.length)\n      throw new Error('Add at least one order item first!');\n\n    return this.template.attachment.payload.elements[this.template.attachment.payload.elements.length - 1];\n  }\n\n  addItem(title) {\n    if (!title)\n      throw new Error('Item title is required');\n\n    this.template.attachment.payload.elements.push({\n      title: title\n    });\n\n    return this;\n  }\n\n  addSubtitle(subtitle) {\n    if (!subtitle)\n      throw new Error('Subtitle is required for addSubtitle method');\n\n    let item = this.getLastItem();\n\n    item.subtitle = subtitle;\n\n    return this;\n  }\n\n  addQuantity(quantity) {\n    if (!quantity)\n      throw new Error('Quantity is required for addQuantity method');\n\n    if (!isNumber(quantity))\n      throw new Error('Quantity needs to be a number');\n\n    let item = this.getLastItem();\n\n    item.quantity = quantity;\n\n    return this;\n  }\n\n  addPrice(price) {\n    if (!price)\n      throw new Error('Price is required for addPrice method');\n\n    if (!isNumber(price))\n      throw new Error('Price needs to be a number');\n\n    let item = this.getLastItem();\n\n    item.price = price;\n\n    return this;\n  }\n\n  addCurrency(currency) {\n    if (!currency)\n      throw new Error('Currency is required for addCurrency method');\n\n    let item = this.getLastItem();\n\n    item.currency = currency;\n\n    return this;\n  }\n\n  addImage(image) {\n    if (!image)\n      throw new Error('Absolute url is required for addImage method');\n\n    if (!isUrl(image))\n      throw new Error('Valid absolute url is required for addImage method');\n\n    let item = this.getLastItem();\n\n    item.image_url = image;\n\n    return this;\n  }\n\n  addShippingAddress(street1, street2, city, zip, state, country) {\n    if (!street1)\n      throw new Error('Street is required for addShippingAddress');\n\n    if (!city)\n      throw new Error('City is required for addShippingAddress method');\n\n    if (!zip)\n      throw new Error('Zip code is required for addShippingAddress method');\n\n    if (!state)\n      throw new Error('State is required for addShippingAddress method');\n\n    if (!country)\n      throw new Error('Country is required for addShippingAddress method');\n\n    this.template.attachment.payload.address = {\n      street_1: street1,\n      street_2: street2 || '',\n      city: city,\n      postal_code: zip,\n      state: state,\n      country: country\n    };\n\n    return this;\n  }\n\n  addAdjustment(name, amount) {\n    if (!amount || !isNumber(amount))\n      throw new Error('Adjustment amount must be a number');\n\n    let adjustment = {};\n\n    if (name)\n      adjustment.name = name;\n\n    if (amount)\n      adjustment.amount = amount;\n\n    if (name || amount) {\n      this.template.attachment.payload.adjustments = this.template.attachment.payload.adjustments || [];\n      this.template.attachment.payload.adjustments.push(adjustment);\n    }\n\n    return this;\n  }\n\n  addSubtotal(subtotal) {\n    if (!subtotal)\n      throw new Error('Subtotal is required for addSubtotal method');\n\n    if (!isNumber(subtotal))\n      throw new Error('Subtotal must be a number');\n\n    this.template.attachment.payload.summary.subtotal = subtotal;\n\n    return this;\n  }\n\n  addShippingCost(shippingCost) {\n    if (!shippingCost)\n      throw new Error('shippingCost is required for addShippingCost method');\n\n    if (!isNumber(shippingCost))\n      throw new Error('Shipping cost must be a number');\n\n    this.template.attachment.payload.summary.shipping_cost = shippingCost;\n\n    return this;\n  }\n\n  addTax(tax) {\n    if (!tax)\n      throw new Error('Total tax amount is required for addSubtotal method');\n\n    if (!isNumber(tax))\n      throw new Error('Total tax amount must be a number');\n\n    this.template.attachment.payload.summary.total_tax = tax;\n\n    return this;\n  }\n\n  addTotal(total) {\n    if (!total)\n      throw new Error('Total amount is required for addSubtotal method');\n\n    if (!isNumber(total))\n      throw new Error('Total amount must be a number');\n\n    this.template.attachment.payload.summary.total_cost = total;\n\n    return this;\n  }\n\n  get() {\n    if (!this.template.attachment.payload.elements.length)\n      throw new Error('At least one element/item is required');\n\n    if (!this.template.attachment.payload.summary.total_cost)\n      throw new Error('Total amount is required');\n\n    return this.template;\n  }\n}\n\nclass List extends FacebookTemplate {\n  constructor(topElementStyle) {\n    super();\n\n    this.bubbles = [];\n\n    this.template = {\n      attachment: {\n        type: 'template',\n        payload: {\n          template_type: 'list',\n          top_element_style: topElementStyle ? topElementStyle : 'large',\n          elements: [],\n          buttons: []\n        }\n      }\n    };\n  }\n\n  getFirstBubble() {\n    if (!this.bubbles || !this.bubbles.length)\n      throw new Error('Add at least one bubble first!');\n\n    return this.bubbles[0];\n  }\n\n  getLastBubble() {\n    if (!this.bubbles || !this.bubbles.length)\n      throw new Error('Add at least one bubble first!');\n\n    return this.bubbles[this.bubbles.length - 1];\n  }\n\n  addBubble(title, subtitle) {\n    if (this.bubbles.length === 4)\n      throw new Error('4 bubbles are maximum for List template');\n\n    if (!title)\n      throw new Error('Bubble title cannot be empty');\n\n    if (title.length > 80)\n      throw new Error('Bubble title cannot be longer than 80 characters');\n\n    if (subtitle && subtitle.length > 80)\n      throw new Error('Bubble subtitle cannot be longer than 80 characters');\n\n    let bubble = {\n      title: title\n    };\n\n    if (subtitle)\n      bubble['subtitle'] = subtitle;\n\n    this.bubbles.push(bubble);\n\n    return this;\n  }\n\n  addImage(url) {\n    if (!url)\n      throw new Error('Image URL is required for addImage method');\n\n    if (!isUrl(url))\n      throw new Error('Image URL needs to be valid for addImage method');\n\n    this.getLastBubble()['image_url'] = url;\n\n    return this;\n  }\n\n  addDefaultAction(url) {\n    const bubble = this.getLastBubble();\n\n    if (bubble.default_action)\n      throw new Error('Bubble already has default action');\n\n    if (!url)\n      throw new Error('Bubble default action URL is required');\n\n    if (!isUrl(url))\n      throw new Error('Bubble default action URL must be valid URL');\n\n    bubble.default_action = {\n      type: 'web_url',\n      url: url\n    };\n\n    return this;\n  }\n\n  addButton(title, value, type) {\n    const bubble = this.getLastBubble();\n\n    bubble.buttons = bubble.buttons || [];\n\n    if (bubble.buttons.length === 1)\n      throw new Error('One button is already added and that\\'s the maximum');\n\n    if (!title)\n      throw new Error('Button title cannot be empty');\n\n    if (!value)\n      throw new Error('Button value is required');\n\n    const button = {\n      title: title\n    };\n\n    if (isUrl(value)) {\n      button.type = 'web_url';\n      button.url = value;\n    } else {\n      button.type = 'postback';\n      button.payload = value;\n    }\n\n    if (type) {\n      button.type = type;\n    }\n\n    bubble.buttons.push(button);\n\n    return this;\n  }\n\n  addShareButton() {\n    const bubble = this.getLastBubble();\n\n    bubble.buttons = bubble.buttons || [];\n\n    if (bubble.buttons.length === 1)\n      throw new Error('One button is already added and that\\'s the maximum');\n    const button = {\n      type: 'element_share'\n    };\n\n    bubble.buttons.push(button);\n\n    return this;\n  }\n\n  addListButton(title, value, type) {\n    if (this.template.attachment.payload.buttons.length === 1)\n      throw new Error('One List button is already added and that\\'s the maximum');\n\n    if (!title)\n      throw new Error('List button title cannot be empty');\n\n    if (!value)\n      throw new Error('List button value is required');\n\n    const button = {\n      title: title\n    };\n\n    if (isUrl(value)) {\n      button.type = 'web_url';\n      button.url = value;\n    } else {\n      button.type = 'postback';\n      button.payload = value;\n    }\n\n    if (type) {\n      button.type = type;\n    }\n\n    this.template.attachment.payload.buttons.push(button);\n\n    return this;\n  }\n\n  get() {\n    if (!this.bubbles || !this.bubbles.length || this.bubbles.length < 2)\n      throw new Error('2 bubbles are minimum for List template!');\n\n    if (this.template.attachment.payload.top_element_style === 'large' && !this.getFirstBubble()['image_url'])\n      throw new Error('You need to add image to the first bubble because you use `large` top element style');\n\n    this.template.attachment.payload.elements = this.bubbles;\n\n    return this.template;\n  }\n}\n\nclass ChatAction {\n  constructor(action) {\n    const AVAILABLE_TYPES = ['typing_on', 'typing_off', 'mark_seen'];\n\n    if (AVAILABLE_TYPES.indexOf(action) < 0)\n      throw new Error('Valid action is required for Facebook ChatAction template. Available actions are: typing_on, typing_off and mark_seen.');\n\n    this.template = {\n      sender_action: action\n    };\n  }\n\n  get() {\n    return this.template;\n  }\n}\n\nclass Pause {\n  constructor(milliseconds) {\n    this.template = {\n      claudiaPause: milliseconds || 500\n    };\n  }\n\n  get() {\n    return this.template;\n  }\n}\n\n/* Deprecated methods */\nclass text extends Text {\n  constructor(text) {\n    super(text);\n    console.log('Deprecation notice: please use .Text instead of .text method, lower case method names will be removed in next major version of Claudia bot builder');\n  }\n}\n\nclass attachment extends Attachment {\n  constructor(url, type) {\n    super(url, type);\n    console.log('Deprecation notice: please use .Attachment instead of .attachment method, lower case method names will be removed in next major version of Claudia bot builder');\n  }\n}\n\nclass image extends Image {\n  constructor(url) {\n    super(url);\n    console.log('Deprecation notice: please use .Image instead of .image method, lower case method names will be removed in next major version of Claudia bot builder');\n  }\n}\n\nclass audio extends Audio {\n  constructor(url) {\n    super(url);\n    console.log('Deprecation notice: please use .Audio instead of .audio method, lower case method names will be removed in next major version of Claudia bot builder');\n  }\n}\n\nclass video extends Video {\n  constructor(url) {\n    super(url);\n    console.log('Deprecation notice: please use .Video instead of .video method, lower case method names will be removed in next major version of Claudia bot builder');\n  }\n}\n\nclass file extends File {\n  constructor(url) {\n    super(url);\n    console.log('Deprecation notice: please use .File instead of .file method, lower case method names will be removed in next major version of Claudia bot builder');\n  }\n}\n\nclass generic extends Generic {\n  constructor() {\n    super();\n    console.log('Deprecation notice: please use .Generic instead of .generic method, lower case method names will be removed in next major version of Claudia bot builder');\n  }\n}\n\nclass button extends Button {\n  constructor(text) {\n    super(text);\n    console.log('Deprecation notice: please use .Button instead of .button method, lower case method names will be removed in next major version of Claudia bot builder');\n  }\n}\n\nclass receipt extends Receipt {\n  constructor(name, orderNumber, currency, paymentMethod) {\n    super(name, orderNumber, currency, paymentMethod);\n    console.log('Deprecation notice: please use .Receipt instead of .receipt method, lower case method names will be removed in next major version of Claudia bot builder');\n  }\n}\n\nmodule.exports = {\n  BaseTemplate: FacebookTemplate,\n  Text: Text,\n  Attachment: Attachment,\n  Image: Image,\n  Audio: Audio,\n  Video: Video,\n  File: File,\n  Generic: Generic,\n  Button: Button,\n  Receipt: Receipt,\n  List: List,\n  ChatAction: ChatAction,\n  Pause: Pause,\n  // Deprecated methods\n  text: text,\n  attachment: attachment,\n  image: image,\n  audio: audio,\n  video: video,\n  file: file,\n  generic: generic,\n  button: button,\n  receipt: receipt\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/is-url.js":"'use strict';\n\nmodule.exports = function isUrl(url) {\n  const pattern = /^[-a-zA-Z0-9@:%_\\+.~#?&//=]{2,256}\\.[a-z]{2,63}\\b(\\/[-a-zA-Z0-9@:%_\\(\\)\\+.,~#?&//=]*)?$/gi;\n  return pattern.test(url);\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/slack/format-message.js":"'use strict';\n\nconst isUrl = require('../is-url');\n\nclass SlackTemplate {\n  constructor(text) {\n    this.template = {\n      mrkdwn: true\n    };\n    this.template.attachments = [];\n\n    if (text)\n      this.template.text = text;\n  }\n\n  replaceOriginal(value) {\n    this.template.replace_original = !!value;\n    return this;\n  }\n\n  disableMarkdown(value) {\n    if (value)\n      this.template.mrkdwn = !value;\n\n    return this;\n  }\n\n  // This works for Slash commands only\n  channelMessage(value) {\n    if (value && value !== 'ephemeral')\n      this.template.response_type = 'in_channel';\n\n    return this;\n  }\n\n  getLatestAttachment() {\n    if (!this.template.attachments.length)\n      throw new Error('Add at least one attachment first');\n\n    return this.template.attachments[this.template.attachments.length - 1];\n  }\n\n  addAttachment(callbackId, fallback) {\n    if (this.template.attachments.length === 20)\n      throw new Error('You can not add more than 20 attachments');\n\n    const attachment = {\n      actions: []\n    };\n\n    if (callbackId)\n      attachment.callback_id = callbackId;\n\n    attachment.fallback = fallback || 'Slack told us that you are not able to see this attachment 😢';\n\n    this.template.attachments.push(attachment);\n\n    return this;\n  }\n\n  addTitle(text, link) {\n    if (!text)\n      throw new Error('Title text is required for addTitle method');\n\n    const attachment = this.getLatestAttachment();\n    attachment.title = text;\n    if (isUrl(link))\n      attachment.title_link = link;\n\n    return this;\n  }\n\n  addText(text) {\n    if (!text)\n      throw new Error('Text is required for addText method');\n\n    const attachment = this.getLatestAttachment();\n    attachment.text = text;\n\n    return this;\n  }\n\n  addPretext(text) {\n    if (!text)\n      throw new Error('Text is required for addPretext method');\n\n    const attachment = this.getLatestAttachment();\n    attachment.pretext = text;\n\n    return this;\n  }\n\n  addImage(url) {\n    if (!isUrl(url))\n      throw new Error('addImage method requires a valid URL');\n\n    const attachment = this.getLatestAttachment();\n    attachment.image_url = url;\n\n    return this;\n  }\n\n  addThumbnail(url) {\n    if (!isUrl(url))\n      throw new Error('addThumbnail method requires a valid URL');\n\n    const attachment = this.getLatestAttachment();\n    attachment.thumb_url = url;\n\n    return this;\n  }\n\n  addAuthor(name, icon, link) {\n    if (!name)\n      throw new Error('Name is required for addAuthor method');\n\n    const attachment = this.getLatestAttachment();\n    attachment.author_name = name;\n\n    if (icon)\n      attachment.author_icon = icon;\n\n    if (isUrl(link))\n      attachment.author_link = link;\n\n    return this;\n  }\n\n  addFooter(text, icon) {\n    if (!text)\n      throw new Error('Text is required for addFooter method');\n\n    const attachment = this.getLatestAttachment();\n    attachment.footer = text;\n\n    if (icon)\n      attachment.footer_icon = icon;\n\n    return this;\n  }\n\n  addColor(color) {\n    if (!color)\n      throw new Error('Color is required for addColor method');\n\n    const attachment = this.getLatestAttachment();\n    attachment.color = color;\n\n    return this;\n  }\n\n  addTimestamp(timestamp) {\n    if (!(timestamp instanceof Date))\n      throw new Error('Timestamp needs to be a valid Date object');\n\n    const attachment = this.getLatestAttachment();\n    attachment.ts = timestamp.getTime();\n\n    return this;\n  }\n\n  addField(title, value, isShort) {\n    if (!title || !value)\n      throw new Error('Title and value are required for addField method');\n\n    const attachment = this.getLatestAttachment();\n    if (!attachment.fields)\n      attachment.fields = [];\n\n    attachment.fields.push({\n      title: title,\n      value: value,\n      short: !!isShort\n    });\n\n    return this;\n  }\n\n  addAction(text, name, value, style) {\n    if (this.getLatestAttachment().actions.length === 5)\n      throw new Error('You can not add more than 5 actions');\n\n    if (!text || !name || !value)\n      throw new Error('Text, name and value are requeired for addAction method');\n\n    const action = {\n      text: text,\n      name: name,\n      value: value,\n      type: 'button'\n    };\n\n    if (style)\n      action.style = style;\n\n    this.getLatestAttachment().actions.push(action);\n\n    return this;\n  }\n\n  getLatestAction() {\n    const actions = this.getLatestAttachment().actions;\n\n    if (!actions.length)\n      throw new Error('At least one action is requeired for getLatestAction method');\n\n    return actions[actions.length - 1];\n  }\n\n  addConfirmation(title, text, okLabel, dismissLabel) {\n    const action = this.getLatestAction();\n\n    if (!title || !text)\n      throw new Error('Title and text are required for addConfirmation method');\n\n    action.confirm = {\n      title: title,\n      text: text,\n      ok_text: okLabel || 'Ok',\n      dismiss_text: dismissLabel || 'Dismiss'\n    };\n\n    return this;\n  }\n\n  get() {\n    return this.template;\n  }\n}\n\nmodule.exports = SlackTemplate;\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/telegram/format-message.js":"'use strict';\n\nclass TelegramMessage {\n  constructor() {\n    this.template = {};\n  }\n\n  disableNotification() {\n    this.template.disable_notification = true;\n  }\n\n  addReplyKeyboard(keyboardArray, resizeKeyboard, oneTimeKeyboard) {\n    if (!Array.isArray(keyboardArray))\n      throw new Error('KeyboardArray needs to be valid array of arrays for addReplyKeyboard method');\n\n    const replyKeyboard = {\n      keyboard: keyboardArray\n    };\n\n    if (resizeKeyboard)\n      replyKeyboard.resize_keyboard = true;\n\n    if (oneTimeKeyboard)\n      replyKeyboard.one_time_keyboard = true;\n\n    this.template.reply_markup = JSON.stringify(replyKeyboard);\n\n    return this;\n  }\n\n  addInlineKeyboard(keyboardArray) {\n    if (!Array.isArray(keyboardArray))\n      throw new Error('KeyboardArray needs to be valid array of arrays for addInlineKeyboard method');\n\n    const inlineKeyboard = {\n      inline_keyboard: keyboardArray\n    };\n\n    this.template.reply_markup = JSON.stringify(inlineKeyboard);\n\n    return this;\n  }\n\n  replyKeyboardHide(selective) {\n    const replyKeyboardHide = {\n      hide_keyboard: true,\n      selective: !!selective\n    };\n\n    this.template.reply_markup = JSON.stringify(replyKeyboardHide);\n\n    return this;\n  }\n\n  forceReply(selective) {\n    const forceReply = {\n      force_reply: true,\n      selective: !!selective\n    };\n\n    this.template.reply_markup = JSON.stringify(forceReply);\n\n    return this;\n  }\n\n  get() {\n    return this.template;\n  }\n}\n\nclass Text extends TelegramMessage {\n  constructor(text) {\n    super();\n    if (!text || typeof text !== 'string')\n      throw new Error('Text is required for Telegram Text template');\n\n    this.template = {\n      text: text,\n      parse_mode: 'Markdown'\n    };\n  }\n\n  disableMarkdown() {\n    delete this.template.parse_mode;\n    return this;\n  }\n}\n\nclass Photo extends TelegramMessage {\n  constructor(photo, caption) {\n    super();\n    if (!photo || typeof photo !== 'string')\n      throw new Error('Photo needs to be an ID or URL for Telegram Photo method');\n\n    this.template = {\n      photo: photo\n    };\n\n    if (caption && typeof caption === 'string')\n      this.template.caption = caption;\n  }\n\n  get() {\n    return {\n      method: 'sendPhoto',\n      body: this.template\n    };\n  }\n}\n\nclass Audio extends TelegramMessage {\n  constructor(audio, caption, duration) {\n    super();\n    if (!audio || typeof audio !== 'string')\n      throw new Error('Audio needs to be an ID or URL for Telegram Audio method');\n\n    this.template = {\n      audio: audio\n    };\n\n    if (caption && typeof caption === 'string')\n      this.template.caption = caption;\n\n    if (duration && typeof duration === 'number')\n      this.template.duration = duration;\n  }\n\n  addTitle(title) {\n    if (!title || typeof title != 'string')\n      throw new Error('Title is required for Telegram addTitle method');\n\n    this.template.title = title;\n\n    return this;\n  }\n\n  addPerformer(performer) {\n    if (!performer)\n      throw new Error('Performer is required for Telegram addPerformer method');\n\n    this.template.performer = performer;\n\n    return this;\n  }\n\n  get() {\n    return {\n      method: 'sendAudio',\n      body: this.template\n    };\n  }\n}\n\nclass Location extends TelegramMessage {\n  constructor(latitude, longitude) {\n    super();\n    if (!latitude || !longitude || typeof latitude !== 'number' || typeof longitude !== 'number')\n      throw new Error('Latitude and longitude are required for Telegram Location template');\n\n    this.template = {\n      latitude: latitude,\n      longitude: longitude\n    };\n  }\n\n  get() {\n    return {\n      method: 'sendLocation',\n      body: this.template\n    };\n  }\n}\n\nclass Venue extends TelegramMessage {\n  constructor(latitude, longitude, title, address) {\n    super();\n    if (!latitude || !longitude || typeof latitude !== 'number' || typeof longitude !== 'number')\n      throw new Error('Latitude and longitude are required for Telegram Venue template');\n\n    if (!title || typeof title !== 'string')\n      throw new Error('Title is required for Telegram Venue template');\n\n    if (!address || typeof address !== 'string')\n      throw new Error('Address is required for Telegram Venue template');\n\n    this.template = {\n      latitude: latitude,\n      longitude: longitude,\n      title: title,\n      address: address\n    };\n  }\n\n  addFoursqare(foursquareId) {\n    if (!foursquareId)\n      throw new Error('Foursquare ID is required for Telegram Venue template addFoursqare method');\n\n    this.template.foursquare_id = foursquareId;\n\n    return this;\n  }\n\n  get() {\n    return {\n      method: 'sendVenue',\n      body: this.template\n    };\n  }\n}\n\nclass ChatAction extends TelegramMessage {\n  constructor(action) {\n    super();\n    const AVAILABLE_TYPES = ['typing', 'upload_photo', 'record_video', 'upload_video', 'record_audio', 'upload_audio', 'upload_document', 'find_location'];\n\n    if (AVAILABLE_TYPES.indexOf(action) < 0)\n      throw new Error('Valid action is required for Telegram ChatAction template. Check https://core.telegram.org/bots/api#sendchataction for all available actions.');\n\n    this.template = {\n      action: action\n    };\n  }\n\n  get() {\n    return {\n      method: 'sendChatAction',\n      body: this.template\n    };\n  }\n}\n\nclass Pause {\n  constructor(miliseconds) {\n    this.template = {\n      claudiaPause: miliseconds || 500\n    };\n  }\n\n  get() {\n    return this.template;\n  }\n}\n\nclass File extends TelegramMessage {\n  constructor(document, caption) {\n    super();\n    if (!document || typeof document !== 'string')\n      throw new Error('Document needs to be an URL for the Telegram File method');\n\n    this.template = {\n      document: document\n    };\n\n    // caption is optional\n    if (caption && typeof caption === 'string')\n      this.template.caption = caption;\n  }\n\n  get() {\n    return {\n      method: 'sendDocument',\n      body: this.template\n    };\n  }\n}\n\nclass Sticker extends TelegramMessage {\n  constructor(sticker) {\n    super();\n    if (!sticker || typeof sticker !== 'string')\n      throw new Error('Sticker needs to be an URL or sticker ID for the Telegram Sticker method');\n\n    this.template = {\n      sticker: sticker\n    };\n  }\n\n  get() {\n    return {\n      method: 'sendSticker',\n      body: this.template\n    };\n  }\n}\n\nclass Contact extends TelegramMessage {\n  constructor(phone, firstName, lastName) {\n    super();\n    if (!phone || typeof phone !== 'string')\n      throw new Error('Phone number needs to be a string for Telegram Contact method');\n\n    if (!firstName || typeof firstName !== 'string')\n      throw new Error('First name needs to be a string for Telegram Contact method');\n\n    this.template = {\n      phone_number: phone,\n      first_name: firstName\n    };\n\n    // lastName is optional\n    if (lastName && typeof lastName === 'string')\n      this.template.last_name = lastName;\n  }\n\n  get() {\n    return {\n      method: 'sendContact',\n      body: this.template\n    };\n  }\n}\n\nmodule.exports = {\n  Text: Text,\n  Photo: Photo,\n  Audio: Audio,\n  Location: Location,\n  Venue: Venue,\n  ChatAction: ChatAction,\n  Pause: Pause,\n  File: File,\n  Sticker: Sticker,\n  Contact: Contact\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/viber/format-message.js":"'use strict';\n\nconst isUrl = require('../is-url');\n\nclass ViberMessage {\n  constructor() {\n    this.template = {};\n  }\n\n  addReplyKeyboard(isDefaultHeight, backgroundColor) {\n\n    const replyKeyboard = {\n      Type: 'keyboard',\n      DefaultHeight: isDefaultHeight || true,\n      BgColor: backgroundColor || '#FFFFFF',\n      Buttons: []\n    };\n\n    this.template.keyboard = replyKeyboard;\n\n    return this;\n  }\n\n  addKeyboardButton(text, buttonValue, columnSize, rowSize, buttonObj) {\n\n    if (!this.template.keyboard || !Array.isArray(this.template.keyboard.Buttons))\n      throw new Error('KeyboardButton can only be added if you previously added the ReplyKeyboard');\n\n    if (!text || typeof text !== 'string')\n      throw new Error('Text is required for the Viber KeyboardButton template');\n\n    if (!buttonValue || typeof buttonValue !== 'string')\n      throw new Error('buttonValue is required for the Viber KeyboardButton template, and it can be a valid URL or a string');\n\n    buttonObj = buttonObj || {};\n\n    buttonObj.Text = text;\n    buttonObj.ActionBody = buttonValue;\n\n    if (isUrl(buttonValue)) {\n      buttonObj.ActionType = 'open-url';\n    } else {\n      buttonObj.ActionType = 'reply';\n    }\n\n    if (columnSize && typeof columnSize == 'number' && columnSize > 0 && columnSize <= 6)\n      buttonObj.Columns = columnSize;\n\n    if (rowSize && typeof rowSize === 'number' && rowSize > 0 && rowSize <= 2)\n      buttonObj.Rows = rowSize;\n\n    this.template.keyboard.Buttons.push(buttonObj);\n\n    return this;\n  }\n\n  get() {\n    return this.template;\n  }\n}\n\nclass Text extends ViberMessage {\n  constructor(text) {\n    super();\n    if (!text || typeof text !== 'string')\n      throw new Error('Text is required for the Viber Text template');\n\n    this.template = {\n      type: 'text',\n      text: text\n    };\n  }\n}\n\nclass Photo extends ViberMessage {\n  constructor(photo, caption) {\n    super();\n    if (!photo || typeof photo !== 'string')\n      throw new Error('Photo needs to be an URL for the Viber Photo method');\n    caption = caption || '';\n    if (caption && typeof caption !== 'string')\n      throw new Error('Text needs to be a string for Viber Photo method');\n\n    this.template = {\n      type: 'picture',\n      media: photo,\n      text: caption\n    };\n  }\n}\n\nclass Video extends ViberMessage {\n  constructor(media, size, duration) {\n    super();\n    if (!media || typeof media !== 'string')\n      throw new Error('Media needs to be an URL for Viber Video method');\n\n    if (!size || typeof size !== 'number')\n      throw new Error('Size needs to be a Number representing size in bytes for Viber Video method');\n\n    this.template = {\n      type: 'video',\n      media: media,\n      size: size\n    };\n\n    if (duration && typeof duration === 'number')\n      this.template.duration = duration;\n  }\n}\n\nclass File extends ViberMessage {\n  constructor(media, size, fileName) {\n    super();\n    if (!media || typeof media !== 'string')\n      throw new Error('Media needs to be an URL for the Viber File method');\n\n    if (!size || typeof size !== 'number')\n      throw new Error('Size needs to be a Number representing size in bytes for the Viber File method');\n\n    if (!fileName || typeof fileName !== 'string')\n      throw new Error('File name needs to be a String representing the name of the file for the Viber File method');\n\n    this.template = {\n      type: 'file',\n      media: media,\n      size: size,\n      file_name: fileName\n    };\n  }\n}\n\nclass Contact extends ViberMessage {\n  constructor(name, phoneNumber) {\n    super();\n    if (!name || !phoneNumber || typeof name !== 'string' || typeof phoneNumber !== 'string')\n      throw new Error('Contact name and phone number are required for the Viber Contact template');\n\n    this.template = {\n      type: 'contact',\n      contact: {\n        name: name,\n        phone_number: phoneNumber\n      }\n    };\n  }\n}\n\n\nclass Location extends ViberMessage {\n  constructor(latitude, longitude) {\n    super();\n    if (!latitude || !longitude || typeof latitude !== 'number' || typeof longitude !== 'number')\n      throw new Error('Latitude and longitude are required for the Viber Location template');\n\n    this.template = {\n      type: 'location',\n      location: {\n        lat: latitude,\n        lon: longitude\n      }\n    };\n  }\n}\n\nclass Url extends ViberMessage {\n  constructor(url) {\n    super();\n    if (!url || !isUrl(url) || typeof url !== 'string')\n      throw new Error('Media needs to be an URL for the Viber URL method');\n\n    if (url.length > 2000)\n      throw new Error('Media URL can not be longer than 2000 characters for the Viber URL method');\n\n    this.template = {\n      type: 'url',\n      media: url\n    };\n  }\n}\n\nclass Sticker extends ViberMessage {\n  constructor(stickerId) {\n    super();\n    if (!stickerId || typeof stickerId !== 'number')\n      throw new Error('Sticker ID and ');\n\n    this.template = {\n      type: 'sticker',\n      sticker_id: stickerId\n    };\n  }\n}\n\nmodule.exports = {\n  Text: Text,\n  Photo: Photo,\n  Video: Video,\n  File: File,\n  Contact: Contact,\n  Location: Location,\n  Url: Url,\n  Sticker: Sticker\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/skype/format-message.js":"'use strict';\n\nclass SkypeMessage {\n  constructor() {\n    this.template = {};\n    this.template.attachments = [];\n  }\n\n  get() {\n    return this.template;\n  }\n}\n\nclass Photo extends SkypeMessage {\n  constructor(base64Photo) {\n    super();\n    if (!base64Photo || typeof base64Photo !== 'string')\n      throw new Error('Photo is required for the Skype Photo template');\n\n    this.template = {\n      type: 'message/image',\n      attachments: [{\n        contentUrl: base64Photo\n      }]\n    };\n  }\n}\n\nclass Carousel extends SkypeMessage {\n  constructor(summary, text) {\n    super();\n\n    this.template = {\n      type: 'message/card.carousel',\n      attachmentLayout: 'carousel',\n      summary: summary || '',\n      text: text || '',\n      attachments: []\n    };\n\n    return this;\n  }\n\n  getCurrentAttachment() {\n    let current = this.template.attachments.length - 1;\n\n    if (current < 0) {\n      throw new Error('You need to add attachment to Carousel');\n    }\n\n    return current;\n  }\n\n  addHero(images) {\n    if(images && !Array.isArray(images)) {\n      throw new Error('Images should be sent as array for the Skype Hero template');\n    }\n\n    this.template.attachments.push({\n      contentType: 'application/vnd.microsoft.card.hero',\n      content: {\n        title: '',\n        subtitle: '',\n        text: '',\n        images: images ? images.map(image => ({url: image, alt: ''})) : [],\n        buttons: []\n      }\n    });\n\n    return this;\n  }\n\n  addThumbnail(images) {\n    if(images && !Array.isArray(images)) {\n      throw new Error('Images should be sent as array for the Skype Thumbnail template');\n    }\n\n    this.template.attachments.push({\n      contentType: 'application/vnd.microsoft.card.thumbnail',\n      content: {\n        title: '',\n        subtitle: '',\n        text: '',\n        images: images ? images.map(image => ({url: image, alt: ''})) : [],\n        buttons: []\n      }\n    });\n\n    return this;\n  }\n\n  addReceipt(total, tax, vat) {\n    this.template.attachments.push({\n      contentType: 'application/vnd.microsoft.card.receipt',\n      content: {\n        title: '',\n        subtitle: '',\n        text: '',\n        total: total || '',\n        tax: tax || '',\n        vat: vat || '',\n        items: [],\n        facts: [],\n        buttons: []\n      }\n    });\n\n    return this;\n  }\n\n  addFact(key, value) {\n    let currentAttachment = this.getCurrentAttachment();\n\n    this.template.attachments[currentAttachment].content.facts.push({\n      key: key || '',\n      value: value || ''\n    });\n\n    return this;\n  }\n\n  addItem(title, subtitle, text, price, quantity, image) {\n    let currentAttachment = this.getCurrentAttachment();\n\n    this.template.attachments[currentAttachment].content.items.push({\n      title: title || '',\n      subtitle: subtitle || '',\n      text: text || '',\n      price: price || '',\n      quantity: quantity || '',\n      image: {\n        url: image || ''\n      }\n    });\n\n    return this;\n  }\n\n  addTitle(title) {\n    let currentAttachment = this.getCurrentAttachment();\n\n    if (!title || typeof title !== 'string')\n      throw new Error('Title needs to be a string for Skype addTitle method');\n\n    this.template.attachments[currentAttachment].content.title = title;\n\n    return this;\n  }\n\n  addSubtitle(subtitle) {\n    let currentAttachment = this.getCurrentAttachment();\n\n    if (!subtitle || typeof subtitle !== 'string')\n      throw new Error('Subtitle needs to be a string for Skype addSubtitle method');\n\n    this.template.attachments[currentAttachment].content.subtitle = subtitle;\n\n    return this;\n  }\n\n  addText(text) {\n    let currentAttachment = this.getCurrentAttachment();\n\n    if (!text || typeof text !== 'string')\n      throw new Error('Text needs to be a string for Skype addText method');\n\n    this.template.attachments[currentAttachment].content.text = text;\n\n    return this;\n  }\n\n  addButton(title, value, type) {\n    let currentAttachment = this.getCurrentAttachment();\n\n    if (!title || typeof title !== 'string')\n      throw new Error('Title needs to be a string for Skype addButton method');\n\n    if (!value || typeof value !== 'string')\n      throw new Error('Value needs to be a string for Skype addButton method');\n\n    if (!type || typeof type !== 'string')\n      throw new Error('Type needs to be a string for Skype addButton method');\n\n    let validTypes = ['openUrl', 'imBack', 'postBack', 'playAudio', 'playVideo', 'showImage', 'downloadFile', 'signin'];\n    if (validTypes.indexOf(type) == -1)\n      throw new Error('Type needs to be a valid type string for Skype addButton method');\n\n    this.template.attachments[currentAttachment].content.buttons.push({\n      type: type,\n      title: title,\n      value: value\n    });\n\n    return this;\n  }\n}\n\nclass Typing extends SkypeMessage {\n  constructor() {\n    super();\n    this.template = {\n      type: 'typing'\n    };\n\n    return this.template;\n  }\n}\n\n//TODO: investigate how to send Hero, Thumbnail and Receipt without carousel\n\nmodule.exports = {\n  Photo: Photo,\n  Carousel: Carousel,\n  Typing: Typing\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/lib/slack/delayed-reply.js":"'use strict';\n\nconst rp = require('minimal-request-promise');\nconst formatReply = require('./reply');\n\nmodule.exports = function slackDelayedReply(message, response) {\n  if (!message || !message.originalRequest || !message.originalRequest.response_url || !response)\n    throw new Error('Original bot request and response are required');\n\n  return rp.post(message.originalRequest.response_url, {\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(formatReply(response))\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/bot-builder-spec.js":"/*global describe, it, jasmine, expect, beforeEach*/\nvar botBuilder = require('../lib/bot-builder');\ndescribe('BotBuilder', () => {\n  var messageHandler, underTest, lambdaContextSpy;\n\n  beforeEach(() => {\n    messageHandler = jasmine.createSpy('messageHandler');\n    lambdaContextSpy = jasmine.createSpyObj('lambdaContext', ['done']);\n    underTest = botBuilder(messageHandler);\n  });\n\n  it('configures a Claudia Rest API', () => {\n    expect(underTest.apiConfig().version).toEqual(3);\n  });\n\n  it('sets up a GET route for /', (done) => {\n    underTest.proxyRouter({\n      requestContext: {\n        resourcePath: '/',\n        httpMethod: 'GET'\n      }\n    }, lambdaContextSpy).then(() => {\n      expect(lambdaContextSpy.done).toHaveBeenCalledWith(null, jasmine.objectContaining({body: '\"Ok\"'}));\n    }).then(done, done.fail);\n  });\n  [\n    {\n      name: 'facebook',\n      path: 'facebook',\n      methods: ['GET', 'POST']\n    },\n    {\n      name: 'slackSlashCommand',\n      path: 'slack/slash-command',\n      methods: ['GET', 'POST']\n    },\n    {\n      name: 'telegram',\n      path: 'telegram',\n      methods: ['POST']\n    },\n    {\n      name: 'skype',\n      path: 'skype',\n      methods: ['POST']\n    },\n    {\n      name: 'twilio',\n      path: 'twilio',\n      methods: ['POST']\n    },\n    {\n      name: 'kik',\n      path: 'kik',\n      methods: ['POST']\n    },\n    {\n      name: 'groupme',\n      path: 'groupme',\n      methods: ['POST']\n    },\n    {\n      name: 'viber',\n      path: 'viber',\n      methods: ['POST']\n    }\n  ].forEach(platform => {\n    describe('setting up ' + platform.name, () => {\n      it('should setup the platform if the options are not provided', () => {\n        underTest = botBuilder(messageHandler);\n        expect(Object.keys(underTest.apiConfig().routes[platform.path])).toBeTruthy();\n      });\n      it('should setup the platform if the options are provided without platforms' + platform.name, () => {\n        underTest = botBuilder(messageHandler, { plugins: [] });\n        expect(Object.keys(underTest.apiConfig().routes[platform.path])).toBeTruthy();\n      });\n      it('should setup the platform if the options are provided and platform is enabled' + platform.name, () => {\n        var api = botBuilder(messageHandler, { platforms: [platform.name] });\n        expect(Object.keys(api.apiConfig().routes[platform.path])).toEqual(platform.methods);\n      });\n      it('should not setup the platform if the options are provided and platform is disabled' + platform.name, () => {\n        var options = { platforms: [] };\n        underTest = botBuilder(messageHandler, options);\n        expect(underTest.apiConfig().routes[platform.path]).toBeFalsy();\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/break-text-spec.js":"/*global describe, it, expect, require */\nvar breakText = require('../lib/breaktext');\ndescribe('breakText', () => {\n  it('returns a single line if less than length', () => {\n    expect(breakText('abc def', 10)).toEqual(['abc def']);\n    expect(breakText('abc def', 7)).toEqual(['abc def']);\n  });\n  it('breaks around max length', () => {\n    expect(breakText('abc def', 5)).toEqual(['abc', 'def']);\n  });\n  it('breaks words that are too long', () => {\n    expect(breakText('abcdef 123456789', 5)).toEqual(['abcde', 'f', '1234', '56789']);\n  });\n  it('does not explode on blank strings', () => {\n    expect(breakText('', 5)).toEqual(['']);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/is-url-spec.js":"/*global describe, it, expect, require */\nconst isUrl = require('../lib/is-url');\ndescribe('isUrl', () => {\n  it('should be a function', () => {\n    expect(typeof isUrl).toBe('function');\n  });\n  it('should return false for an invalid url', () => {\n    expect(isUrl('')).toBeFalsy();\n    expect(isUrl('test')).toBeFalsy();\n    expect(isUrl('http://')).toBeFalsy();\n    expect(isUrl('http//google')).toBeFalsy();\n  });\n  it('should return true for a valid url', () => {\n    expect(isUrl('http://claudiajs.com')).toBeTruthy();\n    expect(isUrl('https://claudiajs.com')).toBeTruthy();\n    expect(isUrl('https://www.claudiajs.com')).toBeTruthy();\n    expect(isUrl('https://github.com/claudiajs')).toBeTruthy();\n    expect(isUrl('https://github.com/claudiajs/claudia-bot-builder')).toBeTruthy();\n    expect(isUrl('https://www.google.com/#q=claudia,bot')).toBeTruthy();\n  });\n  it('should return false if url is in the sentence', () => {\n    expect(isUrl('This is a valid url: http://google.com')).toBeFalsy();\n    expect(isUrl('http://google.com is an url')).toBeFalsy();\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/alexa/alexa-parse-spec.js":"/*global describe, it, expect, require */\n'use strict';\n\nvar parse = require('../../lib/alexa/parse');\n\ndescribe('Alexa parse', () => {\n  it('should return nothing if the format is invalid', () => {\n    expect(parse('string')).toBeUndefined();\n    expect(parse()).toBeUndefined();\n    expect(parse(false)).toBeUndefined();\n    expect(parse(123)).toBeUndefined();\n    expect(parse({})).toBeUndefined();\n    expect(parse([1, 2, 3])).toBeUndefined();\n  });\n  it('should return undefined if the session user is missing', () => {\n    expect(parse({request: { intent: { name: 'intent 1'}}, session: {} })).toBeUndefined();\n  });\n  it('should return original request with an empty text if the intent is missing', () => {\n    let msg = {request: {}, session: { user: { userId: 'claudia alexa user'} } };\n    expect(parse(msg)).toEqual({ sender: 'claudia alexa user', text: '', originalRequest: msg, type: 'alexa-skill'});\n  });\n  it('should return original request with an empty text if the intent name is missing', () => {\n    let msg = {request: { intent: {}}, session: { user: { userId: 'claudia alexa user'} } };\n    expect(parse(msg)).toEqual({ sender: 'claudia alexa user', text: '', originalRequest: msg, type: 'alexa-skill'});\n  });\n  it('should return a parsed object with proper sender and text when the intent name and session user are present', () => {\n    let msg = {\n      request: { intent: { name: 'intent 1'}},\n      session: { user: { userId: 'claudia alexa user'}} };\n    expect(parse(msg)).toEqual({ sender: 'claudia alexa user', text: '', originalRequest: msg, type: 'alexa-skill'});\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/alexa/alexa-reply-spec.js":"/*global describe, it, expect, require */\n'use strict';\nvar reply = require('../../lib/alexa/reply');\n\ndescribe('Alexa Reply', () => {\n\n  it('just returns the bot response when its not a string', () => {\n    expect(reply()).toEqual(undefined);\n    expect(reply(undefined, 'Claudia Alexa Bot')).toEqual(undefined);\n    expect(reply({ hello: 'alexa'}, 'Claudia Alexa Bot')).toEqual({ hello: 'alexa'});\n  });\n\n  it('just returns the proper Alexa response when its not a string', () => {\n    expect(reply('hello', 'Claudia Alexa Bot'))\n      .toEqual({\n        response: {\n          outputSpeech: {\n            type: 'PlainText',\n            text: 'hello'\n          },\n          card: {\n            type: 'Simple',\n            title: 'Claudia Alexa Bot',\n            content: 'hello'\n          },\n          shouldEndSession: true\n        }\n      });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/alexa/alexa-setup-spec.js":"/*global require, describe, it, expect, beforeEach, jasmine*/\n'use strict';\nvar underTest = require('../../lib/alexa/setup'),\n  utils = require('../../lib/utils/env-utils');\ndescribe('Alexa setup', () => {\n  var api, bot, logError, parser, responder, botPromise, botResolve, botReject;\n  beforeEach(() => {\n    api = jasmine.createSpyObj('api', ['get', 'post', 'addPostDeployStep']);\n    botPromise = new Promise((resolve, reject) => {\n      botResolve = resolve;\n      botReject = reject;\n    });\n    bot = jasmine.createSpy().and.returnValue(botPromise);\n    parser = jasmine.createSpy();\n    logError = jasmine.createSpy();\n    responder = jasmine.createSpy();\n    underTest(api, bot, logError, parser, responder);\n  });\n  describe('message processor', () => {\n    const singleMessageTemplate = {\n      request: {\n        intent: {\n          name: 'intent 1',\n          slots: {\n            value: 'HELLO_SLOT'\n          }\n        }\n      },\n      session: { user: { userId: 'user1'} }\n    };\n    it('wires the POST request for alexa to the message processor', () => {\n      expect(api.post.calls.count()).toEqual(1);\n      expect(api.post).toHaveBeenCalledWith('/alexa', jasmine.any(Function));\n    });\n    describe('processing a single message', () => {\n      var handler;\n      beforeEach(() => {\n        handler = api.post.calls.argsFor(0)[1];\n      });\n      it('breaks down the message and puts it into the parser', () => {\n        handler({body: singleMessageTemplate, env: {alexaAppName: 'Claudia Alexa Bot'}});\n        expect(parser).toHaveBeenCalledWith({\n          request: {\n            intent: {\n              name: 'intent 1',\n              slots: {\n                value: 'HELLO_SLOT'\n              }\n            }\n          },\n          session: { user: { userId: 'user1'} }\n        });\n      });\n      it('passes the parsed value to the bot if a message can be parsed', (done) => {\n        parser.and.returnValue('MSG1');\n        handler({body: singleMessageTemplate, env: {}});\n        Promise.resolve().then(() => {\n          expect(bot).toHaveBeenCalledWith('MSG1', { body: singleMessageTemplate, env: {} });\n        }).then(done, done.fail);\n      });\n      it('responds when the bot resolves', (done) => {\n        parser.and.returnValue({sender: 'user1', text: 'MSG1', type: 'alexa-skill'});\n        botResolve('Hello Alexa');\n        handler({body: singleMessageTemplate, env: {alexaAppName: utils.encode('Claudia Alexa Bot')}}).then(() => {\n          expect(responder).toHaveBeenCalledWith('Hello Alexa', 'Claudia Alexa Bot');\n        }).then(done, done.fail);\n      });\n      it('can work with bot responses as strings', (done) => {\n        botResolve('Hello Alexa');\n        parser.and.returnValue({sender: 'user1', text: 'Hello'});\n        handler({body: singleMessageTemplate, env: {alexaAppName: utils.encode('Claudia Alexa Bot')}}).then(() => {\n          expect(responder).toHaveBeenCalledWith('Hello Alexa', 'Claudia Alexa Bot');\n        }).then(done, done.fail);\n\n      });\n      it('logs error when the bot rejects without responding', (done) => {\n        parser.and.returnValue('MSG1');\n\n        handler({body: singleMessageTemplate, env: {alexaAppName: 'Claudia Alexa Bot'}}).then(() => {\n          expect(responder).not.toHaveBeenCalled();\n          expect(logError).toHaveBeenCalledWith('No No');\n        }).then(done, done.fail);\n\n        botReject('No No');\n      });\n      it('logs the error when the responder throws an error', (done) => {\n        parser.and.returnValue('MSG1');\n        responder.and.throwError('XXX');\n        botResolve('Yes');\n        handler({body: singleMessageTemplate, env: {alexaAppName: 'Claudia Alexa Bot'}}).then(() => {\n          expect(logError).toHaveBeenCalledWith(jasmine.any(Error));\n        }).then(done, done.fail);\n      });\n      describe('working with promises in responders', () => {\n        var responderResolve, responderReject, responderPromise, hasResolved;\n        beforeEach(() => {\n          responderPromise = new Promise((resolve, reject) => {\n            responderResolve = resolve;\n            responderReject = reject;\n          });\n          responder.and.returnValue(responderPromise);\n\n          parser.and.returnValue('MSG1');\n        });\n        it('waits for the responders to resolve before completing the request', (done) => {\n          handler({body: singleMessageTemplate, env: {alexaAppName: 'Claudia Alexa Bot'}}).then(() => {\n            hasResolved = true;\n          });\n\n          botPromise.then(() => {\n            expect(hasResolved).toBeFalsy();\n          }).then(done, done.fail);\n\n          botResolve('YES');\n        });\n        it('resolves when the responder resolves', (done) => {\n          handler({body: singleMessageTemplate, env: {alexaAppName: 'Claudia Alexa Bot'}}).then((message) => {\n            expect(message).toEqual('As Promised!');\n          }).then(done, done.fail);\n\n          botPromise.then(() => {\n            responderResolve('As Promised!');\n          });\n          botResolve('YES');\n        });\n        it('logs error when the responder rejects', (done) => {\n          handler({body: singleMessageTemplate, env: {alexaAppName: 'Claudia Alexa Bot'}}).then(() => {\n            expect(logError).toHaveBeenCalledWith('Bomb!');\n          }).then(done, done.fail);\n\n          botPromise.then(() => {\n            responderReject('Bomb!');\n          });\n          botResolve('YES');\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/facebook/facebook-format-message-spec.js":"/*global describe, it, expect, beforeEach, require */\n'use strict';\n\nconst formatFbMessage = require('../../lib/facebook/format-message');\n\ndescribe('Facebook format message', () => {\n  it('should export an object', () => {\n    expect(typeof formatFbMessage).toBe('object');\n  });\n\n  describe('Text', () => {\n    it('should be a class', () => {\n      const message = new formatFbMessage.Text('text');\n      expect(typeof formatFbMessage.Text).toBe('function');\n      expect(message instanceof formatFbMessage.Text).toBeTruthy();\n    });\n\n    it('should throw an error if text is not provided', () => {\n      expect(() => new formatFbMessage.Text()).toThrowError('Text is required for text template');\n    });\n\n    it('should add a text', () => {\n      const message = new formatFbMessage.Text('Some text').get();\n      expect(message.text).toBe('Some text');\n    });\n\n    it('should return a simple text object', () => {\n      const message = new formatFbMessage.Text('Some text');\n      expect(message.get()).toEqual({\n        text: 'Some text'\n      });\n    });\n\n    it('should throw an error if addQuickReply arguments are not provided', () => {\n      const message = new formatFbMessage.Text('Some text');\n      expect(() => message.addQuickReply()).toThrowError('Both text and payload are required for a quick reply');\n    });\n\n    it('should throw an error if addQuickReply payload is too long', () => {\n      const message = new formatFbMessage.Text('Some text');\n      let payload = new Array(102).join('0123456789');\n      expect(() => message.addQuickReply('title', payload)).toThrowError('Payload can not be more than 1000 characters long');\n    });\n\n    it('should throw an error if addQuickReply imageUrl is not an url', () => {\n      const message = new formatFbMessage.Text('Some text');\n      const imageUrl = 'http//invalid-url';\n      expect(() => message.addQuickReply('title', 'PAYLOAD', imageUrl)).toThrowError('Image has a bad url');\n    });\n\n    it('should add a quick reply', () => {\n      const message = new formatFbMessage.Text('Some text')\n        .addQuickReply('title', 'PAYLOAD')\n        .get();\n      expect(message.quick_replies.length).toBe(1);\n      expect(message.quick_replies[0].title).toBe('title');\n      expect(message.quick_replies[0].payload).toBe('PAYLOAD');\n    });\n\n    it('should add a quick reply with an image', () => {\n      const message = new formatFbMessage.Text('Some text')\n        .addQuickReply('title', 'PAYLOAD','http://google.com/path/to/image.png')\n        .get();\n      expect(message.quick_replies.length).toBe(1);\n      expect(message.quick_replies[0].content_type).toBe('text');\n      expect(message.quick_replies[0].title).toBe('title');\n      expect(message.quick_replies[0].payload).toBe('PAYLOAD');\n      expect(message.quick_replies[0].image_url).toBe('http://google.com/path/to/image.png');\n    });\n\n    it('should add a quick reply with a location', () => {\n      const message = new formatFbMessage.Text('Some text')\n        .addQuickReplyLocation()\n        .get();\n      expect(message.quick_replies.length).toBe(1);\n      expect(message.quick_replies[0].content_type).toBe('location');\n    });\n\n    it('should add 11 quick replies', () => {\n      const message = new formatFbMessage.Text('Some text')\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReplyLocation()\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReply('title', 'PAYLOAD')\n        .get();\n      expect(message.quick_replies.length).toBe(11);\n    });\n\n    it('should throw an error if there\\'s more than 11 quick replies', () => {\n      const message = new formatFbMessage.Text('Some text')\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReplyLocation()\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReply('title', 'PAYLOAD')\n        .addQuickReply('title', 'PAYLOAD');\n      expect(() => message.addQuickReply('title', 'PAYLOAD')).toThrowError('There can not be more than 11 quick replies');\n    });\n\n    it('should set the notification type', () => {\n      const regular = new formatFbMessage.Text('Some text')\n        .setNotificationType('REGULAR')\n        .get();\n      expect(regular.notification_type).toBe('REGULAR');\n      const silent = new formatFbMessage.Text('Some text')\n        .setNotificationType('SILENT_PUSH')\n        .get();\n      expect(silent.notification_type).toBe('SILENT_PUSH');\n      const none = new formatFbMessage.Text('Some text')\n        .setNotificationType('NO_PUSH')\n        .get();\n      expect(none.notification_type).toBe('NO_PUSH');\n    });\n\n    it('should throw an on setNotificationType with invalid value', () => {\n      expect(() => new formatFbMessage.Text('Some text').setNotificationType('FACE_SLAP')).toThrowError('Notification type must be one of REGULAR, SILENT_PUSH, or NO_PUSH');\n    });\n\n    it('should trim the title if it is too long', () => {\n      let title = new Array(4).join('0123456789');\n      const message = new formatFbMessage.Text('Some text')\n        .addQuickReply(title, 'PAYLOAD')\n        .get();\n      expect(message.quick_replies[0].title).toBe('01234567890123456789');\n    });\n\n    it('should return a json with text and quick replies', () => {\n      const message = new formatFbMessage.Text('Some text')\n        .addQuickReply('title', 'PAYLOAD');\n      expect(message.get()).toEqual({\n        text: 'Some text',\n        quick_replies: [{\n          title: 'title',\n          payload: 'PAYLOAD',\n          content_type: 'text'\n        }]\n      });\n    });\n  });\n\n  describe('Generic template', () => {\n    let generic;\n\n    beforeEach(() => {\n      generic = new formatFbMessage.Generic();\n    });\n\n    it('should be a class', () => {\n      expect(typeof formatFbMessage.Generic).toBe('function');\n      expect(generic instanceof formatFbMessage.Generic).toBeTruthy();\n    });\n\n    it('should throw an error if at least one bubble/element is not added', () => {\n      expect(() => generic.get()).toThrowError('Add at least one bubble first!');\n    });\n\n    it('should throw an error if bubble title does not exist', () => {\n      expect(() => generic.addBubble()).toThrowError('Bubble title cannot be empty');\n    });\n\n    it('should throw an error if bubble title is too long', () => {\n      expect(() => generic.addBubble('Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua')).toThrowError('Bubble title cannot be longer than 80 characters');\n    });\n\n    it('should throw an error if bubble subtitle is too long', () => {\n      expect(() => generic.addBubble('Test', 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua')).toThrowError('Bubble subtitle cannot be longer than 80 characters');\n    });\n\n    it('should add a bubble with a provided title', () => {\n      generic.addBubble('Test');\n\n      expect(generic.bubbles.length).toBe(1);\n      expect(generic.bubbles[0].title).toBe('Test');\n    });\n\n    it('should add a bubble with a provided title and subtitle', () => {\n      generic.addBubble('Test Title', 'Test Subtitle');\n\n      expect(generic.bubbles.length).toBe(1);\n      expect(generic.bubbles[0].title).toBe('Test Title');\n      expect(generic.bubbles[0].subtitle).toBe('Test Subtitle');\n    });\n\n    it('should throw an error if you try to add an url but not provide it', () => {\n      generic.addBubble('Test');\n\n      expect(() => generic.addUrl()).toThrowError('URL is required for addUrl method');\n    });\n\n    it('should throw an error if you try to add an url in invalid format', () => {\n      generic.addBubble('Test');\n\n      expect(() => generic.addUrl('http//invalid-url')).toThrowError('URL needs to be valid for addUrl method');\n    });\n\n    it('should add an url if it is valid', () => {\n      generic\n        .addBubble('Test')\n        .addUrl('http://google.com');\n\n      expect(generic.bubbles.length).toBe(1);\n      expect(generic.bubbles[0].item_url).toBe('http://google.com');\n    });\n\n    it('should throw an error if you try to add an image but not provide an url', () => {\n      generic\n        .addBubble('Test');\n\n      expect(() => generic.addImage()).toThrowError('Image URL is required for addImage method');\n    });\n\n    it('should throw an error if you try to add an image, but url is in invalid format', () => {\n      generic\n        .addBubble('Test');\n\n      expect(() => generic.addImage('http//invalid-url')).toThrowError('Image URL needs to be valid for addImage method');\n    });\n\n    it('should add an image if it is valid', () => {\n      generic\n        .addBubble('Test')\n        .addImage('http://google.com/path/to/image.png');\n\n      expect(generic.bubbles.length).toBe(1);\n      expect(generic.bubbles[0].image_url).toBe('http://google.com/path/to/image.png');\n    });\n\n    it('should use square aspect ratio for images if \"useSquareImages\" method is chained', () => {\n      generic\n        .useSquareImages()\n        .addBubble('Test')\n        .addImage('http://google.com/path/to/image.png');\n\n      expect(generic.bubbles.length).toBe(1);\n      expect(generic.bubbles[0].image_url).toBe('http://google.com/path/to/image.png');\n      expect(generic.get().attachment.payload.image_aspect_ratio).toBe('square');\n    });\n\n    it('should throw an error if you add a button without the title', () => {\n      generic\n        .addBubble('Test');\n\n      expect(() => generic.addButton()).toThrowError('Button title cannot be empty');\n    });\n\n    it('should throw an error if you add a button without the value', () => {\n      generic\n        .addBubble('Test');\n\n      expect(() => generic.addButton('Title')).toThrowError('Button value is required');\n    });\n\n    it('should add a button with title and payload if you pass valid format', () => {\n      generic\n        .addBubble('Test')\n        .addButton('Title 1', 1);\n\n      expect(generic.bubbles[0].buttons.length).toBe(1);\n      expect(generic.bubbles[0].buttons[0].title).toBe('Title 1');\n      expect(generic.bubbles[0].buttons[0].type).toBe('postback');\n      expect(generic.bubbles[0].buttons[0].payload).toBe(1);\n      expect(generic.bubbles[0].buttons[0].url).not.toBeDefined();\n    });\n\n    it('should add a button with a share url', () => {\n      generic\n        .addBubble('Test')\n        .addShareButton();\n\n      expect(generic.bubbles[0].buttons.length).toBe(1);\n      expect(generic.bubbles[0].buttons[0].type).toBe('element_share');\n    });\n\n    it('should add a button with title and url if you pass valid format', () => {\n      generic\n        .addBubble('Test')\n        .addButton('Title 1', 'http://google.com');\n\n      expect(generic.bubbles[0].buttons.length).toBe(1);\n      expect(generic.bubbles[0].buttons[0].title).toBe('Title 1');\n      expect(generic.bubbles[0].buttons[0].type).toBe('web_url');\n      expect(generic.bubbles[0].buttons[0].url).toBe('http://google.com');\n      expect(generic.bubbles[0].buttons[0].payload).not.toBeDefined();\n    });\n\n    it('should add 3 buttons with valid titles and formats', () => {\n      generic\n        .addBubble('Test')\n        .addButton('b1', 'v1')\n        .addButton('b2', 'v2')\n        .addButton('b3', 'v3');\n\n      expect(generic.bubbles[0].buttons.length).toBe(3);\n      expect(generic.bubbles[0].buttons[0].title).toBe('b1');\n      expect(generic.bubbles[0].buttons[0].payload).toBe('v1');\n      expect(generic.bubbles[0].buttons[1].title).toBe('b2');\n      expect(generic.bubbles[0].buttons[1].payload).toBe('v2');\n      expect(generic.bubbles[0].buttons[2].title).toBe('b3');\n      expect(generic.bubbles[0].buttons[2].payload).toBe('v3');\n    });\n\n    it('should throw an error if call button is added with wrong phone format', () => {\n      generic.addBubble('Test');\n      expect(() => generic.addCallButton('Title')).toThrowError('Call button value needs to be a valid phone number in following format: +1234567...');\n      expect(() => generic.addCallButton('Title', 123)).toThrowError('Call button value needs to be a valid phone number in following format: +1234567...');\n      expect(() => generic.addCallButton('Title', 'abc')).toThrowError('Call button value needs to be a valid phone number in following format: +1234567...');\n      expect(() => generic.addCallButton('Title', '+123')).toThrowError('Call button value needs to be a valid phone number in following format: +1234567...');\n    });\n\n    it('should add a call button', () => {\n      generic.addBubble('Test')\n        .addCallButton('Button 1', '+123456789');\n\n      expect(generic.bubbles[0].buttons.length).toBe(1);\n      expect(generic.bubbles[0].buttons[0].title).toBe('Button 1');\n      expect(generic.bubbles[0].buttons[0].payload).toBe('+123456789');\n      expect(generic.bubbles[0].buttons[0].type).toBe('phone_number');\n    });\n\n    it('should add a share button', () => {\n      generic.addBubble('Test')\n        .addShareButton();\n\n      expect(generic.bubbles[0].buttons.length).toBe(1);\n      expect(generic.bubbles[0].buttons[0].title).toBeUndefined();\n      expect(generic.bubbles[0].buttons[0].type).toBe('element_share');\n    });\n\n    it('should add a share button with share content', () => {\n      const shareContent = {\n        attachment: {\n          type: 'template',\n          payload: {\n            template_type: 'generic',\n            elements: [\n              {\n                title: `I took Peter's \"Which Hat Are You?\" Quiz`,\n                subtitle: 'My result: Fez',\n                image_url: 'https//bot.peters-hats.com/img/hats/fez.jpg',\n                default_action: {\n                  type: 'web_url',\n                  url: 'http://m.me/petershats?ref=invited_by_24601'\n                },\n                buttons: [{\n                  type: 'web_url',\n                  url: 'http://m.me/petershats?ref=invited_by_24601',\n                  title: 'Take Quiz'\n                }]\n              }\n            ]\n          }\n        }\n      };\n      generic.addBubble('Test')\n        .addShareButton(shareContent);\n\n      expect(generic.bubbles[0].buttons.length).toBe(1);\n      expect(generic.bubbles[0].buttons[0].title).toBeUndefined();\n      expect(generic.bubbles[0].buttons[0].type).toBe('element_share');\n      expect(generic.bubbles[0].buttons[0].share_contents).toEqual(shareContent);\n    });\n\n    it('should throw an error if all arguments are not provided for buy button', () => {\n      generic.addBubble('Test');\n\n      expect(() => generic.addBuyButton()).toThrowError('Button value is required');\n      expect(() => generic.addBuyButton('Title')).toThrowError('Button value is required');\n      expect(() => generic.addBuyButton('Title', 'PAYLOAD')).toThrowError('Payment summary is required for buy button');\n      expect(() => generic.addBuyButton('Title', 'PAYLOAD', 123)).toThrowError('Payment summary is required for buy button');\n      expect(() => generic.addBuyButton('Title', 'PAYLOAD', 'abc')).toThrowError('Payment summary is required for buy button');\n    });\n\n    it('should add a buy button', () => {\n      generic.addBubble('Test')\n        .addBuyButton('Buy', 'BUY_PAYLOAD', {\n          additionalOptions: true\n        });\n\n      expect(generic.bubbles[0].buttons.length).toBe(1);\n      expect(generic.bubbles[0].buttons[0].title).toBe('Buy');\n      expect(generic.bubbles[0].buttons[0].type).toBe('payment');\n      expect(generic.bubbles[0].buttons[0].payload).toBe('BUY_PAYLOAD');\n      expect(generic.bubbles[0].buttons[0].payment_summary).toEqual({\n        additionalOptions: true\n      });\n    });\n\n    it('should throw an error if url provided for login button is not valid', () => {\n      generic.addBubble('Test');\n\n      expect(() => generic.addLoginButton()).toThrowError('Valid URL is required for Login button');\n      expect(() => generic.addLoginButton('123')).toThrowError('Valid URL is required for Login button');\n    });\n\n    it('should add a login button', () => {\n      generic.addBubble('Test')\n        .addLoginButton('https://example.com');\n\n      expect(generic.bubbles[0].buttons.length).toBe(1);\n      expect(generic.bubbles[0].buttons[0].title).toBeUndefined();\n      expect(generic.bubbles[0].buttons[0].type).toBe('account_link');\n      expect(generic.bubbles[0].buttons[0].url).toBe('https://example.com');\n    });\n\n    it('should add a logout button', () => {\n      generic.addBubble('Test')\n        .addLogoutButton();\n\n      expect(generic.bubbles[0].buttons.length).toBe(1);\n      expect(generic.bubbles[0].buttons[0].title).toBeUndefined();\n      expect(generic.bubbles[0].buttons[0].type).toBe('account_unlink');\n    });\n\n    it('should throw an error if you add more than 3 buttons', () => {\n      generic\n        .addBubble('Test');\n\n      expect(() => {\n        generic\n          .addButton('Title 1', 1)\n          .addButton('Title 2', 2)\n          .addButton('Title 3', 3)\n          .addButton('Title 4', 4);\n      }).toThrowError('3 buttons are already added and that\\'s the maximum');\n    });\n\n    it('should throw an error if there\\'s more than 10 bubbles', () => {\n      expect(() =>\n        generic\n          .addBubble('1', 'hello')\n          .addBubble('2', 'hello')\n          .addBubble('3', 'hello')\n          .addBubble('4', 'hello')\n          .addBubble('5', 'hello')\n          .addBubble('6', 'hello')\n          .addBubble('7', 'hello')\n          .addBubble('8', 'hello')\n          .addBubble('9', 'hello')\n          .addBubble('10', 'hello')\n          .addBubble('11', 'hello')\n      )\n      .toThrowError('10 bubbles are maximum for Generic template');\n    });\n\n    it('should return a formated object in the end', () => {\n      expect(\n        generic\n          .addBubble('Title')\n          .get()\n      ).toEqual({\n        attachment: {\n          type: 'template',\n          payload: {\n            template_type: 'generic',\n            elements: [{\n              title: 'Title'\n            }]\n          }\n        }\n      });\n    });\n  });\n\n  describe('Button template', () => {\n    it('should be a class', () => {\n      let button = new formatFbMessage.Button('Test');\n\n      expect(typeof formatFbMessage.Button).toBe('function');\n      expect(button instanceof formatFbMessage.Button).toBeTruthy();\n    });\n\n    it('should throw an error if button text is not provided', () => {\n      expect(() => new formatFbMessage.Button()).toThrowError('Button template text cannot be empty');\n    });\n\n    it('should throw an error if button text is longer than 640 characters', () => {\n      expect(() => new formatFbMessage.Button(Array(641).fill('x').join(''))).toThrowError('Button template text cannot be longer than 640 characters');\n    });\n\n    it('should create a button template with the text when valid text is provided', () => {\n      let button = new formatFbMessage.Button('Test');\n\n      expect(button.template.attachment.payload.text).toBe('Test');\n    });\n\n    it('should throw an error if you add a button without the title', () => {\n      let button = new formatFbMessage.Button('Test');\n\n      expect(() => button.addButton()).toThrowError('Button title cannot be empty');\n    });\n\n    it('should throw an error if you add a button without the value', () => {\n      let button = new formatFbMessage.Button('Test');\n\n      expect(() => button.addButton('Title')).toThrowError('Button value is required');\n    });\n\n    it('should add a button with title and payload if you pass valid format', () => {\n      let button = new formatFbMessage.Button('Test');\n      button.addButton('Title 1', 1);\n\n      expect(button.template.attachment.payload.buttons.length).toBe(1);\n      expect(button.template.attachment.payload.buttons[0].title).toBe('Title 1');\n      expect(button.template.attachment.payload.buttons[0].type).toBe('postback');\n      expect(button.template.attachment.payload.buttons[0].payload).toBe(1);\n      expect(button.template.attachment.payload.buttons[0].url).not.toBeDefined();\n    });\n\n    it('should add a button with title and url if you pass valid format', () => {\n      let button = new formatFbMessage.Button('Test');\n      button.addButton('Title 1', 'http://google.com');\n\n      expect(button.template.attachment.payload.buttons.length).toBe(1);\n      expect(button.template.attachment.payload.buttons[0].title).toBe('Title 1');\n      expect(button.template.attachment.payload.buttons[0].type).toBe('web_url');\n      expect(button.template.attachment.payload.buttons[0].url).toBe('http://google.com');\n      expect(button.template.attachment.payload.buttons[0].payload).not.toBeDefined();\n    });\n\n    it('should add 3 buttons with valid titles and formats', () => {\n      const button = new formatFbMessage.Button('Test');\n      button\n        .addButton('b1', 'v1')\n        .addButton('b2', 'v2')\n        .addButton('b3', 'v3');\n\n      expect(button.template.attachment.payload.buttons.length).toBe(3);\n      expect(button.template.attachment.payload.buttons[0].title).toBe('b1');\n      expect(button.template.attachment.payload.buttons[0].payload).toBe('v1');\n      expect(button.template.attachment.payload.buttons[1].title).toBe('b2');\n      expect(button.template.attachment.payload.buttons[1].payload).toBe('v2');\n      expect(button.template.attachment.payload.buttons[2].title).toBe('b3');\n      expect(button.template.attachment.payload.buttons[2].payload).toBe('v3');\n    });\n\n    it('should throw an error if call button is added with wrong phone format', () => {\n      const button = new formatFbMessage.Button('Test');\n      expect(() => button.addCallButton('Title')).toThrowError('Call button value needs to be a valid phone number in following format: +1234567...');\n      expect(() => button.addCallButton('Title', 123)).toThrowError('Call button value needs to be a valid phone number in following format: +1234567...');\n      expect(() => button.addCallButton('Title', 'abc')).toThrowError('Call button value needs to be a valid phone number in following format: +1234567...');\n      expect(() => button.addCallButton('Title', '+123')).toThrowError('Call button value needs to be a valid phone number in following format: +1234567...');\n    });\n\n    it('should add a call button', () => {\n      const button = new formatFbMessage.Button('Test')\n        .addCallButton('Button 1', '+123456789');\n\n      expect(button.template.attachment.payload.buttons.length).toBe(1);\n      expect(button.template.attachment.payload.buttons[0].title).toBe('Button 1');\n      expect(button.template.attachment.payload.buttons[0].payload).toBe('+123456789');\n      expect(button.template.attachment.payload.buttons[0].type).toBe('phone_number');\n    });\n\n    it('should add a share button', () => {\n      const button = new formatFbMessage.Button('Test')\n        .addShareButton();\n\n      expect(button.template.attachment.payload.buttons.length).toBe(1);\n      expect(button.template.attachment.payload.buttons[0].title).toBeUndefined();\n      expect(button.template.attachment.payload.buttons[0].type).toBe('element_share');\n    });\n\n    it('should add a share button with share content', () => {\n      const shareContent = {\n        attachment: {\n          type: 'template',\n          payload: {\n            template_type: 'generic',\n            elements: [\n              {\n                title: `I took Peter's \"Which Hat Are You?\" Quiz`,\n                subtitle: 'My result: Fez',\n                image_url: 'https//bot.peters-hats.com/img/hats/fez.jpg',\n                default_action: {\n                  type: 'web_url',\n                  url: 'http://m.me/petershats?ref=invited_by_24601'\n                },\n                buttons: [{\n                  type: 'web_url',\n                  url: 'http://m.me/petershats?ref=invited_by_24601',\n                  title: 'Take Quiz'\n                }]\n              }\n            ]\n          }\n        }\n      };\n      const button = new formatFbMessage.Button('Test')\n        .addShareButton(shareContent);\n\n      expect(button.template.attachment.payload.buttons.length).toBe(1);\n      expect(button.template.attachment.payload.buttons[0].title).toBeUndefined();\n      expect(button.template.attachment.payload.buttons[0].type).toBe('element_share');\n      expect(button.template.attachment.payload.buttons[0].share_contents).toEqual(shareContent);\n    });\n\n    it('should throw an error if all arguments are not provided for buy button', () => {\n      const button = new formatFbMessage.Button('Test');\n\n      expect(() => button.addBuyButton()).toThrowError('Button value is required');\n      expect(() => button.addBuyButton('Title')).toThrowError('Button value is required');\n      expect(() => button.addBuyButton('Title', 'PAYLOAD')).toThrowError('Payment summary is required for buy button');\n      expect(() => button.addBuyButton('Title', 'PAYLOAD', 123)).toThrowError('Payment summary is required for buy button');\n      expect(() => button.addBuyButton('Title', 'PAYLOAD', 'abc')).toThrowError('Payment summary is required for buy button');\n    });\n\n    it('should add a buy button', () => {\n      const button = new formatFbMessage.Button('Test')\n        .addBuyButton('Buy', 'BUY_PAYLOAD', {\n          additionalOptions: true\n        });\n\n      expect(button.template.attachment.payload.buttons.length).toBe(1);\n      expect(button.template.attachment.payload.buttons[0].title).toBe('Buy');\n      expect(button.template.attachment.payload.buttons[0].type).toBe('payment');\n      expect(button.template.attachment.payload.buttons[0].payload).toBe('BUY_PAYLOAD');\n      expect(button.template.attachment.payload.buttons[0].payment_summary).toEqual({\n        additionalOptions: true\n      });\n    });\n\n    it('should throw an error if url provided for login button is not valid', () => {\n      const button = new formatFbMessage.Button('Test');\n\n      expect(() => button.addLoginButton()).toThrowError('Valid URL is required for Login button');\n      expect(() => button.addLoginButton('123')).toThrowError('Valid URL is required for Login button');\n    });\n\n    it('should add a login button', () => {\n      const button = new formatFbMessage.Button('Test')\n        .addLoginButton('https://example.com');\n\n      expect(button.template.attachment.payload.buttons.length).toBe(1);\n      expect(button.template.attachment.payload.buttons[0].title).toBeUndefined();\n      expect(button.template.attachment.payload.buttons[0].type).toBe('account_link');\n      expect(button.template.attachment.payload.buttons[0].url).toBe('https://example.com');\n    });\n\n    it('should add a logout button', () => {\n      const button = new formatFbMessage.Button('Test')\n        .addLogoutButton();\n\n      expect(button.template.attachment.payload.buttons.length).toBe(1);\n      expect(button.template.attachment.payload.buttons[0].title).toBeUndefined();\n      expect(button.template.attachment.payload.buttons[0].type).toBe('account_unlink');\n    });\n\n    it('should return a formated object in the end', () => {\n      expect(\n        new formatFbMessage.Button('Test')\n          .addButton('Title 1', 1)\n          .get()\n      ).toEqual({\n        attachment: {\n          type: 'template',\n          payload: {\n            template_type: 'button',\n            text: 'Test',\n            buttons: [{\n              type: 'postback',\n              title: 'Title 1',\n              payload: 1\n            }]\n          }\n        }\n      });\n    });\n  });\n\n  describe('Receipt template', () => {\n    let fbExample = {\n      attachment: {\n        type: 'template',\n        payload: {\n          template_type: 'receipt',\n          recipient_name: 'Stephane Crozatier',\n          order_number: '12345678902',\n          currency: 'USD',\n          payment_method: 'Visa 2345',\n          order_url: 'http://petersapparel.parseapp.com/order?order_id=123456',\n          timestamp: 1428444852,\n          elements: [\n            {\n              title: 'Classic White T-Shirt',\n              subtitle: '100% Soft and Luxurious Cotton',\n              quantity: 2,\n              price: 50,\n              currency: 'USD',\n              image_url: 'http://petersapparel.parseapp.com/img/whiteshirt.png'\n            },\n            {\n              title: 'Classic Gray T-Shirt',\n              subtitle: '100% Soft and Luxurious Cotton',\n              quantity: 1,\n              price: 25,\n              currency: 'USD',\n              image_url: 'http://petersapparel.parseapp.com/img/grayshirt.png'\n            }\n          ],\n          address: {\n            street_1: '1 Hacker Way',\n            street_2: '',\n            city: 'Menlo Park',\n            postal_code: '94025',\n            state: 'CA',\n            country: 'US'\n          },\n          summary: {\n            subtotal: 75.00,\n            shipping_cost: 4.95,\n            total_tax: 6.19,\n            total_cost: 56.14\n          },\n          adjustments: [\n            {\n              name: 'New Customer Discount',\n              amount: 20\n            },\n            {\n              name: '$10 Off Coupon',\n              amount: 10\n            }\n          ]\n        }\n      }\n    };\n\n    it('should be a class', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n\n      expect(typeof formatFbMessage.Receipt).toBe('function');\n      expect(receipt instanceof formatFbMessage.Receipt).toBeTruthy();\n    });\n\n    it('should throw an error if recipient\\'s name is not defined', () => {\n      expect(() => new formatFbMessage.Receipt()).toThrowError('Recipient\\'s name cannot be empty');\n    });\n\n    it('should throw an error if order number is not defined', () => {\n      expect(() => new formatFbMessage.Receipt('John Doe')).toThrowError('Order number cannot be empty');\n    });\n\n    it('should throw an error if currency is not defined', () => {\n      expect(() => new formatFbMessage.Receipt('John Doe', 'O123')).toThrowError('Currency cannot be empty');\n    });\n\n    it('should throw an error if payment method is not defined', () => {\n      expect(() => new formatFbMessage.Receipt('John Doe', 'O123', '$')).toThrowError('Payment method cannot be empty');\n    });\n\n    it('should create a receipt template object if recipient, order number, currency and payment method are passed', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n\n      expect(typeof receipt).toBe('object');\n      expect(receipt.template.attachment.payload.recipient_name).toBe('John Doe');\n      expect(receipt.template.attachment.payload.order_number).toBe('O123');\n      expect(receipt.template.attachment.payload.currency).toBe('$');\n      expect(receipt.template.attachment.payload.payment_method).toBe('Paypal');\n    });\n\n    it('should throw an error if user tries to add timestamp but don\\'t provide it', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n\n      expect(() => receipt.addTimestamp()).toThrowError('Timestamp is required for addTimestamp method');\n    });\n\n    it('should throw an error if timestamp is not valid date object', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n\n      expect(() => receipt.addTimestamp('invalid-timestamp')).toThrowError('Timestamp needs to be a valid Date object');\n    });\n\n    it('should add a timestamp if it is a valid date object', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt.addTimestamp(new Date('2016-06-14T20:55:31.438Z'));\n\n      expect(receipt.template.attachment.payload.timestamp).toBe(new Date('2016-06-14T20:55:31.438Z').getTime());\n    });\n\n    it('should should throw an error if user tries to add order url but doesn\\'t provide it', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n\n      expect(() => receipt.addOrderUrl()).toThrowError('Url is required for addOrderUrl method');\n    });\n\n    it('should should throw an error if order url is not a valid url', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n\n      expect(() => receipt.addOrderUrl('http//invalid-url')).toThrowError('Url needs to be valid for addOrderUrl method');\n    });\n\n    it('should add an order url if it is a valid url', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt.addOrderUrl('http://google.com');\n\n      expect(receipt.template.attachment.payload.order_url).toBe('http://google.com');\n    });\n\n    it('should throw an error if there\\'s no items in order', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n\n      expect(() => receipt.get()).toThrowError('At least one element/item is required');\n    });\n\n    it('should throw an error if user tries to add an item without title', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n\n      expect(() => receipt.addItem()).toThrowError('Item title is required');\n    });\n\n    it('should add an item if valid title is provided', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt.addItem('Title');\n\n      expect(receipt.template.attachment.payload.elements.length).toBe(1);\n      expect(receipt.template.attachment.payload.elements[0].title).toBe('Title');\n    });\n\n    it('should throw an error if user tries to add an item\\'s subtitle but doesn\\'t provide it', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt.addItem('Title');\n\n      expect(() => receipt.addSubtitle()).toThrowError('Subtitle is required for addSubtitle method');\n    });\n\n    it('should add an item with a subtitle if valid subtitle is provided', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt\n        .addItem('Title')\n        .addSubtitle('Subtitle');\n\n      expect(receipt.template.attachment.payload.elements.length).toBe(1);\n      expect(receipt.template.attachment.payload.elements[0].subtitle).toBe('Subtitle');\n    });\n\n    it('should throw an error if user tries to add an item\\'s quantity but doesn\\'t provide it', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt.addItem('Title');\n\n      expect(() => receipt.addQuantity()).toThrowError('Quantity is required for addQuantity method');\n    });\n\n    it('should throw an error if user tries to add an item\\'s quantity which is not a number', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt.addItem('Title');\n\n      expect(() => receipt.addQuantity('test')).toThrowError('Quantity needs to be a number');\n    });\n\n    it('should add an item with a quantity if valid number is provided', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt\n        .addItem('Title')\n        .addQuantity(42);\n\n      expect(receipt.template.attachment.payload.elements.length).toBe(1);\n      expect(receipt.template.attachment.payload.elements[0].quantity).toBe(42);\n    });\n\n    it('should throw an error if user tries to add an item\\'s price but doesn\\'t provide it', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt.addItem('Title');\n\n      expect(() => receipt.addPrice()).toThrowError('Price is required for addPrice method');\n    });\n\n    it('should throw an error if user tries to add an item\\'s price which is not a number', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt.addItem('Title');\n\n      expect(() => receipt.addPrice('test')).toThrowError('Price needs to be a number');\n    });\n\n    it('should add an item with a quantity if valid price is provided', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt\n        .addItem('Title')\n        .addPrice(4.2);\n\n      expect(receipt.template.attachment.payload.elements.length).toBe(1);\n      expect(receipt.template.attachment.payload.elements[0].price).toBe(4.2);\n    });\n\n    it('should throw an error if user tries to add an item\\'s currency but doesn\\'t provide it', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt.addItem('Title');\n\n      expect(() => receipt.addCurrency()).toThrowError('Currency is required for addCurrency method');\n    });\n\n    it('should add an item with a currency if valid currency is provided', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt\n        .addItem('Title')\n        .addCurrency('$');\n\n      expect(receipt.template.attachment.payload.elements.length).toBe(1);\n      expect(receipt.template.attachment.payload.elements[0].currency).toBe('$');\n    });\n\n    it('should throw an error if user tries to add an item\\'s image but doesn\\'t provide it', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt.addItem('Title');\n\n      expect(() => receipt.addImage()).toThrowError('Absolute url is required for addImage method');\n    });\n\n    it('should throw an error if user tries to add an item\\'s image which is not a valid url', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt.addItem('Title');\n\n      expect(() => receipt.addImage('test')).toThrowError('Valid absolute url is required for addImage method');\n    });\n\n    it('should add an item with an image if valid url is provided', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt\n        .addItem('Title')\n        .addImage('http://google.com/path/to/image.png');\n\n      expect(receipt.template.attachment.payload.elements.length).toBe(1);\n      expect(receipt.template.attachment.payload.elements[0].image_url).toBe('http://google.com/path/to/image.png');\n    });\n\n    it('should add more than 1 item if titles are valid', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt\n        .addItem('Title 1')\n        .addItem('Title 2');\n\n      expect(receipt.template.attachment.payload.elements.length).toBe(2);\n      expect(receipt.template.attachment.payload.elements[0].title).toBe('Title 1');\n      expect(receipt.template.attachment.payload.elements[1].title).toBe('Title 2');\n    });\n\n    it('should throw an error if user tries to add a shipping address without a street address', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt\n        .addItem('Title 1');\n\n      expect(() => receipt.addShippingAddress()).toThrowError('Street is required for addShippingAddress');\n    });\n\n    it('should throw an error if user tries to add a shipping address without the city', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt\n        .addItem('Title 1');\n\n      expect(() => receipt.addShippingAddress('Bulevar Nikole Tesle 42', null)).toThrowError('City is required for addShippingAddress method');\n    });\n\n    it('should throw an error if user tries to add a shipping address without a postal code', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt\n        .addItem('Title 1');\n\n      expect(() => receipt.addShippingAddress('Bulevar Nikole Tesle 42', null, 'Belgrade')).toThrowError('Zip code is required for addShippingAddress method');\n    });\n\n    it('should throw an error if user tries to add a shipping address without the state', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt\n        .addItem('Title 1');\n\n      expect(() => receipt.addShippingAddress('Bulevar Nikole Tesle 42', null, 'Belgrade', 11070)).toThrowError('State is required for addShippingAddress method');\n    });\n\n    it('should throw an error if user tries to add a shipping address without the country', () => {\n      let receipt = new formatFbMessage.Receipt('John Doe', 'O123', '$', 'Paypal');\n      receipt\n        .addItem('Title 1');\n\n      expect(() => receipt.addShippingAddress('Bulevar Nikole Tesle 42', null, 'Belgrade', 11070, 'Serbia')).toThrowError('Country is required for addShippingAddress method');\n    });\n\n    it('should parse an example for FB documentation', () => {\n      let receipt = new formatFbMessage.Receipt('Stephane Crozatier', '12345678902', 'USD', 'Visa 2345')\n        .addTimestamp(new Date(1428444852))\n        .addOrderUrl('http://petersapparel.parseapp.com/order?order_id=123456')\n        .addItem('Classic White T-Shirt')\n          .addSubtitle('100% Soft and Luxurious Cotton')\n          .addQuantity(2)\n          .addPrice(50)\n          .addCurrency('USD')\n          .addImage('http://petersapparel.parseapp.com/img/whiteshirt.png')\n        .addItem('Classic Gray T-Shirt')\n          .addSubtitle('100% Soft and Luxurious Cotton')\n          .addQuantity(1)\n          .addPrice(25)\n          .addCurrency('USD')\n          .addImage('http://petersapparel.parseapp.com/img/grayshirt.png')\n        .addShippingAddress('1 Hacker Way', '', 'Menlo Park', '94025',  'CA', 'US')\n        .addSubtotal(75.00)\n        .addShippingCost(4.95)\n        .addTax(6.19)\n        .addTotal(56.14)\n        .addAdjustment('New Customer Discount', 20)\n        .addAdjustment('$10 Off Coupon', 10)\n        .get();\n\n      expect(receipt).toEqual(fbExample);\n    });\n\n  });\n\n  describe('Image attachment', () => {\n    it('should be a class', () => {\n      let image = new formatFbMessage.Image('http://google.com');\n\n      expect(typeof formatFbMessage.Image).toBe('function');\n      expect(image instanceof formatFbMessage.Image).toBeTruthy();\n    });\n\n    it('should throw an error if you add an image without the url', () => {\n      expect(() => new formatFbMessage.Image()).toThrowError('Image template requires a valid URL as a first parameter');\n    });\n\n    it('should throw an error if you add an image with invalid url', () => {\n      expect(() => new formatFbMessage.Image('google')).toThrowError('Image template requires a valid URL as a first parameter');\n    });\n\n    it('should add an image with given URL if URL is valid', () => {\n      let image = new formatFbMessage.Image('http://google.com/path/to/image.png');\n\n      expect(image.template.attachment.payload.url).toEqual('http://google.com/path/to/image.png');\n    });\n\n    it('should return a formated object in the end', () => {\n      expect(\n        new formatFbMessage.Image('http://google.com/path/to/image.png').get()\n      ).toEqual({\n        attachment: {\n          type: 'image',\n          payload: {\n            url: 'http://google.com/path/to/image.png'\n          }\n        }\n      });\n    });\n  });\n\n  describe('List template', () => {\n    let list;\n\n    beforeEach(() => {\n      list = new formatFbMessage.List();\n    });\n\n    it('should be a class', () => {\n      expect(typeof formatFbMessage.List).toBe('function');\n      expect(list instanceof formatFbMessage.List).toBeTruthy();\n    });\n\n    it('should throw an error if at least two bubble/element are not added', () => {\n      expect(() => list.get()).toThrowError('2 bubbles are minimum for List template!');\n    });\n\n    it('should throw an error if bubble title does not exist', () => {\n      expect(() => list.addBubble()).toThrowError('Bubble title cannot be empty');\n    });\n\n    it('should throw an error if bubble title is too long', () => {\n      expect(() => list.addBubble('Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua')).toThrowError('Bubble title cannot be longer than 80 characters');\n    });\n\n    it('should throw an error if bubble subtitle is too long', () => {\n      expect(() => list.addBubble('Test', 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua')).toThrowError('Bubble subtitle cannot be longer than 80 characters');\n    });\n\n    it('should add a bubble with a provided title', () => {\n      list.addBubble('Test');\n\n      expect(list.bubbles.length).toBe(1);\n      expect(list.bubbles[0].title).toBe('Test');\n    });\n\n    it('should add a bubble with a provided title and subtitle', () => {\n      list.addBubble('Test Title', 'Test Subtitle');\n\n      expect(list.bubbles.length).toBe(1);\n      expect(list.bubbles[0].title).toBe('Test Title');\n      expect(list.bubbles[0].subtitle).toBe('Test Subtitle');\n    });\n\n    it('should throw an error if you try to add an image but not provide an url', () => {\n      list\n        .addBubble('Test');\n\n      expect(() => list.addImage()).toThrowError('Image URL is required for addImage method');\n    });\n\n    it('should throw an error if you try to add an image, but url is in invalid format', () => {\n      list\n        .addBubble('Test');\n\n      expect(() => list.addImage('http//invalid-url')).toThrowError('Image URL needs to be valid for addImage method');\n    });\n\n    it('should add an image if it is valid', () => {\n      list\n        .addBubble('Test')\n        .addImage('http://google.com/path/to/image.png');\n\n      expect(list.bubbles.length).toBe(1);\n      expect(list.bubbles[0].image_url).toBe('http://google.com/path/to/image.png');\n    });\n\n    it('should throw an error if you add a button without the title', () => {\n      list\n        .addBubble('Test');\n\n      expect(() => list.addButton()).toThrowError('Button title cannot be empty');\n    });\n\n    it('should throw an error if you add a button without the value', () => {\n      list\n        .addBubble('Test');\n\n      expect(() => list.addButton('Title')).toThrowError('Button value is required');\n    });\n\n    it('should add a button with title and payload if you pass valid format', () => {\n      list\n        .addBubble('Test')\n        .addButton('Title 1', 1);\n\n      expect(list.bubbles[0].buttons.length).toBe(1);\n      expect(list.bubbles[0].buttons[0].title).toBe('Title 1');\n      expect(list.bubbles[0].buttons[0].type).toBe('postback');\n      expect(list.bubbles[0].buttons[0].payload).toBe(1);\n      expect(list.bubbles[0].buttons[0].url).not.toBeDefined();\n    });\n\n    it('should add a button with a share url', () => {\n      list\n        .addBubble('Test')\n        .addShareButton();\n\n      expect(list.bubbles[0].buttons.length).toBe(1);\n      expect(list.bubbles[0].buttons[0].type).toBe('element_share');\n    });\n\n    it('should add a button with title and url if you pass valid format', () => {\n      list\n        .addBubble('Test')\n        .addButton('Title 1', 'http://google.com');\n\n      expect(list.bubbles[0].buttons.length).toBe(1);\n      expect(list.bubbles[0].buttons[0].title).toBe('Title 1');\n      expect(list.bubbles[0].buttons[0].type).toBe('web_url');\n      expect(list.bubbles[0].buttons[0].url).toBe('http://google.com');\n      expect(list.bubbles[0].buttons[0].payload).not.toBeDefined();\n    });\n\n    it('should override type when a type parameter is passed', () => {\n      list\n        .addBubble('Test')\n        .addButton('b1', '+123456789', 'phone_number');\n\n      expect(list.bubbles[0].buttons[0].type).toBe('phone_number');\n    });\n\n    it('should throw an error if you add more than 1 button', () => {\n      list\n        .addBubble('Test');\n\n      expect(() => {\n        list\n          .addButton('Title 1', 1)\n          .addButton('Title 2', 2);\n      }).toThrowError('One button is already added and that\\'s the maximum');\n    });\n\n    it('should throw an error if you add a default action without the url', () => {\n      list\n        .addBubble('Test');\n\n      expect(() => list.addDefaultAction()).toThrowError('Bubble default action URL is required');\n    });\n\n    it('should throw an error if you add a default action without the url', () => {\n      list\n        .addBubble('Test');\n\n      expect(() => list.addDefaultAction('some_url')).toThrowError('Bubble default action URL must be valid URL');\n    });\n\n    it('should throw an error if you add a more than one default action', () => {\n      list\n        .addBubble('Test')\n        .addDefaultAction('http://google.com/some/action');\n\n      expect(() => list.addDefaultAction('http://google.com/some/action')).toThrowError('Bubble already has default action');\n    });\n\n    it('should add default action', () => {\n      list\n        .addBubble('1', 'hello')\n        .addDefaultAction('http://google.com/some/action');\n\n      expect(list.bubbles.length).toBe(1);\n      expect(list.bubbles[0].default_action.type).toBe('web_url');\n      expect(list.bubbles[0].default_action.url).toBe('http://google.com/some/action');\n    });\n\n    it('should throw an error if there\\'s more than 4 bubbles', () => {\n      expect(() =>\n        list\n          .addBubble('1', 'hello')\n          .addBubble('2', 'hello')\n          .addBubble('3', 'hello')\n          .addBubble('4', 'hello')\n          .addBubble('5', 'hello')\n      )\n        .toThrowError('4 bubbles are maximum for List template');\n    });\n\n    it('should throw an error if you add a list button without the title', () => {\n      list\n        .addBubble('Test');\n\n      expect(() => list.addListButton()).toThrowError('List button title cannot be empty');\n    });\n\n    it('should throw an error if you add a list button without the value', () => {\n      list\n        .addBubble('Test');\n\n      expect(() => list.addListButton('Title')).toThrowError('List button value is required');\n    });\n\n    it('should throw an error if there\\'s more than 1 list buttons', () => {\n      expect(() =>\n        list\n          .addBubble('1', 'hello')\n          .addListButton('Title 1', 1)\n          .addListButton('Title 2', 2)\n      )\n        .toThrowError('One List button is already added and that\\'s the maximum');\n    });\n\n    it('should add list button', () => {\n      list\n          .addBubble('1', 'hello')\n          .addListButton('Title 1', 1);\n\n      let buttons = list.template.attachment.payload.buttons;\n\n      expect(buttons.length).toBe(1);\n      expect(buttons[0].title).toBe('Title 1');\n      expect(buttons[0].type).toBe('postback');\n      expect(buttons[0].payload).toBe(1);\n      expect(buttons[0].url).not.toBeDefined();\n    });\n\n    it('should return a formated object in the end', () => {\n      expect(\n        list\n          .addBubble('Title 1')\n            .addImage('http://google.com/path/to/image.png')\n          .addBubble('Title 2')\n          .get()\n      ).toEqual({\n        attachment: {\n          type: 'template',\n          payload: {\n            template_type: 'list',\n            top_element_style: 'large',\n            buttons: [],\n            elements: [\n              {\n                title: 'Title 1',\n                image_url: 'http://google.com/path/to/image.png'\n              },\n              {\n                title: 'Title 2'\n              }\n            ]\n          }\n        }\n      });\n    });\n  });\n  describe('ChatAction', () => {\n    it('should send a chat action if it is correct', () => {\n      expect(new formatFbMessage.ChatAction('typing_on').get()).toEqual({\n        sender_action: 'typing_on'\n      });\n      expect(new formatFbMessage.ChatAction('typing_off').get()).toEqual({\n        sender_action: 'typing_off'\n      });\n      expect(new formatFbMessage.ChatAction('mark_seen').get()).toEqual({\n        sender_action: 'mark_seen'\n      });\n    });\n    it('should throw an error if chat action is not valid', () => {\n      expect(() => new formatFbMessage.ChatAction('invalid_chat_action').get()).toThrowError('Valid action is required for Facebook ChatAction template. Available actions are: typing_on, typing_off and mark_seen.');\n    });\n  });\n  describe('Pause', () => {\n    it('should be a class', () => {\n      const message = new formatFbMessage.Pause(200);\n      expect(typeof formatFbMessage.Pause).toBe('function');\n      expect(message instanceof formatFbMessage.Pause).toBeTruthy();\n    });\n\n    it('should generate an object with a defined value', () => {\n      const message = new formatFbMessage.Pause(1000).get();\n      expect(message).toEqual({\n        claudiaPause: 1000\n      });\n    });\n\n    it('should generate an object with a default value', () => {\n      const message = new formatFbMessage.Pause().get();\n      expect(message).toEqual({\n        claudiaPause: 500\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/facebook/facebook-integration-spec.js":"/*global describe, it, jasmine, expect, beforeEach*/\nvar botBuilder = require('../../lib/bot-builder'),\n  https = require('https');\ndescribe('Facebook Bot integration test', () => {\n  var messageHandler,\n    underTest,\n    lambdaContextSpy,\n    singleMessageTemplate = {\n      'object':'page',\n      'entry':[\n        {\n          'id': 'PAGE_ID',\n          'time': 1457764198246,\n          'messaging':[\n            {\n              'sender':{\n                'id':'USER_ID'\n              },\n              'recipient':{\n                'id':'PAGE_ID'\n              },\n              'timestamp':1457764197627,\n              'message':{\n                'mid':'mid.1457764197618:41d102a3e1ae206a38',\n                'seq':73,\n                'text':'hello, world!'\n              }\n            }\n          ]\n        }\n      ]\n    };\n\n  beforeEach(() => {\n    messageHandler = jasmine.createSpy('messageHandler');\n    lambdaContextSpy = jasmine.createSpyObj('lambdaContext', ['done']);\n    underTest = botBuilder(messageHandler, {}, () => {});\n  });\n\n  describe('API integration wiring', () => {\n    describe('token verification', () => {\n      it('uses the text/plain content type', () => {\n        expect(underTest.apiConfig().routes.facebook.GET.success.contentType).toEqual('text/plain');\n      });\n\n      it('returns hub challenge if the tokens match', (done) => {\n        underTest.proxyRouter({\n          requestContext: {\n            resourcePath: '/facebook',\n            httpMethod: 'GET'\n          },\n          queryStringParameters: {\n            'hub.verify_token': '12345',\n            'hub.challenge': 'XHCG'\n          },\n          stageVariables: {\n            facebookVerifyToken: '12345'\n          }\n        }, lambdaContextSpy).then(() => {\n          expect(lambdaContextSpy.done).toHaveBeenCalledWith(null, jasmine.objectContaining({body:'XHCG'}));\n        }).then(done, done.fail);\n      });\n\n      it('returns Error challenge if the tokens do not match', (done) => {\n        underTest.proxyRouter({\n          requestContext: {\n            resourcePath: '/facebook',\n            httpMethod: 'GET'\n          },\n          queryStringParameters: {\n            'hub.verify_token': '123x',\n            'hub.challenge': 'XHCG'\n          },\n          stageVariables: {\n            facebookVerifyToken: '12345'\n          }\n        }, lambdaContextSpy).then(() => {\n          expect(lambdaContextSpy.done).toHaveBeenCalledWith(null, jasmine.objectContaining({body:'Error'}));\n        }).then(done, done.fail);\n      });\n    });\n    describe('message handling', () => {\n      it('sends the response using https to facebook', done => {\n        messageHandler.and.returnValue(Promise.resolve('YES'));\n\n        underTest.proxyRouter({\n          requestContext: {\n            resourcePath: '/facebook',\n            httpMethod: 'POST'\n          },\n          body: singleMessageTemplate,\n          stageVariables: {\n            facebookAccessToken: '12345'\n          }\n        }, lambdaContextSpy);\n\n        https.request.pipe(callOptions => {\n          expect(callOptions).toEqual(jasmine.objectContaining({\n            method: 'POST',\n            hostname: 'graph.facebook.com',\n            path: '/v2.6/me/messages?access_token=12345',\n            protocol: 'https:',\n            headers: { 'Content-Type': 'application/json' },\n            body: '{\"recipient\":{\"id\":\"USER_ID\"},\"message\":{\"text\":\"YES\"}}'\n          }));\n          done();\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/facebook/facebook-parse-spec.js":"/*global describe, it, expect, require */\nvar parse = require('../../lib/facebook/parse');\ndescribe('Facebook parse', () => {\n  it('returns nothing if the format is invalid', () => {\n    expect(parse('string')).toBeUndefined();\n    expect(parse()).toBeUndefined();\n    expect(parse(false)).toBeUndefined();\n    expect(parse(123)).toBeUndefined();\n    expect(parse({})).toBeUndefined();\n    expect(parse([1, 2, 3])).toBeUndefined();\n  });\n  it('returns false if the message or sender are missing', () => {\n    expect(parse({sender: 'tom'})).toBeUndefined();\n    expect(parse({message: 'pete'})).toBeUndefined();\n  });\n  it('returns a parsed object when there message and sender are present', () => {\n    var msg = {sender: {id: 'tom'}, message: { text: 'Hello' }};\n    expect(parse(msg, {})).toEqual({ sender: 'tom', text: 'Hello', originalRequest: msg, type: 'facebook'});\n  });\n  it('returns a parsed object for postback messages', () => {\n    var msg = {\n      sender: { id: '12345' },\n      recipient: { id: '67890' },\n      timestamp: 1465558466933,\n      postback: { payload: 'POSTBACK' }\n    };\n    expect(parse(msg)).toEqual({\n      sender: '12345',\n      text: 'POSTBACK',\n      originalRequest: msg,\n      postback: true,\n      type: 'facebook'\n    });\n  });\n  it('returns a parsed object for a quick reply', () => {\n    var msg = {\n      sender: { id: '12345' },\n      recipient: { id: '67890' },\n      timestamp: 1465558466933,\n      message: {\n        mid: 'mid.1464990849238:b9a22a2bcb1de31773',\n        seq: 69,\n        quick_reply: {\n          payload: 'QUICK_REPLY'\n        }\n      }\n    };\n    expect(parse(msg)).toEqual({\n      sender: '12345',\n      text: 'QUICK_REPLY',\n      originalRequest: msg,\n      type: 'facebook',\n      postback: true\n    });\n  });\n  it('does not parse the object if it is delivery report', () => {\n    var msg = {\n      sender: { id: '12345' },\n      recipient: { id: '67890' },\n      timestamp: 1465558466933,\n      delivery: {\n        mids: ['mid.1458668856218:ed81099e15d3f4f233'],\n        watermark: 1458668856253,\n        seq: 37\n      }\n    };\n    expect(parse(msg)).toBeFalsy();\n  });\n  it('does not parse the object if it is read report', () => {\n    var msg = {\n      sender: { id: '12345' },\n      recipient: { id: '67890' },\n      timestamp: 1465558466933,\n      read: {\n        watermark: 1458668856253,\n        seq: 38\n      }\n    };\n    expect(parse(msg)).toBeFalsy();\n  });\n  it('does not parse the object if it is an echo message', () => {\n    var msg = {\n      sender: {\n        id: '12345'\n      },\n      recipient: {\n        id: '54321'\n      },\n      timestamp: 1483413621558,\n      message: {\n        is_echo: true,\n        app_id: 314159,\n        mid: 'mid.1483413621558:a9dc28cb84',\n        seq: 1022,\n        text: 'Some text'\n      }\n    };\n    expect(parse(msg)).toBeFalsy();\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/facebook/facebook-reply-spec.js":"/*global describe, it, expect, require, jasmine, beforeEach */\nvar reply = require('../../lib/facebook/reply'),\n  https = require('https');\ndescribe('Facebook Reply', () => {\n  'use strict';\n  beforeEach(() =>{\n    jasmine.DEFAULT_TIMEOUT_INTERVAL = 5000;\n  });\n  it('includes the token in the path request', done => {\n    https.request.pipe(callOptions => {\n      expect(callOptions).toEqual(jasmine.objectContaining({\n        method: 'POST',\n        hostname: 'graph.facebook.com',\n        path: '/v2.6/me/messages?access_token=ACCESS123',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      }));\n      done();\n    });\n    reply('user123', 'Hi there', 'ACCESS123');\n  });\n  it('sends string messages as a text object', done => {\n    https.request.pipe(callOptions => {\n      expect(JSON.parse(callOptions.body)).toEqual({\n        recipient: {\n          id: 'user123'\n        },\n        message: {\n          text: 'Hi there'\n        }\n      });\n      done();\n    });\n    reply('user123', 'Hi there', 'ACCESS123');\n  });\n  it('sends large text messages split into several', done => {\n    var longLongMessage = new Array(201).join('blok ');\n\n    https.request.pipe(function () {\n      this.respond('200', 'OK', 'Hi there');\n    });\n\n    reply('user123', longLongMessage, 'ACCESS123').then(() => {\n      expect(https.request.calls.length).toEqual(2);\n      expect(JSON.parse(https.request.calls[0].args[0].body)).toEqual({\n        recipient: {\n          id: 'user123'\n        },\n        message: {\n          text: new Array(640/5).join('blok ') + 'blok'\n        }\n      });\n      expect(JSON.parse(https.request.calls[1].args[0].body)).toEqual({\n        recipient: {\n          id: 'user123'\n        },\n        message: {\n          text: new Array((1000 - 640)/5).join('blok ') + 'blok'\n        }\n      });\n    }).then(done, done.fail);\n  });\n  it('sends requests in sequence', done => {\n    var fiveHundred = new Array(101).join('blok ');\n\n    https.request.pipe(() => {\n      Promise.resolve().then(() => {\n        expect(https.request.calls.length).toEqual(1);\n      }).then(done);\n    });\n\n    reply('user123', fiveHundred, 'ACCESS123');\n  });\n  describe('when an array is passed', () => {\n    it('does not send the second request until the first one completes', done => {\n      let answers = ['foo', 'bar'];\n      https.request.pipe(() => {\n        Promise.resolve().then(() => {\n          expect(https.request.calls.length).toEqual(1);\n        }).then(done);\n      });\n      reply('user123', answers, 'ACCESS123');\n    });\n    it('sends the requests in sequence', done => {\n      let answers = ['foo', 'bar'];\n      https.request.pipe(function () {\n        this.respond('200', 'OK');\n        if (https.request.calls.length === 2) {\n          expect(JSON.parse(https.request.calls[0].body[0])).toEqual({recipient:{id:'user123'},message:{text:'foo'}});\n          expect(JSON.parse(https.request.calls[1].body[0])).toEqual({recipient:{id:'user123'},message:{text:'bar'}});\n          done();\n        }\n      });\n      reply('user123', answers, 'ACCESS123');\n\n    });\n\n  });\n  it('sends complex messages without transforming into a text object', done => {\n    https.request.pipe(callOptions => {\n      expect(JSON.parse(callOptions.body)).toEqual({\n        recipient: {\n          id: 'user123'\n        },\n        message: {\n          template: 'big',\n          contents: {\n            title: 'red'\n          }\n        }\n      });\n      done();\n    });\n    reply('user123', {template: 'big', contents: { title: 'red'} }, 'ACCESS123');\n  });\n  it('does not send a message if message is not provided', () => {\n    reply('user123', null, 'ACCESS123')\n      .then(() => {\n        expect(https.request.calls.length).toBe(0);\n      });\n\n    reply('user123', false, 'ACCESS123')\n      .then(() => {\n        expect(https.request.calls.length).toBe(0);\n      });\n\n    reply('user123', undefined, 'ACCESS123')\n      .then(() => {\n        expect(https.request.calls.length).toBe(0);\n      });\n  });\n  it('sets a typing action if \"sender_action\" is passed', done => {\n    https.request.pipe(callOptions => {\n      expect(JSON.parse(callOptions.body)).toEqual({\n        recipient: {\n          id: 'user123'\n        },\n        sender_action: 'typing_on'\n      });\n      done();\n    });\n    reply('user123', { sender_action: 'typing_on' }, 'ACCESS123');\n  });\n  it('does not resolve before the https endpoint responds', done => {\n    https.request.pipe(done);\n    reply('user123', {template: 'big', contents: { title: 'red'} }, 'ACCESS123').then(done.fail, done.fail);\n  });\n  it('resolves when the https endpoint responds with 200', done => {\n    https.request.pipe(function () {\n      this.respond('200', 'OK', 'Hi there');\n    });\n    reply('user123', {template: 'big', contents: { title: 'red'} }, 'ACCESS123').then(done, done.fail);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/facebook/facebook-setup-spec.js":"/*global require, describe, it, expect, beforeEach, jasmine*/\n'use strict';\nvar underTest = require('../../lib/facebook/setup');\ndescribe('Facebook setup', () => {\n  var api, bot, logError, parser, responder, botPromise, botResolve, botReject;\n  beforeEach(() => {\n    api = jasmine.createSpyObj('api', ['get', 'post', 'addPostDeployStep']);\n    botPromise = new Promise((resolve, reject) => {\n      botResolve = resolve;\n      botReject = reject;\n    });\n    bot = jasmine.createSpy().and.returnValue(botPromise);\n    parser = jasmine.createSpy();\n    logError = jasmine.createSpy();\n    responder = jasmine.createSpy();\n    underTest(api, bot, logError, parser, responder);\n  });\n  describe('token validator', () => {\n    it('wires the GET request for facebook to a token validator', () => {\n      expect(api.get.calls.count()).toEqual(1);\n      expect(api.get).toHaveBeenCalledWith('/facebook', jasmine.any(Function), {success: {contentType: 'text/plain'}});\n    });\n    it('replies with hub.challenge when tokens match', () => {\n      let handler = api.get.calls.argsFor(0)[1],\n        result = handler({\n          queryString: {\n            'hub.verify_token': '12345',\n            'hub.challenge': 'XXAA'\n          }, env: {\n            facebookVerifyToken: '12345'\n          }\n        });\n      expect(result).toEqual('XXAA');\n    });\n    it('replies with Error when tokens do not match', () => {\n      let handler = api.get.calls.argsFor(0)[1],\n        result = handler({\n          queryString: {\n            'hub.verify_token': '12345',\n            'hub.challenge': 'XXAA'\n          }, env: {\n            facebookVerifyToken: '12346'\n          }\n        });\n      expect(result).toEqual('Error');\n    });\n  });\n  describe('message processor', () => {\n    const singleMessageTemplate = {\n      'object':'page',\n      'entry':[{\n        'id': 'PAGE_ID',\n        'time': 1457764198246,\n        'messaging':[\n          { 'A': 'B' }\n        ]\n      }]\n    };\n    it('wires the POST request for facebook to the message processor', () => {\n      expect(api.post.calls.count()).toEqual(1);\n      expect(api.post).toHaveBeenCalledWith('/facebook', jasmine.any(Function));\n    });\n    describe('processing a single message', () => {\n      var handler;\n      beforeEach(() => {\n        handler = api.post.calls.argsFor(0)[1];\n      });\n      it('should fail if x hub signature does not match', done => {\n        handler({body: singleMessageTemplate, rawBody: '{\"object\":\"page\",\"entry\":[{\"id\":\"PAGE_ID\",\"time\":1457764198246,\"messaging\":[{\"A\":\"B\"}]}]}', headers: {'X-Hub-Signature': 'sha1=12345'}, env: {facebookAccessToken: 'ABC', facebookAppSecret: '54321'}})\n          .catch(err => {\n            expect(err).toBe('X-Hub-Signatures does not match');\n            return;\n          })\n          .then(done, done.fail);\n      });\n      it('breaks down the message and puts it into the parser', () => {\n        handler({body: singleMessageTemplate, env: {facebookAccessToken: 'ABC'}});\n        expect(parser.calls.argsFor(0)[0]).toEqual({'A': 'B'});\n      });\n      it('passes the parsed value to the bot if a message can be parsed', (done) => {\n        parser.and.returnValue('MSG1');\n        handler({body: singleMessageTemplate, env: {}});\n        Promise.resolve().then(() => {\n          expect(bot).toHaveBeenCalledWith('MSG1', { body: singleMessageTemplate, env: {} });\n        }).then(done, done.fail);\n      });\n      it('does not invoke the bot if the message cannot be parsed', (done) => {\n        parser.and.returnValue(false);\n        handler({body: singleMessageTemplate, env: {}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(bot).not.toHaveBeenCalled();\n        }).then(done, done.fail);\n      });\n      it('responds when the bot resolves', (done) => {\n        parser.and.returnValue({sender: 'user1', text: 'MSG1'});\n        botResolve('Yes Yes');\n        handler({body: singleMessageTemplate, env: {facebookAccessToken: 'ABC'}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(responder).toHaveBeenCalledWith('user1', 'Yes Yes', 'ABC');\n        }).then(done, done.fail);\n      });\n      it('can work with bot responses as strings', (done) => {\n        bot.and.returnValue('Yes!');\n        parser.and.returnValue({sender: 'user1', text: 'MSG1'});\n        handler({body: singleMessageTemplate, env: {facebookAccessToken: 'ABC'}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(responder).toHaveBeenCalledWith('user1', 'Yes!', 'ABC');\n        }).then(done, done.fail);\n\n      });\n      it('logs error when the bot rejects without responding', (done) => {\n        parser.and.returnValue('MSG1');\n\n        handler({body: singleMessageTemplate, env: {}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(responder).not.toHaveBeenCalled();\n          expect(logError).toHaveBeenCalledWith('No No');\n        }).then(done, done.fail);\n\n        botReject('No No');\n      });\n      it('logs the error when the responder throws an error', (done) => {\n        parser.and.returnValue('MSG1');\n        responder.and.throwError('XXX');\n        botResolve('Yes');\n        handler({body: singleMessageTemplate, env: {facebookAccessToken: 'ABC'}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(logError).toHaveBeenCalledWith(jasmine.any(Error));\n        }).then(done, done.fail);\n      });\n      describe('working with promises in responders', () => {\n        var responderResolve, responderReject, responderPromise, hasResolved;\n        beforeEach(() => {\n          responderPromise = new Promise((resolve, reject) => {\n            responderResolve = resolve;\n            responderReject = reject;\n          });\n          responder.and.returnValue(responderPromise);\n\n          parser.and.returnValue('MSG1');\n        });\n        it('waits for the responders to resolve before completing the request', (done) => {\n          handler({body: singleMessageTemplate, env: {facebookAccessToken: 'ABC'}}).then(() => {\n            hasResolved = true;\n          });\n\n          botPromise.then(() => {\n            expect(hasResolved).toBeFalsy();\n          }).then(done, done.fail);\n\n          botResolve('YES');\n        });\n        it('resolves when the responder resolves', (done) => {\n          handler({body: singleMessageTemplate, env: {facebookAccessToken: 'ABC'}}).then((message) => {\n            expect(message).toEqual('ok');\n          }).then(done, done.fail);\n\n          botPromise.then(() => {\n            responderResolve('As Promised!');\n          });\n          botResolve('YES');\n        });\n        it('logs error when the responder rejects', (done) => {\n          handler({body: singleMessageTemplate, env: {facebookAccessToken: 'ABC'}}).then((message) => {\n            expect(message).toEqual('ok');\n            expect(logError).toHaveBeenCalledWith('Bomb!');\n          }).then(done, done.fail);\n\n          botPromise.then(() => {\n            responderReject('Bomb!');\n          });\n          botResolve('YES');\n        });\n      });\n    });\n    describe('multiple messages', () => {\n      const multiMessageTemplate = {\n        'object':'page',\n        'entry':[{\n          'id': 'PAGE_ID',\n          'time': 1457764198246,\n          'messaging':[\n            { 'A': 'B' },\n            { 'C': 'D' }\n          ]\n        }, {\n          'id': 'PAGE_ID',\n          'time': 1457764198246,\n          'messaging':[\n            { 'E': 'F' },\n            { 'G': 'H' }\n          ]\n        }]\n      };\n      var botPromises,\n        responderPromises,\n        handler,\n        buildPromiseFor = (array) => {\n          var pResolve, pReject, promise;\n          promise = new Promise((resolve, reject) => {\n            pResolve = resolve;\n            pReject = reject;\n          });\n          promise.resolve = pResolve;\n          promise.reject = pReject;\n          array.push(promise);\n          return promise;\n        };\n\n      beforeEach(() => {\n        var index = 0;\n        botPromises = [];\n        responderPromises = [];\n        bot.and.callFake(() => {\n          return buildPromiseFor(botPromises);\n        });\n        responder.and.callFake(() => {\n          return buildPromiseFor(responderPromises);\n        });\n        handler = api.post.calls.argsFor(0)[1];\n        parser.and.callFake(() => {\n          index += 1;\n          return {\n            sender: 'sender' + index,\n            text: 'text' + index\n          };\n        });\n      });\n      it('parses messages in sequence', () => {\n        handler({body: multiMessageTemplate, env: {facebookAccessToken: 'ABC'}});\n        expect(parser.calls.count()).toBe(4);\n        expect(parser.calls.argsFor(0)[0]).toEqual({'A': 'B'});\n        expect(parser.calls.argsFor(1)[0]).toEqual({'C': 'D'});\n        expect(parser.calls.argsFor(2)[0]).toEqual({'E': 'F'});\n        expect(parser.calls.argsFor(3)[0]).toEqual({'G': 'H'});\n      });\n      it('calls the bot for each message individually', (done) => {\n        handler({body: multiMessageTemplate, env: {facebookAccessToken: 'ABC'}});\n        Promise.resolve().then(() => {\n          expect(bot.calls.count()).toEqual(4);\n          expect(bot).toHaveBeenCalledWith({sender: 'sender1', text: 'text1'}, {body: multiMessageTemplate, env: {facebookAccessToken: 'ABC'}});\n          expect(bot).toHaveBeenCalledWith({sender: 'sender2', text: 'text2'}, {body: multiMessageTemplate, env: {facebookAccessToken: 'ABC'}});\n          expect(bot).toHaveBeenCalledWith({sender: 'sender3', text: 'text3'}, {body: multiMessageTemplate, env: {facebookAccessToken: 'ABC'}});\n          expect(bot).toHaveBeenCalledWith({sender: 'sender4', text: 'text4'}, {body: multiMessageTemplate, env: {facebookAccessToken: 'ABC'}});\n        }).then(done, done.fail);\n      });\n      it('calls the responders for each bot response individually', (done) => {\n        handler({body: multiMessageTemplate, env: {facebookAccessToken: 'ABC'}});\n        Promise.resolve().then(() => {\n          botPromises[0].resolve('From first');\n          botPromises[1].resolve('From second');\n          return botPromises[1];\n        }).then(() => {\n          expect(responder).toHaveBeenCalledWith('sender1', 'From first', 'ABC');\n          expect(responder).toHaveBeenCalledWith('sender2', 'From second', 'ABC');\n        }).then(done, done.fail);\n      });\n      it('does not resolve until all the responders resolve', (done) => {\n        var hasResolved;\n        handler({body: multiMessageTemplate, env: {facebookAccessToken: 'ABC'}}).then(() => {\n          hasResolved = true;\n        }).then(done.fail, done.fail);\n        Promise.resolve().then(() => {\n          botPromises.forEach((p) => p.resolve('group'));\n          return botPromises.pop();\n        }).then(() => {\n          responderPromises.slice(1).forEach((p) => p.resolve('result'));\n          return responderPromises.pop();\n        }).then(() => {\n          expect(hasResolved).toBeFalsy();\n        }).then(done, done.fail);\n      });\n      it('resolves when all the responders resolve', (done) => {\n        handler({body: multiMessageTemplate, env: {facebookAccessToken: 'ABC'}}).then((message) => {\n          expect(message).toEqual('ok');\n        }).then(done, done.fail);\n        Promise.resolve().then(() => {\n          botPromises.forEach((p) => p.resolve('group'));\n          return botPromises.pop();\n        }).then(() => {\n          responderPromises.forEach((p) => p.resolve('result'));\n          return responderPromises.pop();\n        });\n      });\n    });\n\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/groupme/groupme-parse-spec.js":"/*global describe, it, expect, require */\n'use strict';\nvar parse = require('../../lib/groupme/parse');\n\ndescribe('GroupMe parse', () => {\n  it('returns nothing if the format is invalid', () => {\n    expect(parse('string')).toBeUndefined();\n    expect(parse()).toBeUndefined();\n    expect(parse(false)).toBeUndefined();\n    expect(parse(123)).toBeUndefined();\n    expect(parse({})).toBeUndefined();\n    expect(parse([1, 2, 3])).toBeUndefined();\n  });\n  it('returns undefined if the message text is missing', () => {\n    expect(parse({sender_type: 'user', group_id: 1 })).toBeUndefined();\n  });\n  it('returns undefined if the message group_id is missing', () => {\n    expect(parse({sender_type: 'user', text: 'hello groupme'})).toBeUndefined();\n  });\n  it('returns undefined if the message sender_type is a bot', () => {\n    expect(parse({sender_type: 'bot', text: 'hello groupme', group_id: 1})).toBeUndefined();\n  });\n  it('returns a parsed object with proper sender and text when the text and group_id are present and sender_type is not a bot', () => {\n    var msg = {group_id: 1, text: 'hello groupme', sender_type: 'user'};\n    expect(parse(msg)).toEqual({ sender: 1, text: 'hello groupme', originalRequest: msg, type: 'groupme'});\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/groupme/groupme-reply-spec.js":"/*global describe, it, expect, require, jasmine */\n'use strict';\nvar reply = require('../../lib/groupme/reply'),\n  https = require('https');\n\ndescribe('GroupMe Reply', () => {\n\n  it('includes the Content type application/json in the header', done => {\n    https.request.pipe(callOptions => {\n      var data = { bot_id: 123123, text: 'hello groupme' };\n      expect(callOptions).toEqual(jasmine.objectContaining({\n        method: 'POST',\n        hostname: 'api.groupme.com',\n        path: '/v3/bots/post',\n        headers: {\n          'content-type': 'application/json'\n        },\n        body: JSON.stringify(data)\n      }));\n      done();\n    });\n    reply({ sender: 1, text: 'hello groupme', originalRequest: {}, type: 'groupme'}, 123123);\n  });\n\n  it('sends messages as a string', done => {\n    https.request.pipe(callOptions => {\n      expect(callOptions.body).toEqual(JSON.stringify({\n        bot_id: 123123,\n        text: 'hello groupme'\n      }));\n      done();\n    });\n    reply('hello groupme', 123123);\n  });\n\n  it('does not resolve before the https endpoint responds', done => {\n    https.request.pipe(done);\n    reply({ sender: 1, text: 'hello groupme', originalRequest: {}, type: 'groupme'}, 123123\n    ).then(done.fail, done.fail);\n  });\n\n  it('resolves when the https endpoint responds with 200', done => {\n    https.request.pipe(() => {\n      setTimeout(() => {\n        https.request.calls[0].respond('200', 'OK', 'Hello GroupMe');\n      }, 10);\n    });\n    reply({ sender: 1, text: 'hello groupme', originalRequest: {}, type: 'groupme'}, 123123).then(done, done.fail);\n  });\n\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/groupme/groupme-setup-spec.js":"/*global require, describe, it, expect, beforeEach, jasmine*/\n'use strict';\nvar underTest = require('../../lib/groupme/setup');\ndescribe('GroupMe setup', () => {\n  var api, bot, logError, parser, responder, botPromise, botResolve, botReject;\n  beforeEach(() => {\n    api = jasmine.createSpyObj('api', ['get', 'post', 'addPostDeployStep']);\n    botPromise = new Promise((resolve, reject) => {\n      botResolve = resolve;\n      botReject = reject;\n    });\n    bot = jasmine.createSpy().and.returnValue(botPromise);\n    parser = jasmine.createSpy();\n    logError = jasmine.createSpy();\n    responder = jasmine.createSpy();\n    underTest(api, bot, logError, parser, responder);\n  });\n  describe('message processor', () => {\n    const singleMessageTemplate = {\n      group_id: 345678,\n      text: 'hello GroupMe',\n      sender_type: 'user'\n    };\n    it('wires the POST request for kik to the message processor', () => {\n      expect(api.post.calls.count()).toEqual(1);\n      expect(api.post).toHaveBeenCalledWith('/groupme', jasmine.any(Function));\n    });\n    describe('processing a single message', () => {\n      var handler;\n      beforeEach(() => {\n        handler = api.post.calls.argsFor(0)[1];\n      });\n      it('breaks down the message and puts it into the parser', () => {\n        handler({body: singleMessageTemplate, env: {GROUPME_BOT_ID: 123123123}});\n        expect(parser).toHaveBeenCalledWith({\n          group_id: 345678,\n          text: 'hello GroupMe',\n          sender_type: 'user'\n        });\n      });\n      it('passes the parsed value to the bot if a message can be parsed', (done) => {\n        parser.and.returnValue('Group me with the group');\n        handler({body: singleMessageTemplate, env: {GROUPME_BOT_ID: 123123123}});\n        Promise.resolve().then(() => {\n          expect(bot).toHaveBeenCalledWith('Group me with the group', { body: singleMessageTemplate, env: {GROUPME_BOT_ID: 123123123} });\n        }).then(done, done.fail);\n      });\n      it('does not invoke the bot if the message cannot be parsed', (done) => {\n        parser.and.returnValue(false);\n        handler({body: singleMessageTemplate, env: {GROUPME_BOT_ID: 123123123}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(bot).not.toHaveBeenCalled();\n        }).then(done, done.fail);\n      });\n      it('responds when the bot resolves', (done) => {\n        parser.and.returnValue({sender: 123123, text: 'Test GroupMe'});\n        botResolve('Group me with the group');\n        handler({body: singleMessageTemplate, env: {GROUPME_BOT_ID: 123123123}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(responder).toHaveBeenCalledWith('Group me with the group', 123123123);\n        }).then(done, done.fail);\n      });\n      it('can work with bot responses as strings', (done) => {\n        bot.and.returnValue('Group me with the group');\n        parser.and.returnValue({sender: 'user1', text: 'Hello'});\n        handler({body: singleMessageTemplate, env: {GROUPME_BOT_ID: 123123123}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(responder).toHaveBeenCalledWith('Group me with the group', 123123123);\n        }).then(done, done.fail);\n\n      });\n      it('logs error when the bot rejects without responding', (done) => {\n        parser.and.returnValue('MSG1');\n\n        handler({body: singleMessageTemplate, env: {GROUPME_BOT_ID: 123123123}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(responder).not.toHaveBeenCalled();\n          expect(logError).toHaveBeenCalledWith('No No GroupMe');\n        }).then(done, done.fail);\n\n        botReject('No No GroupMe');\n      });\n      it('logs the error when the responder throws an error', (done) => {\n        parser.and.returnValue('MSG1');\n        responder.and.throwError('XXX');\n        botResolve('Yes');\n        handler({body: singleMessageTemplate, env: {GROUPME_BOT_ID: 123123123}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(logError).toHaveBeenCalledWith(jasmine.any(Error));\n        }).then(done, done.fail);\n      });\n      describe('working with promises in responders', () => {\n        var responderResolve, responderReject, responderPromise, hasResolved;\n        beforeEach(() => {\n          responderPromise = new Promise((resolve, reject) => {\n            responderResolve = resolve;\n            responderReject = reject;\n          });\n          responder.and.returnValue(responderPromise);\n\n          parser.and.returnValue('MSG1');\n        });\n        it('waits for the responders to resolve before completing the request', (done) => {\n          handler({body: singleMessageTemplate, env: {GROUPME_BOT_ID: 123123123}}).then(() => {\n            hasResolved = true;\n          });\n\n          botPromise.then(() => {\n            expect(hasResolved).toBeFalsy();\n          }).then(done, done.fail);\n\n          botResolve('YES');\n        });\n        it('resolves when the responder resolves', (done) => {\n          handler({body: singleMessageTemplate, env: {GROUPME_BOT_ID: 123123123}}).then((message) => {\n            expect(message).toEqual('ok');\n          }).then(done, done.fail);\n\n          botPromise.then(() => {\n            responderResolve('As Promised!');\n          });\n          botResolve('YES');\n        });\n        it('logs error when the responder rejects', (done) => {\n          handler({body: singleMessageTemplate, env: {GROUPME_BOT_ID: 123123123}}).then((message) => {\n            expect(message).toEqual('ok');\n            expect(logError).toHaveBeenCalledWith('Bomb!');\n          }).then(done, done.fail);\n\n          botPromise.then(() => {\n            responderReject('Bomb!');\n          });\n          botResolve('YES');\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/helpers/fake-https-request.js":"/*global beforeEach, afterEach */\nvar fake = require('fake-http-request');\nbeforeEach(() => {\n  fake.install('https');\n});\nafterEach(() => {\n  fake.uninstall('https');\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/kik/kik-parse-spec.js":"/*global describe, it, expect, require */\n'use strict';\nvar parse = require('../../lib/kik/parse');\n\ndescribe('Kik parse', () => {\n  it('returns nothing if the format is invalid', () => {\n    expect(parse('string')).toBeUndefined();\n    expect(parse()).toBeUndefined();\n    expect(parse(false)).toBeUndefined();\n    expect(parse(123)).toBeUndefined();\n    expect(parse({})).toBeUndefined();\n    expect(parse([1, 2, 3])).toBeUndefined();\n  });\n  it('returns false if the message chatId is missing', () => {\n    expect(parse({from: 'someUser', body: '2342342fwefwsdf', type: 'text'})).toBeUndefined();\n    expect(parse({body: undefined})).toBeUndefined();\n  });\n  it('returns a parsed object with proper chatId and kikType when the chatId is present and kikType is text', () => {\n    var msg = {from: 'firstUser', chatId: 123412312, body: 'Hello Kik', type: 'text'};\n    var contextId = '3sdfsdfsdf24';\n    expect(parse(msg, contextId)).toEqual({ sender: 'firstUser', text: 'Hello Kik', chatId: 123412312, kikType: 'text', originalRequest: msg, type: 'kik'});\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/kik/kik-reply-spec.js":"/*global describe, it, expect, require, jasmine */\n'use strict';\nvar reply = require('../../lib/kik/reply'),\n  https = require('https');\n\ndescribe('Kik Reply', () => {\n\n  it('includes the Kik Authorization and Content type application/json in the header', done => {\n    https.request.pipe(callOptions => {\n      var data = {messages: [{ body: 'hello Kik', to: 'randomKikUser', type: 'text', chatId: 123}]};\n      expect(callOptions).toEqual(jasmine.objectContaining({\n        method: 'POST',\n        hostname: 'api.kik.com',\n        path: '/v1/message',\n        headers: {\n          'Authorization': `Basic ${new Buffer('someRandomKikUsername' + ':' + 'RandomKikApiKey').toString('base64')}`,\n          'content-type': 'application/json'\n        },\n        body: JSON.stringify(data)\n      }));\n      done();\n    });\n    reply({sender: 'randomKikUser', kikType: 'text', chatId: 123},\n      {text: 'hello Kik'}, 'someRandomKikUsername', 'RandomKikApiKey');\n  });\n\n  it('sends messages as a string', done => {\n    https.request.pipe(callOptions => {\n      expect(callOptions.body).toEqual(JSON.stringify({\n        messages: [\n          {\n            body: 'hello Kik',\n            to: 'randomKikUser',\n            type: 'text',\n            chatId: 123\n          }\n        ]}));\n      done();\n    });\n    reply({sender: 'randomKikUser', kikType: 'text', chatId: 123},\n      'hello Kik', 'someRandomKikUsername', 'RandomKikApiKey');\n  });\n\n  it('does not resolve before the https endpoint responds', done => {\n    https.request.pipe(done);\n    reply({sender: 'randomKikUser', kikType: 'text', chatId: 123},\n      'hello Kik', 'someRandomKikUsername', 'RandomKikApiKey'\n    ).then(done.fail, done.fail);\n  });\n\n  it('resolves when the https endpoint responds with 200', done => {\n    https.request.pipe(() => {\n      setTimeout(() => {\n        https.request.calls[0].respond('200', 'OK', 'Hello Kik');\n      }, 10);\n    });\n    reply({sender: 'randomKikUser', kikType: 'text', chatId: 123},\n      'hello Kik', 'someRandomKikUsername', 'RandomKikApiKey').then(done, done.fail);\n  });\n\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/kik/kik-setup-spec.js":"/*global require, describe, it, expect, beforeEach, jasmine*/\n'use strict';\nvar underTest = require('../../lib/kik/setup');\ndescribe('Kik setup', () => {\n  var api, bot, logError, parser, responder, botPromise, botResolve, botReject;\n  beforeEach(() => {\n    api = jasmine.createSpyObj('api', ['get', 'post', 'addPostDeployStep']);\n    botPromise = new Promise((resolve, reject) => {\n      botResolve = resolve;\n      botReject = reject;\n    });\n    bot = jasmine.createSpy().and.returnValue(botPromise);\n    parser = jasmine.createSpy();\n    logError = jasmine.createSpy();\n    responder = jasmine.createSpy();\n    underTest(api, bot, logError, parser, responder);\n  });\n  describe('message processor', () => {\n    const singleMessageTemplate = {\n      messages: [\n        {\n          from: 'randomKikUser',\n          body: 'hello Kik',\n          chatId: 123,\n          type: 'test'\n        }\n      ]\n    };\n    it('wires the POST request for kik to the message processor', () => {\n      expect(api.post.calls.count()).toEqual(1);\n      expect(api.post).toHaveBeenCalledWith('/kik', jasmine.any(Function));\n    });\n    describe('processing a single message', () => {\n      var handler;\n      beforeEach(() => {\n        handler = api.post.calls.argsFor(0)[1];\n      });\n      it('breaks down the message and puts it into the parser', () => {\n        handler({body: singleMessageTemplate, env: {kikUserName: 'randomKikUserName', kikApiKey: 'RandomAPIKey'}});\n        expect(parser).toHaveBeenCalledWith({\n          from: 'randomKikUser',\n          body: 'hello Kik',\n          chatId: 123,\n          type: 'test'\n        });\n      });\n      it('passes the parsed value to the bot if a message can be parsed', (done) => {\n        parser.and.returnValue('MSG1');\n        handler({body: singleMessageTemplate, env: {}});\n        Promise.resolve().then(() => {\n          expect(bot).toHaveBeenCalledWith('MSG1', { body: singleMessageTemplate, env: {} });\n        }).then(done, done.fail);\n      });\n      it('does not invoke the bot if the message cannot be parsed', (done) => {\n        parser.and.returnValue(false);\n        handler({body: singleMessageTemplate, env: {}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(bot).not.toHaveBeenCalled();\n        }).then(done, done.fail);\n      });\n      it('responds when the bot resolves', (done) => {\n        parser.and.returnValue({sender: 'user1', text: 'MSG1'});\n        botResolve('Kik Kik the bucket');\n        handler({body: singleMessageTemplate, env: {kikUserName: 'randomKikUserName', kikApiKey: 'RandomAPIKey'}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(responder).toHaveBeenCalledWith({sender: 'user1', text: 'MSG1'}, 'Kik Kik the bucket', 'randomKikUserName', 'RandomAPIKey');\n        }).then(done, done.fail);\n      });\n      it('can work with bot responses as strings', (done) => {\n        bot.and.returnValue('Kik the bucket');\n        parser.and.returnValue({sender: 'user1', text: 'Hello'});\n        handler({body: singleMessageTemplate, env: {kikUserName: 'randomKikUserName', kikApiKey: 'RandomAPIKey'}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(responder).toHaveBeenCalledWith({sender: 'user1', text: 'Hello'}, 'Kik the bucket', 'randomKikUserName', 'RandomAPIKey');\n        }).then(done, done.fail);\n\n      });\n      it('logs error when the bot rejects without responding', (done) => {\n        parser.and.returnValue('MSG1');\n\n        handler({body: singleMessageTemplate, env: {}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(responder).not.toHaveBeenCalled();\n          expect(logError).toHaveBeenCalledWith('No No');\n        }).then(done, done.fail);\n\n        botReject('No No');\n      });\n      it('logs the error when the responder throws an error', (done) => {\n        parser.and.returnValue('MSG1');\n        responder.and.throwError('XXX');\n        botResolve('Yes');\n        handler({body: singleMessageTemplate, env: {kikUserName: 'randomKikUserName', kikApiKey: 'RandomAPIKey'}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(logError).toHaveBeenCalledWith(jasmine.any(Error));\n        }).then(done, done.fail);\n      });\n      describe('working with promises in responders', () => {\n        var responderResolve, responderReject, responderPromise, hasResolved;\n        beforeEach(() => {\n          responderPromise = new Promise((resolve, reject) => {\n            responderResolve = resolve;\n            responderReject = reject;\n          });\n          responder.and.returnValue(responderPromise);\n\n          parser.and.returnValue('MSG1');\n        });\n        it('waits for the responders to resolve before completing the request', (done) => {\n          handler({body: singleMessageTemplate, env: {kikUserName: 'randomKikUserName', kikApiKey: 'RandomAPIKey'}}).then(() => {\n            hasResolved = true;\n          });\n\n          botPromise.then(() => {\n            expect(hasResolved).toBeFalsy();\n          }).then(done, done.fail);\n\n          botResolve('YES');\n        });\n        it('resolves when the responder resolves', (done) => {\n          handler({body: singleMessageTemplate, env: {kikUserName: 'randomKikUserName', kikApiKey: 'RandomAPIKey'}}).then((message) => {\n            expect(message).toEqual('ok');\n          }).then(done, done.fail);\n\n          botPromise.then(() => {\n            responderResolve('As Promised!');\n          });\n          botResolve('YES');\n        });\n        it('logs error when the responder rejects', (done) => {\n          handler({body: singleMessageTemplate, env: {kikUserName: 'randomKikUserName', kikApiKey: 'RandomAPIKey'}}).then((message) => {\n            expect(message).toEqual('ok');\n            expect(logError).toHaveBeenCalledWith('Bomb!');\n          }).then(done, done.fail);\n\n          botPromise.then(() => {\n            responderReject('Bomb!');\n          });\n          botResolve('YES');\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/line/line-parse-spec.js":"/*global describe, it, expect, require */\n'use strict';\nconst parse = require('../../lib/line/parse');\n\ndescribe('LINE parse', () => {\n  it('returns nothing if the format is invalid', () => {\n    expect(parse('string')).toBeUndefined();\n    expect(parse()).toBeUndefined();\n    expect(parse(false)).toBeUndefined();\n    expect(parse(123)).toBeUndefined();\n    expect(parse({})).toBeUndefined();\n    expect(parse([1, 2, 3])).toBeUndefined();\n  });\n  it('returns nothing if the message type or source with userId is missing', () => {\n    expect(parse({replyToken: 'someRandomToken', source: { userId: 'ola Line'}, message: {text: 'hello'}})).toBeUndefined();\n    expect(parse({type: 'message', replyToken: 'someRandomToken', source: {}, message: {text: 'hello'}})).toBeUndefined();\n  });\n  it('returns a parsed object with replyToken and type line when the replyToken is present and source and source user.id is text', () => {\n    let msg = {type: 'message', replyToken: 'someRandomToken', source: { userId: 'ola Line'}, message: {text: 'hello'}};\n    expect(parse(msg)).toEqual({ sender: 'ola Line', replyToken: 'someRandomToken', text: 'hello', originalRequest: msg, type: 'line'});\n  });\n});","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/line/line-reply-spec.js":"/*global describe, it, expect, require, jasmine */\n'use strict';\nconst reply = require('../../lib/line/reply'),\n  https = require('https');\n\ndescribe('Line Reply', () => {\n\n  it('includes the Line Authorization and Content type application/json in the header', done => {\n    https.request.pipe(callOptions => {\n      let lineChannelAccessToken = 'LineRandomAccessToken';\n      let data = {replyToken: 'randomLineToken', messages: [{type: 'message', text: 'hello Line'}]};\n      expect(callOptions).toEqual(jasmine.objectContaining({\n        method: 'POST',\n        hostname: 'api.line.me',\n        path: '/v2/bot/message/reply',\n        headers: {\n          'Authorization': `Bearer ${lineChannelAccessToken}`,\n          'Content-Type': 'application/json; charset=utf-8',\n          'Content-Length': Buffer.byteLength(JSON.stringify(data), 'utf8')\n        },\n        body: JSON.stringify(data)\n      }));\n      done();\n    });\n    reply('randomLineToken', {type: 'message', text: 'hello Line'}, 'LineRandomAccessToken');\n  });\n\n  it('sends messages as a string', done => {\n    https.request.pipe(callOptions => {\n      expect(callOptions.body).toEqual(JSON.stringify({\n        replyToken: 'randomLineToken',\n        messages: [\n          {\n            type: 'message',\n            text: 'hello Line'\n          }\n        ]}));\n      done();\n    });\n    reply('randomLineToken', {type: 'message', text: 'hello Line'}, 'LineRandomAccessToken');\n  });\n\n  it('does not resolve before the https endpoint responds', done => {\n    https.request.pipe(done);\n    reply('randomLineToken', {type: 'message', text: 'hello Line'}, 'LineRandomAccessToken')\n      .then(done.fail, done.fail);\n  });\n\n  it('resolves when the https endpoint responds with 200', done => {\n    https.request.pipe(() => {\n      setTimeout(() => {\n        https.request.calls[0].respond('200', 'OK', 'hello Line');\n      }, 10);\n    });\n    reply('randomLineToken', {type: 'message', text: 'hello Line'}, 'LineRandomAccessToken').then(done, done.fail);\n  });\n\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/line/line-setup-spec.js":"/*global require, describe, it, expect, beforeEach, jasmine*/\n'use strict';\nvar underTest = require('../../lib/line/setup');\ndescribe('Line setup', () => {\n  var api, bot, logError, parser, responder, botPromise, botResolve, botReject;\n  beforeEach(() => {\n    api = jasmine.createSpyObj('api', ['get', 'post', 'addPostDeployStep']);\n    botPromise = new Promise((resolve, reject) => {\n      botResolve = resolve;\n      botReject = reject;\n    });\n    bot = jasmine.createSpy().and.returnValue(botPromise);\n    parser = jasmine.createSpy();\n    logError = jasmine.createSpy();\n    responder = jasmine.createSpy();\n    underTest(api, bot, logError, parser, responder);\n  });\n  describe('message processor', () => {\n    const singleMessageTemplate = {\n      'events':[{\n        'replyToken': 'RandomLineReplyToken',\n        'type': 'message',\n        'source':{\n          'type': 'user',\n          'userId': 'someUserId'\n        },\n        'message': {\n          'id': '123',\n          'type': 'text',\n          'text': 'Hello Line'\n        }\n      }]\n    };\n    it('wires the POST request for line to the message processor', () => {\n      expect(api.post.calls.count()).toEqual(1);\n      expect(api.post).toHaveBeenCalledWith('/line', jasmine.any(Function));\n    });\n    describe('processing a single message', () => {\n      var handler;\n      beforeEach(() => {\n        handler = api.post.calls.argsFor(0)[1];\n      });\n      it('breaks down the message and puts it into the parser', () => {\n        handler({body: singleMessageTemplate, env: {lineChannelAccessToken: 'ABC'}});\n        expect(parser.calls.argsFor(0)[0]).toEqual({\n          'replyToken': 'RandomLineReplyToken', 'type': 'message',\n          'source':{'type': 'user', 'userId': 'someUserId'},\n          'message': {'id': '123', 'type': 'text', 'text': 'Hello Line'}\n        });\n      });\n      it('passes the parsed value to the bot if a message can be parsed', (done) => {\n        parser.and.returnValue({replyToken: 'RandomLineReplyToken'});\n        handler({body: singleMessageTemplate, env: {}});\n        Promise.resolve().then(() => {\n          expect(bot).toHaveBeenCalledWith({replyToken: 'RandomLineReplyToken'}, { body: singleMessageTemplate, env: {} });\n        }).then(done, done.fail);\n      });\n      it('does not invoke the bot if the message cannot be parsed', (done) => {\n        parser.and.returnValue(false);\n        handler({body: singleMessageTemplate, env: {}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(bot).not.toHaveBeenCalled();\n        }).then(done, done.fail);\n      });\n      it('responds when the bot resolves', (done) => {\n        parser.and.returnValue({replyToken: 'randomToken', text: 'MSG1'});\n        botResolve('Yes Yes');\n        handler({body: singleMessageTemplate, env: {lineChannelAccessToken: new Buffer('ABC').toString('base64')}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(responder).toHaveBeenCalledWith('randomToken', 'Yes Yes', 'ABC');\n        }).then(done, done.fail);\n      });\n      it('can work with bot responses as strings', (done) => {\n        bot.and.returnValue('Yes!');\n        parser.and.returnValue({replyToken: 'randomToken', text: 'MSG1'});\n        handler({body: singleMessageTemplate, env: {lineChannelAccessToken: new Buffer('ABC').toString('base64')}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(responder).toHaveBeenCalledWith('randomToken', 'Yes!', 'ABC');\n        }).then(done, done.fail);\n\n      });\n      it('logs error when the bot rejects without responding', (done) => {\n        parser.and.returnValue('MSG1');\n\n        handler({body: singleMessageTemplate, env: {}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(responder).not.toHaveBeenCalled();\n          expect(logError).toHaveBeenCalledWith('No No');\n        }).then(done, done.fail);\n\n        botReject('No No');\n      });\n      it('logs the error when the responder throws an error', (done) => {\n        parser.and.returnValue('MSG1');\n        responder.and.throwError('XXX');\n        botResolve('Yes');\n        handler({body: singleMessageTemplate, env: {lineChannelAccessToken: new Buffer('ABC').toString('base64')}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(logError).toHaveBeenCalledWith(jasmine.any(Error));\n        }).then(done, done.fail);\n      });\n      describe('working with promises in responders', () => {\n        var responderResolve, responderReject, responderPromise, hasResolved;\n        beforeEach(() => {\n          responderPromise = new Promise((resolve, reject) => {\n            responderResolve = resolve;\n            responderReject = reject;\n          });\n          responder.and.returnValue(responderPromise);\n\n          parser.and.returnValue('MSG1');\n        });\n        it('waits for the responders to resolve before completing the request', (done) => {\n          handler({body: singleMessageTemplate, env: {lineChannelAccessToken: 'ABC'}}).then(() => {\n            hasResolved = true;\n          });\n\n          botPromise.then(() => {\n            expect(hasResolved).toBeFalsy();\n          }).then(done, done.fail);\n\n          botResolve('YES');\n        });\n        it('resolves when the responder resolves', (done) => {\n          handler({body: singleMessageTemplate, env: {lineChannelAccessToken: 'ABC'}}).then((message) => {\n            expect(message).toEqual('ok');\n          }).then(done, done.fail);\n\n          botPromise.then(() => {\n            responderResolve('As Promised!');\n          });\n          botResolve('YES');\n        });\n        it('logs error when the responder rejects', (done) => {\n          handler({body: singleMessageTemplate, env: {lineChannelAccessToken: 'ABC'}}).then((message) => {\n            expect(message).toEqual('ok');\n            expect(logError).toHaveBeenCalledWith('Bomb!');\n          }).then(done, done.fail);\n\n          botPromise.then(() => {\n            responderReject('Bomb!');\n          });\n          botResolve('YES');\n        });\n      });\n    });\n    describe('multiple messages', () => {\n      const multiMessageTemplate = {\n        'events': [\n          {\n            'replyToken': 'RandomLineReplyToken',\n            'type': 'message',\n            'source': {\n              'type': 'user',\n              'userId': 'someUserId'\n            },\n            'message': {\n              'id': '123',\n              'type': 'text',\n              'text': 'Hello Line'\n            }\n          },\n          {\n            'replyToken': 'RandomLineReplyToken',\n            'type': 'message',\n            'source': {\n              'type': 'user',\n              'userId': 'otherUserId'\n            },\n            'message': {\n              'id': '456',\n              'type': 'text',\n              'text': 'Bye Line'\n            }\n          }\n        ]\n      };\n      var botPromises,\n        responderPromises,\n        handler,\n        buildPromiseFor = (array) => {\n          var pResolve, pReject, promise;\n          promise = new Promise((resolve, reject) => {\n            pResolve = resolve;\n            pReject = reject;\n          });\n          promise.resolve = pResolve;\n          promise.reject = pReject;\n          array.push(promise);\n          return promise;\n        };\n\n      beforeEach(() => {\n        var index = 0;\n        botPromises = [];\n        responderPromises = [];\n        bot.and.callFake(() => {\n          return buildPromiseFor(botPromises);\n        });\n        responder.and.callFake(() => {\n          return buildPromiseFor(responderPromises);\n        });\n        handler = api.post.calls.argsFor(0)[1];\n        parser.and.callFake(() => {\n          index += 1;\n          return {\n            sender: 'sender' + index,\n            text: 'text' + index,\n            replyToken: 'RandomLineReplyToken',\n            type: 'line'\n          };\n        });\n      });\n      it('parses messages in sequence', () => {\n        handler({body: multiMessageTemplate, env: {lineChannelAccessToken: 'ABC'}});\n        expect(parser.calls.count()).toBe(2);\n        expect(parser.calls.argsFor(0)[0]).toEqual({\n          'replyToken': 'RandomLineReplyToken',\n          'type': 'message',\n          'source':{\n            'type': 'user',\n            'userId': 'someUserId'\n          },\n          'message': {\n            'id': '123',\n            'type': 'text',\n            'text': 'Hello Line'\n          }\n        });\n        expect(parser.calls.argsFor(1)[0]).toEqual({\n          'replyToken': 'RandomLineReplyToken',\n          'type': 'message',\n          'source':{\n            'type': 'user',\n            'userId': 'otherUserId'\n          },\n          'message': {\n            'id': '456',\n            'type': 'text',\n            'text': 'Bye Line'\n          }\n        });\n      });\n      it('calls the bot for each message individually', (done) => {\n        handler({body: multiMessageTemplate, env: {lineChannelAccessToken: 'ABC'}});\n        Promise.resolve().then(() => {\n          expect(bot.calls.count()).toEqual(2);\n          expect(bot).toHaveBeenCalledWith({sender: 'sender1', text: 'text1', replyToken: 'RandomLineReplyToken', type: 'line'}, {body: multiMessageTemplate, env: {lineChannelAccessToken: 'ABC'}});\n          expect(bot).toHaveBeenCalledWith({sender: 'sender2', text: 'text2', replyToken: 'RandomLineReplyToken', type: 'line'}, {body: multiMessageTemplate, env: {lineChannelAccessToken: 'ABC'}});\n        }).then(done, done.fail);\n      });\n      it('calls the responders for each bot response individually', (done) => {\n        handler({body: multiMessageTemplate, env: {lineChannelAccessToken: new Buffer('ABC').toString('base64')}});\n        Promise.resolve().then(() => {\n          botPromises[0].resolve('From first');\n          botPromises[1].resolve('From second');\n          return botPromises[1];\n        }).then(() => {\n          expect(responder).toHaveBeenCalledWith('RandomLineReplyToken', 'From first', 'ABC');\n          expect(responder).toHaveBeenCalledWith('RandomLineReplyToken', 'From second', 'ABC');\n        }).then(done, done.fail);\n      });\n      it('does not resolve until all the responders resolve', (done) => {\n        var hasResolved;\n        handler({body: multiMessageTemplate, env: {lineChannelAccessToken: 'ABC'}}).then(() => {\n          hasResolved = true;\n        }).then(done.fail, done.fail);\n        Promise.resolve().then(() => {\n          botPromises.forEach((p) => p.resolve('group'));\n          return botPromises.pop();\n        }).then(() => {\n          responderPromises.slice(1).forEach((p) => p.resolve('result'));\n          return responderPromises.pop();\n        }).then(() => {\n          expect(hasResolved).toBeFalsy();\n        }).then(done, done.fail);\n      });\n      it('resolves when all the responders resolve', (done) => {\n        handler({body: multiMessageTemplate, env: {lineChannelAccessToken: 'ABC'}}).then((message) => {\n          expect(message).toEqual('ok');\n        }).then(done, done.fail);\n        Promise.resolve().then(() => {\n          botPromises.forEach((p) => p.resolve('group'));\n          return botPromises.pop();\n        }).then(() => {\n          responderPromises.forEach((p) => p.resolve('result'));\n          return responderPromises.pop();\n        });\n      });\n    });\n\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/skype/skype-format-message-spec.js":"/*global describe, it, expect, require */\n'use strict';\n\nconst formatMessage = require('../../lib/skype/format-message');\n\ndescribe('Skype format message', () => {\n  it('should export an object', () => {\n    expect(typeof formatMessage).toBe('object');\n  });\n\n  describe('Photo', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.Photo('foo');\n      expect(typeof formatMessage.Photo).toBe('function');\n      expect(message instanceof formatMessage.Photo).toBeTruthy();\n    });\n\n    it('should throw an error if photo url is not provided', () => {\n      expect(() => new formatMessage.Photo()).toThrowError('Photo is required for the Skype Photo template');\n    });\n\n    it('should generate a valid Skype template object', () => {\n      const message = new formatMessage.Photo('base_64_string').get();\n      expect(message).toEqual({\n        type: 'message/image',\n        attachments: [\n          {\n            contentUrl: 'base_64_string'\n          }\n        ]\n      });\n    });\n  });\n\n  describe('Carousel', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.Photo('foo');\n      expect(typeof formatMessage.Photo).toBe('function');\n      expect(message instanceof formatMessage.Photo).toBeTruthy();\n    });\n\n    it('should generate a valid Carousel template object', () => {\n      const message = new formatMessage.Carousel('summary', 'text').get();\n      expect(message).toEqual({\n        type: 'message/card.carousel',\n        attachmentLayout: 'carousel',\n        summary: 'summary',\n        text: 'text',\n        attachments: []\n      });\n    });\n\n    it('should throw error if addHero is called without images array', () => {\n      expect(() => new formatMessage.Carousel('summary', 'text')\n        .addHero('image')\n        .get()).toThrowError('Images should be sent as array for the Skype Hero template');\n    });\n\n    it('should generate a valid Carousel template object with Hero', () => {\n      const message = new formatMessage.Carousel('summary', 'text')\n        .addHero(['image'])\n          .addTitle('title')\n          .addSubtitle('subtitle')\n          .addText('text')\n        .get();\n      expect(message).toEqual({\n        type: 'message/card.carousel',\n        attachmentLayout: 'carousel',\n        summary: 'summary',\n        text: 'text',\n        attachments: [{\n          contentType: 'application/vnd.microsoft.card.hero',\n          content: {\n            title: 'title',\n            subtitle: 'subtitle',\n            text: 'text',\n            images: [{url: 'image', alt: ''}],\n            buttons: []\n          }\n        }]\n      });\n    });\n\n    it('should throw error if addButton is called without attachment', () => {\n      expect(() => new formatMessage.Carousel('summary', 'text')\n        .addButton('title', 'test', 'imBack')\n        .get()).toThrowError('You need to add attachment to Carousel');\n    });\n\n    it('should throw error if addButton is called without title', () => {\n      expect(() => new formatMessage.Carousel('summary', 'text')\n        .addHero()\n        .addButton()\n        .get()).toThrowError('Title needs to be a string for Skype addButton method');\n    });\n\n    it('should throw error if addButton is called without value', () => {\n      expect(() => new formatMessage.Carousel('summary', 'text')\n        .addHero()\n        .addButton('title', '', 'imBack')\n        .get()).toThrowError('Value needs to be a string for Skype addButton method');\n    });\n\n    it('should throw error if addButton is called without type', () => {\n      expect(() => new formatMessage.Carousel('summary', 'text')\n        .addHero()\n        .addButton('title', 'value')\n        .get()).toThrowError('Type needs to be a string for Skype addButton method');\n    });\n\n    it('should throw error if addButton is called with strange type', () => {\n      expect(() => new formatMessage.Carousel('summary', 'text')\n        .addHero()\n        .addButton('title', 'value', 'someType')\n        .get()).toThrowError('Type needs to be a valid type string for Skype addButton method');\n    });\n\n    it('should generate a valid Carousel template object with Hero with Button', () => {\n      const message = new formatMessage.Carousel('summary', 'text')\n        .addHero()\n          .addButton('title', 'value', 'imBack')\n        .get();\n      expect(message).toEqual({\n        type: 'message/card.carousel',\n        attachmentLayout: 'carousel',\n        summary: 'summary',\n        text: 'text',\n        attachments: [{\n          contentType: 'application/vnd.microsoft.card.hero',\n          content: {\n            title: '',\n            subtitle: '',\n            text: '',\n            images: [],\n            buttons: [{\n              type: 'imBack',\n              title: 'title',\n              value: 'value'\n            }]\n          }\n        }]\n      });\n    });\n\n    it('should throw error if addThumbnail is called without images array', () => {\n      expect(() => new formatMessage.Carousel('summary', 'text')\n        .addThumbnail('title', 'subtitle', 'text', 'image')\n        .get()).toThrowError('Images should be sent as array for the Skype Thumbnail template');\n    });\n\n    it('should generate a valid Carousel template object with Thumbnail', () => {\n      const message = new formatMessage.Carousel('summary', 'text')\n        .addThumbnail(['image'])\n          .addTitle('title')\n          .addSubtitle('subtitle')\n          .addText('text')\n        .get();\n      expect(message).toEqual({\n        type: 'message/card.carousel',\n        attachmentLayout: 'carousel',\n        summary: 'summary',\n        text: 'text',\n        attachments: [{\n          contentType: 'application/vnd.microsoft.card.thumbnail',\n          content: {\n            title: 'title',\n            subtitle: 'subtitle',\n            text: 'text',\n            images: [{url: 'image', alt: ''}],\n            buttons: []\n          }\n        }]\n      });\n    });\n\n    it('should generate a valid Carousel template object with Receipt', () => {\n      const message = new formatMessage.Carousel('summary', 'text')\n        .addReceipt('total', 'tax', 'vat')\n          .addTitle('title')\n          .addSubtitle('subtitle')\n          .addText('text')\n        .get();\n      expect(message).toEqual({\n        type: 'message/card.carousel',\n        attachmentLayout: 'carousel',\n        summary: 'summary',\n        text: 'text',\n        attachments: [{\n          contentType: 'application/vnd.microsoft.card.receipt',\n          content: {\n            title: 'title',\n            subtitle: 'subtitle',\n            text: 'text',\n            total: 'total',\n            tax: 'tax',\n            vat: 'vat',\n            items: [],\n            facts: [],\n            buttons: []\n          }\n        }]\n      });\n    });\n\n    it('should generate a valid Carousel template object with Receipt with Item', () => {\n      const message = new formatMessage.Carousel('summary', 'text')\n        .addReceipt('total', 'tax', 'vat')\n          .addTitle('title')\n          .addSubtitle('subtitle')\n          .addText('text')\n            .addItem('title', 'subtitle', 'text', 'price', 'quantity', 'image')\n        .get();\n      expect(message).toEqual({\n        type: 'message/card.carousel',\n        attachmentLayout: 'carousel',\n        summary: 'summary',\n        text: 'text',\n        attachments: [{\n          contentType: 'application/vnd.microsoft.card.receipt',\n          content: {\n            title: 'title',\n            subtitle: 'subtitle',\n            text: 'text',\n            total: 'total',\n            tax: 'tax',\n            vat: 'vat',\n            items: [{\n              title: 'title',\n              subtitle: 'subtitle',\n              text: 'text',\n              price: 'price',\n              quantity: 'quantity',\n              image: {\n                url: 'image'\n              }\n            }],\n            facts: [],\n            buttons: []\n          }\n        }]\n      });\n    });\n\n    it('should generate a valid Carousel template object with Receipt with Fact', () => {\n      const message = new formatMessage.Carousel('summary', 'text')\n        .addReceipt('total', 'tax', 'vat')\n          .addTitle('title')\n          .addSubtitle('subtitle')\n          .addText('text')\n            .addFact('key', 'value')\n        .get();\n      expect(message).toEqual({\n        type: 'message/card.carousel',\n        attachmentLayout: 'carousel',\n        summary: 'summary',\n        text: 'text',\n        attachments: [{\n          contentType: 'application/vnd.microsoft.card.receipt',\n          content: {\n            title: 'title',\n            subtitle: 'subtitle',\n            text: 'text',\n            total: 'total',\n            tax: 'tax',\n            vat: 'vat',\n            items: [],\n            facts: [{\n              key: 'key',\n              value: 'value'\n            }],\n            buttons: []\n          }\n        }]\n      });\n    });\n\n    it('should throw error if addTitle is called without title', () => {\n      expect(() => new formatMessage.Carousel('summary', 'text')\n        .addHero()\n          .addTitle()\n        .get()).toThrowError('Title needs to be a string for Skype addTitle method');\n    });\n\n    it('should throw error if addSubtitle is called without subtitle', () => {\n      expect(() => new formatMessage.Carousel('summary', 'text')\n        .addHero()\n        .addSubtitle()\n        .get()).toThrowError('Subtitle needs to be a string for Skype addSubtitle method');\n    });\n\n    it('should throw error if addText is called without text', () => {\n      expect(() => new formatMessage.Carousel('summary', 'text')\n        .addHero()\n        .addText()\n        .get()).toThrowError('Text needs to be a string for Skype addText method');\n    });\n\n    it('should generate a valid Typing template object', () => {\n      const message = new formatMessage.Typing();\n      expect(message).toEqual({\n        type: 'typing'\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/skype/skype-parse-spec.js":"/*global describe, it, expect, require */\n'use strict';\nvar parse = require('../../lib/skype/parse');\n\ndescribe('Skype parse', () => {\n  it('returns nothing if the format is invalid', () => {\n    var contextId = '3sdfsdfsdf24';\n    expect(parse('string', contextId)).toBeUndefined();\n    expect(parse()).toBeUndefined();\n    expect(parse(false, contextId)).toBeUndefined();\n    expect(parse(123, contextId)).toBeUndefined();\n    expect(parse({}, contextId)).toBeUndefined();\n    expect(parse([1, 2, 3], contextId)).toBeUndefined();\n  });\n  it('returns false if the message content is missing', () => {\n    expect(parse({from: {id: 111}, contextId: '2342342fwefwsdf'})).toBeUndefined();\n    expect(parse({text: undefined})).toBeUndefined();\n  });\n  it('returns a parsed object with proper contextId when the text is present and contextId is present', () => {\n    var msg = {text:'Bonjour Skype', conversation: {id: 123412312}, id: 324234234};\n    var contextId = '3sdfsdfsdf24';\n    expect(parse(msg, contextId)).toEqual({ sender: 123412312, text: 'Bonjour Skype', originalRequest: msg, contextId: '3sdfsdfsdf24', type: 'skype'});\n  });\n  it('returns a parsed object with undefined contextId when the content is present and contextId is not', () => {\n    var msg = {text:'Bonjour Skype', conversation: {id: 123412312}, id: 324234234};\n    expect(parse(msg)).toEqual({ sender: 123412312, text: 'Bonjour Skype', originalRequest: msg, contextId: undefined, type: 'skype'});\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/skype/skype-token-spec.js":"/*global describe, it, expect, require, jasmine */\n'use strict';\nvar token = require('../../lib/skype/token'),\n  https = require('https'),\n  qs = require('querystring');\n\ndescribe('Skype Token', () => {\n\n  describe('getting the access token makes a request if the token is undefined', () => {\n    it('includes the Skype AppId and Skype App Secret in the request body with the proper content length', done => {\n      var credentialsData = qs.encode({\n        grant_type: 'client_credentials',\n        client_id: 'someSkypeAppId123',\n        client_secret: 'someSkypePrivateKey123',\n        scope: 'https://api.botframework.com/.default'\n      });\n      \n      https.request.pipe(callOptions => {\n        expect(callOptions).toEqual(jasmine.objectContaining({\n          method: 'POST',\n          hostname: 'login.microsoftonline.com',\n          path: '/botframework.com/oauth2/v2.0/token',\n          headers: {\n            'cache-control': 'no-cache',\n            'content-type': 'application/x-www-form-urlencoded',\n            'content-length': Buffer.byteLength(credentialsData)\n          },\n          body: credentialsData\n        }));\n        \n        done();\n      });\n      token.getToken('someSkypeAppId123', 'someSkypePrivateKey123');\n    });\n\n    it('does not resolve before the https endpoint responds', done => {\n      https.request.pipe(done);\n      token.getToken('someSkypeAppId123', 'someSkypePrivateKey123').then(done.fail, done.fail);\n    });\n\n    it('resolves when the https endpoint responds with 200', done => {\n      https.request.pipe(() => {\n        setTimeout(() => {\n          https.request.calls[0].respond('200', 'OK', '{\"access_token\":\"someAccessToken123\"}');\n        }, 10);\n      });\n      token.getToken('someSkypeAppId123', 'someSkypePrivateKey123').then(done, done.fail);\n    });\n  });\n\n});","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/slack/slack-delayed-reply-spec.js":"/*global jasmine, describe, it, expect */\n'use strict';\n\nconst slackDelayedReply = require('../../lib/slack/delayed-reply');\nconst https = require('https');\n\ndescribe('Slack delayed reply', () => {\n  it('should throw an error if message or response are not specified', () => {\n    expect(() => slackDelayedReply()).toThrowError('Original bot request and response are required');\n  });\n\n  it('should send a text message', done => {\n    https.request.pipe(callOptions => {\n      expect(callOptions).toEqual(jasmine.objectContaining({\n        method: 'POST',\n        hostname: 'some.fake',\n        path: '/url',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          text: 'Hello'\n        })\n      }));\n      done();\n    });\n    slackDelayedReply({\n      originalRequest: {\n        response_url: 'https://some.fake/url'\n      }\n    }, 'Hello');\n  });\n\n  it('should send an object', done => {\n    https.request.pipe(callOptions => {\n      expect(callOptions).toEqual(jasmine.objectContaining({\n        method: 'POST',\n        hostname: 'some.fake',\n        path: '/url',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({ attachment: {} })\n      }));\n      done();\n    });\n    slackDelayedReply({\n      originalRequest: {\n        response_url: 'https://some.fake/url'\n      }\n    }, { attachment: {} });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/slack/slack-format-message-spec.js":"/*global describe, it, expect */\n'use strict';\n\nconst formatSlackMessage = require('../../lib/slack/format-message');\n\ndescribe('Slack format message', () => {\n  it('should export a function', () => {\n    expect(typeof formatSlackMessage).toBe('function');\n  });\n\n  describe('Template builder', () => {\n    it('should be a class', () => {\n      let template = new formatSlackMessage('test');\n      expect(typeof formatSlackMessage).toBe('function');\n      expect(template instanceof formatSlackMessage).toBeTruthy();\n    });\n\n    it('should not add text if you don\\'t provide it in the constructor', () => {\n      let message = new formatSlackMessage();\n      expect(message.template.text).toBeFalsy();\n    });\n\n    it('should add text if you provide it in the constructor', () => {\n      let message = new formatSlackMessage('Message text');\n      expect(message.template.text).toBe('Message text');\n    });\n\n    it('should add replace_original to the template if you use replaceOriginal method', () => {\n      let message = new formatSlackMessage().replaceOriginal(true);\n      expect(message.template.replace_original).toBeTruthy();\n    });\n\n    it('should enable markdown by default', () => {\n      let message = new formatSlackMessage();\n      expect(message.template.mrkdwn).toBeTruthy();\n    });\n\n    it('should disable markdown if you use disableMarkdown method', () => {\n      let message = new formatSlackMessage().disableMarkdown(true);\n      expect(message.template.mrkdwn).toBeFalsy();\n    });\n\n    it('should set message type to `in_channel` if you use channelMessage method', () => {\n      let message = new formatSlackMessage().channelMessage(true);\n      expect(message.template.response_type).toBe('in_channel');\n    });\n\n    it('should throw an error if you use getLatestAttachment without adding an attachment', () => {\n      let message = new formatSlackMessage();\n      expect(() => message.getLatestAttachment()).toThrowError('Add at least one attachment first');\n    });\n\n    it('should add an attachment with default fallback when you use addAttachment method', () => {\n      let message = new formatSlackMessage().addAttachment();\n      expect(message.template.attachments.length).toBe(1);\n      expect(message.template.attachments[0].fallback).toBe('Slack told us that you are not able to see this attachment 😢');\n    });\n\n    it('should add an attachment with custom fallback and callback id if they are provided', () => {\n      let message = new formatSlackMessage().addAttachment('CB', 'Fallback');\n      expect(message.template.attachments.length).toBe(1);\n      expect(message.template.attachments[0].callback_id).toBe('CB');\n      expect(message.template.attachments[0].fallback).toBe('Fallback');\n    });\n\n    it('should add 20 attachments', () => {\n      let message = new formatSlackMessage()\n        .addAttachment().addAttachment().addAttachment().addAttachment().addAttachment()\n        .addAttachment().addAttachment().addAttachment().addAttachment().addAttachment()\n        .addAttachment().addAttachment().addAttachment().addAttachment().addAttachment()\n        .addAttachment().addAttachment().addAttachment().addAttachment().addAttachment();\n\n      expect(message.template.attachments.length).toBe(20);\n    });\n\n    it('should throw an error if you add more than 20 attachments', () => {\n      let message = new formatSlackMessage()\n        .addAttachment().addAttachment().addAttachment().addAttachment().addAttachment()\n        .addAttachment().addAttachment().addAttachment().addAttachment().addAttachment()\n        .addAttachment().addAttachment().addAttachment().addAttachment().addAttachment()\n        .addAttachment().addAttachment().addAttachment().addAttachment().addAttachment();\n\n      expect(() => message.addAttachment()).toThrowError('You can not add more than 20 attachments');\n    });\n\n    it('should throw an error if you use addTitle without adding a title', () => {\n      let message = new formatSlackMessage().addAttachment();\n      expect(() => message.addTitle()).toThrowError('Title text is required for addTitle method');\n    });\n\n    it('should add a title for the attachment if you use addTitle method', () => {\n      let message = new formatSlackMessage().addAttachment().addTitle('This is a title');\n      expect(message.template.attachments[0].title).toBe('This is a title');\n    });\n\n    it('should throw an error if you use addText without adding a text', () => {\n      let message = new formatSlackMessage().addAttachment();\n      expect(() => message.addText()).toThrowError('Text is required for addText method');\n    });\n\n    it('should add a text for the attachment if you use addText method', () => {\n      let message = new formatSlackMessage().addAttachment().addText('text');\n      expect(message.template.attachments[0].text).toBe('text');\n    });\n\n    it('should throw an error if you use addPretext without adding a text', () => {\n      let message = new formatSlackMessage().addAttachment();\n      expect(() => message.addPretext()).toThrowError('Text is required for addPretext method');\n    });\n\n    it('should add a pretext for the attachment if you use addText method', () => {\n      let message = new formatSlackMessage().addAttachment().addPretext('pretext');\n      expect(message.template.attachments[0].pretext).toBe('pretext');\n    });\n\n    it('should throw an error if you try to addUrl without providing it', () => {\n      let message = new formatSlackMessage().addAttachment();\n      expect(() => message.addImage()).toThrowError('addImage method requires a valid URL');\n    });\n\n    it('should throw an error if you try to addUrl with invalid url', () => {\n      let message = new formatSlackMessage().addAttachment();\n      expect(() => message.addImage('http:invalid-url')).toThrowError('addImage method requires a valid URL');\n    });\n\n    it('should add an image if you call addUrl with valid URL', () => {\n      let message = new formatSlackMessage().addAttachment().addImage('http://claudiajs.org/path/to/image.png');\n      expect(message.template.attachments[0].image_url).toBe('http://claudiajs.org/path/to/image.png');\n    });\n\n    it('should throw an error if you try to addThumbnail without providing it', () => {\n      let message = new formatSlackMessage().addAttachment();\n      expect(() => message.addThumbnail()).toThrowError('addThumbnail method requires a valid URL');\n    });\n\n    it('should throw an error if you try to addThumbnail with invalid url', () => {\n      let message = new formatSlackMessage().addAttachment();\n      expect(() => message.addThumbnail('http:invalid-url')).toThrowError('addThumbnail method requires a valid URL');\n    });\n\n    it('should add an image if you call addThumbnail with valid URL', () => {\n      let message = new formatSlackMessage().addAttachment().addThumbnail('http://claudiajs.org/path/to/image.png');\n      expect(message.template.attachments[0].thumb_url).toBe('http://claudiajs.org/path/to/image.png');\n    });\n\n    it('should throw an error if you try to addAuthor without providing author name', () => {\n      let message = new formatSlackMessage().addAttachment();\n      expect(() => message.addAuthor()).toThrowError('Name is required for addAuthor method');\n    });\n\n    it('should add an author if you provide valid data', () => {\n      let message = new formatSlackMessage().addAttachment().addAuthor('Jorge Luis Borges', 'http://claudiajs.org/path/to/icon.png', 'http://claudiajs.org/');\n      expect(message.template.attachments[0].author_name).toBe('Jorge Luis Borges');\n      expect(message.template.attachments[0].author_icon).toBe('http://claudiajs.org/path/to/icon.png');\n      expect(message.template.attachments[0].author_link).toBe('http://claudiajs.org/');\n    });\n\n    it('should ignore author link if format is not valid', () => {\n      let message = new formatSlackMessage().addAttachment().addAuthor('Jorge Luis Borges', 'http://claudiajs.org/path/to/icon.png', 'http:invalid-url');\n      expect(message.template.attachments[0].author_name).toBe('Jorge Luis Borges');\n      expect(message.template.attachments[0].author_icon).toBe('http://claudiajs.org/path/to/icon.png');\n      expect(message.template.attachments[0].author_link).toBeFalsy();\n    });\n\n    it('should throw an error if you try to addFooter without providing a text', () => {\n      let message = new formatSlackMessage().addAttachment();\n      expect(() => message.addFooter()).toThrowError('Text is required for addFooter method');\n    });\n\n    it('should add a footer if data is valid', () => {\n      let message = new formatSlackMessage().addAttachment().addFooter('test', 'http://claudiajs.org/path/to/icon.png');\n      expect(message.template.attachments[0].footer).toBe('test');\n      expect(message.template.attachments[0].footer_icon).toBe('http://claudiajs.org/path/to/icon.png');\n    });\n\n    it('should throw an error if you try to addColor without providing it', () => {\n      let message = new formatSlackMessage().addAttachment();\n      expect(() => message.addColor()).toThrowError('Color is required for addColor method');\n    });\n\n    it('should add a color if data is valid', () => {\n      let message = new formatSlackMessage().addAttachment().addColor('#B4D455');\n      expect(message.template.attachments[0].color).toBe('#B4D455');\n    });\n\n    it('should throw an error if you call addTimestamp with anything but Date object', () => {\n      let message = new formatSlackMessage().addAttachment();\n      expect(() => message.addTimestamp('Something')).toThrowError('Timestamp needs to be a valid Date object');\n    });\n\n    it('should add a timestamp if you call addTimestamp method', () => {\n      let message = new formatSlackMessage().addAttachment().addTimestamp(new Date('2016-06-14T20:55:31.438Z'));\n      expect(message.template.attachments[0].ts).toBe(new Date('2016-06-14T20:55:31.438Z').getTime());\n    });\n\n    it('should throw an error if you call addField without providing an info', () => {\n      let message = new formatSlackMessage().addAttachment();\n      expect(() => message.addField()).toThrowError('Title and value are required for addField method');\n    });\n\n    it('should add a field with provided values', () => {\n      let message = new formatSlackMessage().addAttachment().addField('title', 'value');\n      expect(message.template.attachments[0].fields.length).toBe(1);\n      expect(message.template.attachments[0].fields[0].title).toBe('title');\n      expect(message.template.attachments[0].fields[0].value).toBe('value');\n      expect(message.template.attachments[0].fields[0].short).toBe(false);\n    });\n\n    it('should throw an error if you addAction without valid data', () => {\n      let message = new formatSlackMessage().addAttachment();\n      expect(() => message.addAction()).toThrowError('Text, name and value are requeired for addAction method');\n    });\n\n    it('should add an action', () => {\n      let message = new formatSlackMessage().addAttachment().addAction('FooBar', 'foo', 'bar');\n      expect(message.template.attachments[0].actions.length).toBe(1);\n      expect(message.template.attachments[0].actions[0].text).toBe('FooBar');\n      expect(message.template.attachments[0].actions[0].name).toBe('foo');\n      expect(message.template.attachments[0].actions[0].value).toBe('bar');\n      expect(message.template.attachments[0].actions[0].type).toBe('button');\n    });\n\n    it('should add an action with style', () => {\n      let message = new formatSlackMessage().addAttachment().addAction('FooBar', 'foo', 'bar', 'primary');\n      expect(message.template.attachments[0].actions.length).toBe(1);\n      expect(message.template.attachments[0].actions[0].text).toBe('FooBar');\n      expect(message.template.attachments[0].actions[0].name).toBe('foo');\n      expect(message.template.attachments[0].actions[0].value).toBe('bar');\n      expect(message.template.attachments[0].actions[0].style).toBe('primary');\n    });\n\n    it('should add multiple actions', () => {\n      let message = new formatSlackMessage().addAttachment()\n        .addAction('A1', 'foo', 'bar')\n        .addAction('A2', 'foo', 'bar')\n        .addAction('A3', 'foo', 'bar')\n        .addAction('A4', 'foo', 'bar')\n        .addAction('A5', 'foo', 'bar');\n      expect(message.template.attachments[0].actions.length).toBe(5);\n    });\n\n    it('should throw an error if you try to add more than 5 actions', () => {\n      let message = new formatSlackMessage().addAttachment()\n        .addAction('A1', 'foo', 'bar')\n        .addAction('A2', 'foo', 'bar')\n        .addAction('A3', 'foo', 'bar')\n        .addAction('A4', 'foo', 'bar')\n        .addAction('A5', 'foo', 'bar');\n      expect(() => message.addAction('A6', 'foo', 'bar')).toThrowError('You can not add more than 5 actions');\n    });\n\n    it('should throw an error if you try to add confirmation before adding an action', () => {\n      let message = new formatSlackMessage().addAttachment();\n      expect(() => message.addConfirmation()).toThrowError('At least one action is requeired for getLatestAction method');\n    });\n\n    it('should throw an error if you try to add confirmation without valid data', () => {\n      let message = new formatSlackMessage().addAttachment().addAction('FooBar', 'foo', 'bar');\n      expect(() => message.addConfirmation()).toThrowError('Title and text are required for addConfirmation method');\n    });\n\n    it('should add a confirmation', () => {\n      let message = new formatSlackMessage().addAttachment().addAction('FooBar', 'foo', 'bar').addConfirmation('Title', 'Text');\n      expect(message.template.attachments[0].actions[0].confirm.title).toBe('Title');\n      expect(message.template.attachments[0].actions[0].confirm.text).toBe('Text');\n      expect(message.template.attachments[0].actions[0].confirm.ok_text).toBe('Ok');\n      expect(message.template.attachments[0].actions[0].confirm.dismiss_text).toBe('Dismiss');\n    });\n\n    it('should add a confirmation to the last action', () => {\n      let message = new formatSlackMessage()\n        .addAttachment()\n          .addAction('First', 'foo', 'bar')\n          .addAction('Second', 'foo', 'bar')\n          .addAction('Last', 'foo', 'bar')\n            .addConfirmation('Title', 'Text', 'Yes', 'No');\n      expect(message.template.attachments[0].actions[message.template.attachments[0].actions.length - 1].confirm.title).toBe('Title');\n      expect(message.template.attachments[0].actions[message.template.attachments[0].actions.length - 1].confirm.text).toBe('Text');\n      expect(message.template.attachments[0].actions[message.template.attachments[0].actions.length - 1].confirm.ok_text).toBe('Yes');\n      expect(message.template.attachments[0].actions[message.template.attachments[0].actions.length - 1].confirm.dismiss_text).toBe('No');\n    });\n\n    it('should return an json object', () => {\n      let message = new formatSlackMessage('Something').channelMessage(true).get();\n      expect(typeof message).toBe('object');\n      expect(message).toEqual({\n        text: 'Something',\n        response_type: 'in_channel',\n        mrkdwn: true,\n        attachments: []\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/slack/slack-parse-spec.js":"/*global describe, it, expect, require */\nvar parse = require('../../lib/slack/parse');\n\ndescribe('Slack parse', () => {\n  it('returns nothing if the format is invalid', () => {\n    expect(parse('string')).toBeUndefined();\n    expect(parse()).toBeUndefined();\n    expect(parse(false)).toBeUndefined();\n    expect(parse(123)).toBeUndefined();\n    expect(parse({})).toBeUndefined();\n    expect(parse([1, 2, 3])).toBeUndefined();\n  });\n\n  it('returns nothing if user_id and actions are missing', () => {\n    expect(parse({text: 'pete'})).toBeUndefined();\n  });\n\n  it('returns an empty text if the text is missing', () => {\n    var msg = { user_id: 123 };\n    expect(parse(msg)).toEqual({ sender: 123, text: '', originalRequest: msg, type: 'slack-slash-command'});\n  });\n\n  it('returns a parsed object when text and user_id are present', () => {\n    var msg = { user_id: 123, text: 'Hello' };\n    expect(parse(msg)).toEqual({ sender: 123, text: 'Hello', originalRequest: msg, type: 'slack-slash-command'});\n  });\n\n  it('returns a parsed object when actions are present', () => {\n    var msg = { user: { id: 123, name: 'username' }, actions: [{name: 'test', value: 'action'}] };\n    expect(parse(msg)).toEqual({ sender: 123, text: '', originalRequest: msg, type: 'slack-message-action', postback: true});\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/slack/slack-reply-spec.js":"/*global describe, it, expect */\n'use strict';\nvar reply = require('../../lib/slack/reply');\n\ndescribe('Slack Reply', () => {\n\n  it('returns a formatted output if string is passed', () =>\n    expect(reply('string')).toEqual({\n      text: 'string'\n    })\n  );\n\n  it('returns the same thing that was passed if argument is not a string', () => {\n    expect(reply()).toBeUndefined();\n    expect(reply(123)).toBe(123);\n    expect(reply([])).toEqual([]);\n    expect(reply({})).toEqual({});\n    expect(reply({ key: 'value' })).toEqual({ key: 'value' });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/slack/slack-setup-spec.js":"/*global require, describe, it, expect, beforeEach, jasmine*/\n'use strict';\n\nconst underTest = require('../../lib/slack/setup');\n\ndescribe('Slack setup', () => {\n  var api, bot, logError, parser, responder, botPromise, botResolve, botReject;\n\n  beforeEach(() => {\n    api = jasmine.createSpyObj('api', ['get', 'post', 'addPostDeployStep']);\n    botPromise = new Promise((resolve, reject) => {\n      botResolve = resolve;\n      botReject = reject;\n    });\n    bot = jasmine.createSpy().and.returnValue(botPromise);\n    parser = jasmine.createSpy();\n    logError = jasmine.createSpy();\n    responder = jasmine.createSpy();\n    underTest(api, bot, logError, parser, responder);\n  });\n\n  const singleMessageTemplate = {\n    token: 'slack-token',\n    team_id: 'T01AB2CDE',\n    team_domain: 'claudia',\n    channel_id: 'C01BCDE23',\n    channel_name: 'botbuilder',\n    user_id: 'U01ABCD2E',\n    user_name: 'slobodan',\n    command: '/why',\n    text: 'can\\'t I copy the internet?',\n    response_url: 'https://hooks.slack.com/commands/T01AB2CDE/12345678901/0a1BCdeFG2hij3KlmnO4PQR5'\n  };\n\n  const singleWebhookTemplate = {\n    token: 'slack-webhook-token',\n    team_id: 'T01AB2CDE',\n    team_domain: 'claudia',\n    channel_id: 'C01BCDE23',\n    channel_name: 'botbuilder',\n    user_id: 'U01ABCD2E',\n    user_name: 'slobodan',\n    trigger_word: 'why',\n    text: 'can\\'t I copy the internet?',\n    response_url: 'https://hooks.slack.com/commands/T01AB2CDE/12345678901/0a1BCdeFG2hij3KlmnO4PQR5'\n  };\n\n  const singleActionTemplate = {\n    actions: [{\n      name: 'some',\n      value: 'action'\n    }],\n    callback_id: 'comic_1234_xyz',\n    team: {\n      id: 'T47563693',\n      domain: 'watermelonsugar'\n    },\n    channel: {\n      id: 'C065W1189',\n      name: 'forgotten-works'\n    },\n    user: {\n      id: 'U045VRZFT',\n      name: 'brautigan'\n    },\n    action_ts: '1458170917.164398',\n    message_ts: '1458170866.000004',\n    attachment_id: '1',\n    token: 'slack-verification-token',\n    'original_message': '{}',\n    response_url: 'https://hooks.slack.com/actions/T47563693/6204672'\n  };\n\n  describe('slash command webhook and message processor', () => {\n    it('wires the POST request for Slack Slash command to the message processor', () => {\n      expect(api.post.calls.count()).toEqual(2);\n      expect(api.post.calls.argsFor(0)).toEqual(['/slack/slash-command', jasmine.any(Function)]);\n    });\n\n    it('replies with Error when slash command tokens do not match for a slash command message', () => {\n      let handler = api.post.calls.argsFor(0)[1];\n      handler({\n        post: singleMessageTemplate,\n        env: {\n          slackToken: 'slack-invalid-token',\n          slackWebhookToken: 'slack-webhook-token',\n          slackVerificationToken: 'slack-invalid-verification-token'\n        }\n      });\n\n      expect(responder.calls.count()).toEqual(1);\n      expect(responder).toHaveBeenCalledWith('unmatched token slack-token');\n    });\n\n    it('replies with Error when webhook tokens do not match for a webhook message', () => {\n      let handler = api.post.calls.argsFor(0)[1];\n      handler({\n        post: singleWebhookTemplate,\n        env: {\n          slackToken: 'slack-token',\n          slackWebhookToken: 'slack-invalid-webhook-token',\n          slackVerificationToken: 'slack-verification-token'\n        }\n      });\n\n      expect(responder.calls.count()).toEqual(1);\n      expect(responder).toHaveBeenCalledWith('unmatched token slack-webhook-token');\n    });\n\n    it('invokes parser if the slash command request is valid with the slack token', () => {\n      let handler = api.post.calls.argsFor(0)[1];\n      handler({\n        post: singleMessageTemplate,\n        env: {\n          slackToken: 'slack-token',\n          slackWebhookToken: 'slack-invalid-webhook-token',\n          slackVerificationToken: 'slack-invalid-verification-token'\n        }\n      });\n\n      expect(parser.calls.count()).toEqual(1);\n    });\n\n    it('invokes parser if the slash command request is valid with verification token', () => {\n      let handler = api.post.calls.argsFor(0)[1];\n      handler({\n        post: singleMessageTemplate,\n        env: {\n          slackToken: 'slack-invalid-token',\n          slackWebhookToken: 'slack-invalid-webhook-token',\n          slackVerificationToken: 'slack-token'\n        }\n      });\n\n      expect(parser.calls.count()).toEqual(1);\n    });\n\n    it('invokes parser if the webhook request is valid', () => {\n      let handler = api.post.calls.argsFor(0)[1];\n      handler({\n        post: singleWebhookTemplate,\n        env: {\n          slackToken: 'slack-invalid-token',\n          slackWebhookToken: 'slack-webhook-token',\n          slackVerificationToken: 'slack-invalid-verification-token'\n        }\n      });\n\n      expect(parser.calls.count()).toEqual(1);\n    });\n\n    it('does not invoke the bot if the message cannot be parsed', () => {\n      parser.and.returnValue(false);\n\n      let handler = api.post.calls.argsFor(0)[1],\n        result = handler({\n          post: singleMessageTemplate,\n          env: {\n            slackToken: 'slack-token',\n            slackWebhookToken: 'slack-webhook-token',\n            slackVerificationToken: 'slack-verification-token'\n          }\n        });\n\n      result.then(message => {\n        expect(message).toBe('ok');\n        expect(bot).not.toHaveBeenCalled();\n      });\n    });\n\n    it('responds when the bot resolves', done => {\n      parser.and.returnValue({\n        sender: 'User1',\n        text: 'MSG1'\n      });\n\n      botResolve('Hello');\n\n      let handler = api.post.calls.argsFor(0)[1];\n      handler({\n        post: singleMessageTemplate,\n        env: {\n          slackToken: 'slack-token',\n          slackWebhookToken: 'slack-webhook-token',\n          slackVerificationToken: 'slack-verification-token'\n        }\n      }).then(() => {\n        expect(responder).toHaveBeenCalledWith('Hello');\n      }).then(done, done.fail);\n    });\n\n    it('logs error when the bot rejects without responding', done => {\n      parser.and.returnValue('MSG1');\n\n      let handler = api.post.calls.argsFor(0)[1];\n      handler({\n        post: singleMessageTemplate,\n        env: {\n          slackToken: 'slack-token',\n          slackWebhookToken: 'slack-webhook-token',\n          slackVerificationToken: 'slack-verification-token'\n        }\n      }).then(() => {\n        expect(responder).not.toHaveBeenCalled();\n        expect(logError).toHaveBeenCalledWith('No No');\n      }).then(done, done.fail);\n\n      botReject('No No');\n    });\n\n    it('logs the error when the responder throws an error', (done) => {\n      parser.and.returnValue('MSG1');\n      responder.and.throwError('XXX');\n\n      botResolve('Yes');\n\n      let handler = api.post.calls.argsFor(0)[1];\n      handler({\n        post: singleMessageTemplate,\n        env: {\n          slackToken: 'slack-token',\n          slackWebhookToken: 'slack-webhook-token',\n          slackVerificationToken: 'slack-verification-token'\n        }\n      }).then(() => {\n        expect(logError).toHaveBeenCalledWith(jasmine.any(Error));\n      }).then(done, done.fail);\n    });\n\n    it('returns parsed message if valid format is passed', () => {\n      parser.and.returnValue('some message');\n\n      let handler = api.post.calls.argsFor(0)[1],\n        result = handler({\n          post: singleMessageTemplate,\n          env: {\n            slackToken: 'slack-token',\n            slackWebhookToken: 'slack-webhook-token',\n            slackVerificationToken: 'slack-verification-token'\n          }\n        });\n\n      result.then(res => expect(res).toEqual('some message'));\n    });\n  });\n\n  describe('message actions webhook and message processor', () => {\n    it('wires the POST request for Slack message actions to the message processor', () => {\n      expect(api.post.calls.count()).toEqual(2);\n      expect(api.post.calls.argsFor(1)).toEqual(['/slack/message-action', jasmine.any(Function)]);\n    });\n\n    it('replies with Error when tokens for an action message do not match', () => {\n      let handler = api.post.calls.argsFor(1)[1];\n      handler({\n        post: {\n          payload: JSON.stringify(singleActionTemplate)\n        },\n        env: {\n          slackToken: 'slack-invalid-token',\n          slackWebhookToken: 'slack-webhook-token',\n          slackVerificationToken: 'slack-invalid-verification-token'\n\n        }\n      });\n\n      expect(responder.calls.count()).toEqual(1);\n      expect(responder).toHaveBeenCalledWith('unmatched token slack-verification-token');\n    });\n\n    it('invokes parser if the request contains a valid verification token', () => {\n      let handler = api.post.calls.argsFor(1)[1];\n      handler({\n        post: {\n          payload: JSON.stringify(singleActionTemplate)\n        },\n        env: {\n          slackToken: 'slack-invalid-token',\n          slackWebhookToken: 'slack-invalid-webhook-token',\n          slackVerificationToken: 'slack-verification-token'\n        }\n      });\n\n      expect(parser.calls.count()).toEqual(1);\n    });\n\n    it('invokes parser if the request contains a valid slack token for backwards compatibility', () => {\n      let handler = api.post.calls.argsFor(1)[1];\n      handler({\n        post: {\n          payload: JSON.stringify(singleActionTemplate)\n        },\n        env: {\n          slackToken: 'slack-verification-token',\n          slackWebhookToken: 'slack-invalid-webhook-token',\n          slackVerificationToken: 'slack-invalid-verification-token'\n        }\n      });\n\n      expect(parser.calls.count()).toEqual(1);\n    });\n\n    it('invokes parser if the request contains a token valid for either type', () => {\n      let handler = api.post.calls.argsFor(1)[1];\n      handler({\n        post: {\n          payload: JSON.stringify(singleActionTemplate)\n        },\n        env: {\n          slackToken: 'slack-verification-token',\n          slackWebhookToken: 'slack-invalid-webhook-token',\n          slackVerificationToken: 'slack-verification-token'\n        }\n      });\n\n      expect(parser.calls.count()).toEqual(1);\n    });\n\n    it('does not invoke the bot if the message cannot be parsed', () => {\n      parser.and.returnValue(false);\n\n      let handler = api.post.calls.argsFor(1)[1],\n        result = handler({\n          post: {\n            payload: JSON.stringify(singleActionTemplate)\n          },\n          env: {\n            slackToken: 'slack-invalid-token',\n            slackWebhookToken: 'slack-invalid-webhook-token',\n            slackVerificationToken: 'slack-verification-token'\n          }\n        });\n\n      result.then(message => {\n        expect(message).toBe('ok');\n        expect(bot).not.toHaveBeenCalled();\n      });\n    });\n\n    it('responds when the bot resolves', done => {\n      parser.and.returnValue({\n        sender: 'User1',\n        text: 'MSG1'\n      });\n\n      botResolve('Hello');\n\n      let handler = api.post.calls.argsFor(1)[1];\n      handler({\n        post: {\n          payload: JSON.stringify(singleActionTemplate)\n        },\n        env: {\n          slackToken: 'slack-invalid-token',\n          slackWebhookToken: 'slack-invalid-webhook-token',\n          slackVerificationToken: 'slack-verification-token'\n        }\n      }).then(() => {\n        expect(responder).toHaveBeenCalledWith('Hello');\n      }).then(done, done.fail);\n    });\n\n    it('logs error when the bot rejects without responding', done => {\n      parser.and.returnValue('MSG1');\n\n      let handler = api.post.calls.argsFor(1)[1];\n      handler({\n        post: {\n          payload: JSON.stringify(singleActionTemplate)\n        },\n        env: {\n          slackToken: 'slack-invalid-token',\n          slackWebhookToken: 'slack-invalid-webhook-token',\n          slackVerificationToken: 'slack-verification-token'\n        }\n      }).then(() => {\n        expect(responder).not.toHaveBeenCalled();\n        expect(logError).toHaveBeenCalledWith('No No');\n      }).then(done, done.fail);\n\n      botReject('No No');\n    });\n\n    it('logs the error when the responder throws an error', (done) => {\n      parser.and.returnValue('MSG1');\n      responder.and.throwError('XXX');\n\n      botResolve('Yes');\n\n      let handler = api.post.calls.argsFor(1)[1];\n      handler({\n        post: {\n          payload: JSON.stringify(singleActionTemplate)\n        },\n        env: {\n          slackToken: 'slack-invalid-token',\n          slackWebhookToken: 'slack-invalid-webhook-token',\n          slackVerificationToken: 'slack-verification-token'\n        }\n      }).then(() => {\n        expect(logError).toHaveBeenCalledWith(jasmine.any(Error));\n      }).then(done, done.fail);\n    });\n\n    it('returns parsed message if valid format is passed', () => {\n      parser.and.returnValue('some message');\n\n      let handler = api.post.calls.argsFor(1)[1],\n        result = handler({\n          post: {\n            payload: JSON.stringify(singleActionTemplate)\n          },\n          env: {\n            slackToken: 'slack-invalid-token',\n            slackWebhookToken: 'slack-invalid-webhook-token',\n            slackVerificationToken: 'slack-verification-token'\n          }\n        });\n\n      result.then(res => expect(res).toEqual('some message'));\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/support/jasmine-runner.js":"/*global jasmine, require, process*/\nvar Jasmine = require('jasmine'),\n  SpecReporter = require('jasmine-spec-reporter'),\n  noop = function () {},\n  jrunner = new Jasmine(),\n  filter;\nprocess.argv.slice(2).forEach(option => {\n  'use strict';\n  if (option === 'full') {\n    jrunner.configureDefaultReporter({print: noop});    // remove default reporter logs\n    jasmine.getEnv().addReporter(new SpecReporter());   // add jasmine-spec-reporter\n  }\n  if (option.match('^filter=')) {\n    filter = option.match('^filter=(.*)')[1];\n  }\n});\njrunner.loadConfigFile();                           // load jasmine.json configuration\njrunner.execute(undefined, filter);\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/telegram/telegram-format-message-spec.js":"/*global describe, it, expect, require */\n'use strict';\n\nconst formatMessage = require('../../lib/telegram/format-message');\n\ndescribe('Telegram format message', () => {\n  it('should export an object', () => {\n    expect(typeof formatMessage).toBe('object');\n  });\n\n  describe('Text', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.Text('text');\n      expect(typeof formatMessage.Text).toBe('function');\n      expect(message instanceof formatMessage.Text).toBeTruthy();\n    });\n\n    it('should throw an error if text is not provided', () => {\n      expect(() => new formatMessage.Text()).toThrowError('Text is required for Telegram Text template');\n    });\n\n    it('should generate a valid Telegram template object with markdown enabled by default', () => {\n      const message = new formatMessage.Text('Some text').get();\n      expect(message).toEqual({\n        text: 'Some text',\n        parse_mode: 'Markdown'\n      });\n    });\n\n    it('should disable markdown', () => {\n      const message = new formatMessage.Text('Some text').disableMarkdown().get();\n      expect(message).toEqual({\n        text: 'Some text'\n      });\n    });\n\n    it('should add reply keyboard markup', () => {\n      const message = new formatMessage\n        .Text('Some text')\n        .addReplyKeyboard([\n          [1], [2], [3]\n        ])\n        .get();\n      expect(message).toEqual({\n        text: 'Some text',\n        parse_mode: 'Markdown',\n        reply_markup: '{\"keyboard\":[[1],[2],[3]]}'\n      });\n    });\n\n    it('should add inline keyboard markup', () => {\n      const message = new formatMessage\n        .Text('Some text')\n        .addInlineKeyboard([\n          [1], [2], [3]\n        ])\n        .get();\n      expect(message).toEqual({\n        text: 'Some text',\n        parse_mode: 'Markdown',\n        reply_markup: '{\"inline_keyboard\":[[1],[2],[3]]}'\n      });\n    });\n\n    it('should overwrite keyboard markup if there is more than 1', () => {\n      const message = new formatMessage\n        .Text('Some text')\n        .addInlineKeyboard([\n          [1], [2], [3]\n        ])\n        .addReplyKeyboard([\n          [1], [2], [3]\n        ])\n        .get();\n      expect(message).toEqual({\n        text: 'Some text',\n        parse_mode: 'Markdown',\n        reply_markup: '{\"keyboard\":[[1],[2],[3]]}'\n      });\n    });\n  });\n\n  describe('Photo', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.Photo('foo');\n      expect(typeof formatMessage.Photo).toBe('function');\n      expect(message instanceof formatMessage.Photo).toBeTruthy();\n    });\n\n    it('should throw an error if photo url or id is not provided', () => {\n      expect(() => new formatMessage.Photo()).toThrowError('Photo needs to be an ID or URL for Telegram Photo method');\n    });\n\n    it('should generate a valid Telegram template object', () => {\n      const message = new formatMessage.Photo('http://some.random/photo/url').get();\n      expect(message).toEqual({\n        method: 'sendPhoto',\n        body: {\n          photo: 'http://some.random/photo/url'\n        }\n      });\n    });\n\n    it('should generate a valid Telegram template object with caption', () => {\n      const message = new formatMessage.Photo('http://some.random/photo/url', 'Some caption').get();\n      expect(message).toEqual({\n        method: 'sendPhoto',\n        body: {\n          photo: 'http://some.random/photo/url',\n          caption: 'Some caption'\n        }\n      });\n    });\n\n    it('should ignore caption if it is not a string', () => {\n      const message = new formatMessage.Photo('http://some.random/photo/url', {}).get();\n      expect(message).toEqual({\n        method: 'sendPhoto',\n        body: {\n          photo: 'http://some.random/photo/url'\n        }\n      });\n    });\n  });\n\n  describe('Audio', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.Audio('foo');\n      expect(typeof formatMessage.Audio).toBe('function');\n      expect(message instanceof formatMessage.Audio).toBeTruthy();\n    });\n\n    it('should throw an error if audio url or id is not provided', () => {\n      expect(() => new formatMessage.Audio()).toThrowError('Audio needs to be an ID or URL for Telegram Audio method');\n    });\n\n    it('should generate a valid Telegram template object', () => {\n      const message = new formatMessage.Audio('http://some.random/audio/url').get();\n      expect(message).toEqual({\n        method: 'sendAudio',\n        body: {\n          audio: 'http://some.random/audio/url'\n        }\n      });\n    });\n\n    it('should add a caption and duration if they exists', () => {\n      const message = new formatMessage.Audio('http://some.random/audio/url', 'Some caption', 1000).get();\n      expect(message).toEqual({\n        method: 'sendAudio',\n        body: {\n          audio: 'http://some.random/audio/url',\n          caption: 'Some caption',\n          duration: 1000\n        }\n      });\n    });\n\n    it('should ignore caption if it is not a string', () => {\n      const message = new formatMessage.Audio('http://some.random/audio/url', {}, 1000).get();\n      expect(message).toEqual({\n        method: 'sendAudio',\n        body: {\n          audio: 'http://some.random/audio/url',\n          duration: 1000\n        }\n      });\n    });\n\n    it('should ignore duration if it is not a number', () => {\n      const message = new formatMessage.Audio('http://some.random/audio/url', 'Hey', {}).get();\n      expect(message).toEqual({\n        method: 'sendAudio',\n        body: {\n          audio: 'http://some.random/audio/url',\n          caption: 'Hey'\n        }\n      });\n    });\n\n    it('should throw an error if addTitle method is invoked without a valid title', () => {\n      expect(() => new formatMessage.Audio('http://some.random/audio/url').addTitle()).toThrowError('Title is required for Telegram addTitle method');\n    });\n\n    it('should throw an error if addPerformer method is invoked without a valid performer', () => {\n      expect(() => new formatMessage.Audio('http://some.random/audio/url').addPerformer()).toThrowError('Performer is required for Telegram addPerformer method');\n    });\n\n    it('should add title and performer', () => {\n      const message = new formatMessage\n        .Audio('http://some.random/audio/url')\n        .addTitle('Some title')\n        .addPerformer('Some performer')\n        .get();\n\n      expect(message).toEqual({\n        method: 'sendAudio',\n        body: {\n          audio: 'http://some.random/audio/url',\n          title: 'Some title',\n          performer: 'Some performer'\n        }\n      });\n    });\n  });\n\n  describe('Location', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.Location(20, 44);\n      expect(typeof formatMessage.Location).toBe('function');\n      expect(message instanceof formatMessage.Location).toBeTruthy();\n    });\n\n    it('should throw an error if latitude and longitude are not valid', () => {\n      expect(() => new formatMessage.Location()).toThrowError('Latitude and longitude are required for Telegram Location template');\n    });\n\n    it('should generate a valid Telegram template object', () => {\n      const message = new formatMessage.Location(20, 44).get();\n      expect(message).toEqual({\n        method: 'sendLocation',\n        body: {\n          latitude: 20,\n          longitude: 44\n        }\n      });\n    });\n  });\n\n  describe('Venue', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.Venue(20, 44, 'Belgrade', 'Belgrade, Serbia');\n      expect(typeof formatMessage.Venue).toBe('function');\n      expect(message instanceof formatMessage.Venue).toBeTruthy();\n    });\n\n    it('should throw an error if latitude and longitude are not valid', () => {\n      expect(() => new formatMessage.Venue()).toThrowError('Latitude and longitude are required for Telegram Venue template');\n    });\n\n    it('should throw an error if title is not valid', () => {\n      expect(() => new formatMessage.Venue(20, 44)).toThrowError('Title is required for Telegram Venue template');\n    });\n\n    it('should throw an error if address is not valid', () => {\n      expect(() => new formatMessage.Venue(20, 44, 'Title')).toThrowError('Address is required for Telegram Venue template');\n    });\n\n    it('should generate a valid Telegram template object', () => {\n      const message = new formatMessage.Venue(20, 44, 'Some title', 'Some address').get();\n      expect(message).toEqual({\n        method: 'sendVenue',\n        body: {\n          latitude: 20,\n          longitude: 44,\n          title: 'Some title',\n          address: 'Some address'\n        }\n      });\n    });\n\n    it('should throw an error if foursquareId is not valid for addFoursqare method', () => {\n      expect(() => new formatMessage.Venue(20, 44, 'Title', 'Address').addFoursqare()).toThrowError('Foursquare ID is required for Telegram Venue template addFoursqare method');\n    });\n\n    it('should add foursquare ID', () => {\n      const message = new formatMessage\n        .Venue(20, 44, 'Some title', 'Some address')\n        .addFoursqare(123)\n        .get();\n      expect(message).toEqual({\n        method: 'sendVenue',\n        body: {\n          latitude: 20,\n          longitude: 44,\n          title: 'Some title',\n          address: 'Some address',\n          foursquare_id: 123\n        }\n      });\n    });\n  });\n\n  describe('ChatAction', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.ChatAction('typing');\n      expect(typeof formatMessage.ChatAction).toBe('function');\n      expect(message instanceof formatMessage.ChatAction).toBeTruthy();\n    });\n\n    it('should throw an error if chat action is not valid', () => {\n      expect(() => new formatMessage.ChatAction()).toThrowError('Valid action is required for Telegram ChatAction template. Check https://core.telegram.org/bots/api#sendchataction for all available actions.');\n    });\n\n    it('should generate a valid Telegram template object', () => {\n      const message = new formatMessage.ChatAction('typing').get();\n      expect(message).toEqual({\n        method: 'sendChatAction',\n        body: {\n          action: 'typing'\n        }\n      });\n    });\n  });\n\n  describe('Pause', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.Pause(200);\n      expect(typeof formatMessage.Pause).toBe('function');\n      expect(message instanceof formatMessage.Pause).toBeTruthy();\n    });\n\n    it('should generate an object with a defined value', () => {\n      const message = new formatMessage.Pause(1000).get();\n      expect(message).toEqual({\n        claudiaPause: 1000\n      });\n    });\n\n    it('should generate an object with a default value', () => {\n      const message = new formatMessage.Pause().get();\n      expect(message).toEqual({\n        claudiaPause: 500\n      });\n    });\n  });\n\n  describe('File', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.File('https://some.file.com/address.md');\n      expect(typeof formatMessage.File).toBe('function');\n      expect(message instanceof formatMessage.File).toBeTruthy();\n    });\n\n    it('should throw an error if file url is not available', () => {\n      expect(() => new formatMessage.File()).toThrowError('Document needs to be an URL for the Telegram File method');\n    });\n\n    it('should generate a valid Telegram File template object if caption is not sent', () => {\n      const message = new formatMessage.File('https://some.file.com/address.md').get();\n      expect(message).toEqual({\n        method: 'sendDocument',\n        body: {\n          document: 'https://some.file.com/address.md'\n        }\n      });\n    });\n\n    it('should generate a valid Telegram File template object if caption is sent', () => {\n      const message = new formatMessage.File('https://some.file.com/address.md', 'addressing').get();\n      expect(message).toEqual({\n        method: 'sendDocument',\n        body: {\n          document: 'https://some.file.com/address.md',\n          caption: 'addressing'\n        }\n      });\n    });\n  });\n\n  describe('Sticker', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.Sticker('https://some.file.com/address.md');\n      expect(typeof formatMessage.Sticker).toBe('function');\n      expect(message instanceof formatMessage.Sticker).toBeTruthy();\n    });\n\n    it('should throw an error if sticker URL or ID is not available', () => {\n      expect(() => new formatMessage.Sticker()).toThrowError('Sticker needs to be an URL or sticker ID for the Telegram Sticker method');\n    });\n\n    it('should generate a valid Telegram Sticker template object', () => {\n      const message = new formatMessage.Sticker('stickerID').get();\n      expect(message).toEqual({\n        method: 'sendSticker',\n        body: {\n          sticker: 'stickerID'\n        }\n      });\n    });\n  });\n\n  describe('Contact', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.Contact('123456789', 'John');\n      expect(typeof formatMessage.Contact).toBe('function');\n      expect(message instanceof formatMessage.Contact).toBeTruthy();\n    });\n\n    it('should throw an error if phone number is not available', () => {\n      expect(() => new formatMessage.Contact()).toThrowError('Phone number needs to be a string for Telegram Contact method');\n    });\n\n    it('should throw an error if first name is not available', () => {\n      expect(() => new formatMessage.Contact('123456789')).toThrowError('First name needs to be a string for Telegram Contact method');\n    });\n\n    it('should generate a valid Telegram Contact template object', () => {\n      const message = new formatMessage.Contact('123456789', 'John', 'Doe').get();\n      expect(message).toEqual({\n        method: 'sendContact',\n        body: {\n          phone_number: '123456789',\n          first_name: 'John',\n          last_name: 'Doe'\n        }\n      });\n    });\n\n    it('should generate a valid Telegram Contact template object without last name', () => {\n      const message = new formatMessage.Contact('123456789', 'John').get();\n      expect(message).toEqual({\n        method: 'sendContact',\n        body: {\n          phone_number: '123456789',\n          first_name: 'John'\n        }\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/telegram/telegram-parse-spec.js":"/*global describe, it, expect, require */\n'use strict';\nvar parse = require('../../lib/telegram/parse');\n\ndescribe('Telegram parse', () => {\n  it('returns nothing if the format is invalid', () => {\n    expect(parse('string')).toBeUndefined();\n    expect(parse()).toBeUndefined();\n    expect(parse(false)).toBeUndefined();\n    expect(parse(123)).toBeUndefined();\n    expect(parse({})).toBeUndefined();\n    expect(parse([1, 2, 3])).toBeUndefined();\n  });\n  it('returns false the chat id are missing', () => {\n    expect(parse({message: {chat: 'some123ChatId', text: 'ello Telegram'}})).toBeUndefined();\n    expect(parse({message: {text: 'pete'}})).toBeUndefined();\n  });\n  it('returns a parsed object when chat id is present', () => {\n    var msg = {message: {chat: {id: 'some123ChatId'}, text: 'ello Telegram' }};\n    expect(parse(msg)).toEqual({ sender: 'some123ChatId', text: 'ello Telegram', originalRequest: msg, type: 'telegram'});\n  });\n  it('returns a parsed object when messageObject contains a callback_query', () => {\n    var msg = {callback_query: {message: {chat: {id: 'some123ChatId'}},data: 'someCallbackData'}};\n    expect(parse(msg)).toEqual({ sender: 'some123ChatId', text: 'someCallbackData', originalRequest: msg, type: 'telegram'});\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/telegram/telegram-reply-spec.js":"/*global describe, it, expect, require, jasmine */\n'use strict';\nvar reply = require('../../lib/telegram/reply'),\n  https = require('https');\n\ndescribe('Telegram Reply', () => {\n\n  it('includes the telegram access token in the path request', done => {\n    https.request.pipe(callOptions => {\n      expect(callOptions).toEqual(jasmine.objectContaining({\n        method: 'POST',\n        hostname: 'api.telegram.org',\n        path: '/botACCESS123/sendMessage',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      }));\n      done();\n    });\n    reply(\n      {sender: 'some123ChatId', text: 'Hello Telegram', originalRequest: {message: {}}, type: 'telegram'},\n      'Hello Telegram',\n      'ACCESS123'\n    );\n  });\n\n  it('sends text messages as a string', done => {\n    https.request.pipe(callOptions => {\n      expect(JSON.parse(callOptions.body)).toEqual({\n        chat_id: 'some123ChatId',\n        text: 'Hello Telegram'\n      });\n      done();\n    });\n    reply(\n      {sender: 'some123ChatId', originalRequest: {}},\n      'Hello Telegram',\n      'ACCESS123'\n    );\n  });\n\n  describe('when an array is passed', () => {\n    it('does not send the second request until the first one completes', done => {\n      let answers = ['foo', 'bar'];\n      https.request.pipe(() => {\n        Promise.resolve().then(() => {\n          expect(https.request.calls.length).toEqual(1);\n        }).then(done);\n      });\n      reply(\n        {sender: 'some123ChatId', originalRequest: {}, type: 'telegram'},\n        answers,\n        'ACCESS123'\n      );\n    });\n    it('sends the requests in sequence', done => {\n      let answers = ['foo', 'bar'];\n      https.request.pipe(function () {\n        this.respond('200', 'OK');\n        if (https.request.calls.length === 2) {\n          expect(JSON.parse(https.request.calls[0].body[0])).toEqual({chat_id:'some123ChatId',text:'foo'});\n          expect(JSON.parse(https.request.calls[1].body[0])).toEqual({chat_id:'some123ChatId',text:'bar'});\n          done();\n        }\n      });\n      reply(\n        {sender: 'some123ChatId', originalRequest: {}, type: 'telegram'},\n        answers,\n        'ACCESS123'\n      );\n    });\n\n  });\n\n  it('sends custom object as message if user provide an object without method', done => {\n    https.request.pipe(callOptions => {\n      expect(JSON.parse(callOptions.body)).toEqual({\n        chat_id: 'some123ChatId',\n        text: 'Hello *Telegram*',\n        parse_mode: 'Markdown'\n      });\n      done();\n    });\n\n    reply(\n      { sender: 'some123ChatId', text: 'Hello Telegram', originalRequest: { message: {} }, type: 'telegram' },\n      { text: 'Hello *Telegram*', parse_mode: 'Markdown'},\n      'ACCESS123'\n    );\n  });\n\n  it('sends custom object as inline query if user provide an object without method after inline query', done => {\n    https.request.pipe(callOptions => {\n      expect(JSON.parse(callOptions.body)).toEqual({\n        chat_id: 'some123ChatId',\n        text: 'Hello *Telegram*',\n        parse_mode: 'Markdown'\n      });\n      done();\n    });\n\n    reply(\n      { sender: 'some123ChatId', text: 'Hello Telegram', originalRequest: { inline_query: {} }, type: 'telegram' },\n      { text: 'Hello *Telegram*', parse_mode: 'Markdown'},\n      'ACCESS123'\n    );\n  });\n\n  it('sends custom object with custom method if both object and method are provided', done => {\n    https.request.pipe(callOptions => {\n      expect(JSON.parse(callOptions.body)).toEqual({\n        chat_id: 'some123ChatId',\n        text: 'Hello *Telegram*',\n        parse_mode: 'Markdown'\n      });\n      expect(callOptions.href).toEqual('https://api.telegram.org/botACCESS123/sendMessage');\n      done();\n    });\n\n    reply(\n      { sender: 'some123ChatId', text: 'Hello Telegram', originalRequest: { inline_query: {} }, type: 'telegram' },\n      { method: 'sendMessage', body: { text: 'Hello *Telegram*', parse_mode: 'Markdown'} },\n      'ACCESS123'\n    );\n  });\n\n  it('does not resolve before the https endpoint responds', done => {\n    https.request.pipe(done);\n    reply(\n      {sender: 'some123ChatId', text: 'Hello Telegram', originalRequest: {message: {}}, type: 'telegram'},\n      'Hello Telegram',\n      'ACCESS123'\n    ).then(done.fail, done.fail);\n  });\n\n  it('resolves when the https endpoint responds with 200', done => {\n    https.request.pipe(() => {\n      setTimeout(() => {\n        https.request.calls[0].respond('200', 'OK', 'Hello Telegram');\n      }, 10);\n    });\n    reply(\n      {sender: 'some123ChatId', text: 'Hello Telegram', originalRequest: {message: {}}, type: 'telegram'},\n      'Hello Telegram',\n      'ACCESS123'\n    ).then(done, done.fail);\n  });\n\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/telegram/telegram-setup-spec.js":"/*global require, describe, it, expect, beforeEach, jasmine*/\n'use strict';\nvar setup = require('../../lib/telegram/setup');\n\ndescribe('Telegram setup', () => {\n  var api, bot, logError, parser, responder, botPromise, botResolve, botReject;\n  beforeEach(() => {\n    api = jasmine.createSpyObj('api', ['post', 'addPostDeployStep']);\n    botPromise = new Promise((resolve, reject) => {\n      botResolve = resolve;\n      botReject = reject;\n    });\n    bot = jasmine.createSpy().and.returnValue(botPromise);\n    logError = jasmine.createSpy();\n    parser = jasmine.createSpy();\n    responder = jasmine.createSpy();\n    setup(api, bot, logError, parser, responder);\n  });\n\n  describe('message processor', () => {\n    const singleMessageTemplate = {\n      'update_id': 2837645,\n      'message':{\n        'message_id': 32423423,\n        'from': {\n          id: 12321,\n          first_name: 'Testy',\n          last_name: 'Lasty',\n          username: 'testy_lasty'\n        },\n        'date': 1457764198246,\n        'chat': { 'id': 123123, 'type': 'private' }\n      }\n    };\n    it('wires the POST request for telegram to the message processor', () => {\n      expect(api.post.calls.count()).toEqual(1);\n      expect(api.post).toHaveBeenCalledWith('/telegram', jasmine.any(Function));\n    });\n    describe('processing a single message', () => {\n      var handler;\n      beforeEach(() => {\n        handler = api.post.calls.argsFor(0)[1];\n      });\n      it('breaks down the message and puts it into the parser', () => {\n        handler({body: singleMessageTemplate});\n        expect(parser).toHaveBeenCalledWith({\n          'update_id': 2837645,\n          'message': {\n            'message_id': 32423423,\n            'from': {\n              id: 12321,\n              first_name: 'Testy',\n              last_name: 'Lasty',\n              username: 'testy_lasty'\n            },\n            'date': 1457764198246,\n            'chat': {'id': 123123, 'type': 'private'}\n          }\n        });\n      });\n      it('passes the parsed value to the bot if a message can be parsed', (done) => {\n        parser.and.returnValue('MSG1');\n        handler({body: singleMessageTemplate});\n        Promise.resolve().then(() => {\n          expect(bot).toHaveBeenCalledWith('MSG1', {body: singleMessageTemplate});\n        }).then(done, done.fail);\n      });\n      it('does not invoke the bot if the message cannot be parsed', (done) => {\n        parser.and.returnValue(false);\n        handler({body: singleMessageTemplate}).then((message) => {\n          expect(message).toBe('ok');\n          expect(bot).not.toHaveBeenCalled();\n        }).then(done, done.fail);\n      });\n      it('responds when the bot resolves', (done) => {\n        parser.and.returnValue({sender: 'user1', text: 'MSG1'});\n        botResolve('Yes Yes');\n        handler({body: singleMessageTemplate, env: {telegramAccessToken: 'some123AccessToken'}}).then(() => {\n          expect(responder).toHaveBeenCalledWith({sender: 'user1', text: 'MSG1'}, 'Yes Yes', 'some123AccessToken');\n        }).then(done, done.fail);\n      });\n      it('can work with bot responses as strings', (done) => {\n        bot.and.returnValue('Yes!');\n        parser.and.returnValue({sender: 'user1', text: 'MSG1'});\n        handler({body: singleMessageTemplate, env: {telegramAccessToken: 'some123AccessToken'}}).then(() => {\n          expect(responder).toHaveBeenCalledWith({sender: 'user1', text: 'MSG1'}, 'Yes!', 'some123AccessToken');\n        }).then(done, done.fail);\n\n      });\n      it('logs error when the bot rejects without responding', (done) => {\n        parser.and.returnValue('MSG1');\n\n        handler({body: singleMessageTemplate}).then(() => {\n          expect(responder).not.toHaveBeenCalled();\n          expect(logError).toHaveBeenCalledWith('No No');\n        }).then(done, done.fail);\n\n        botReject('No No');\n      });\n      it('logs the error when the responder throws an error', (done) => {\n        parser.and.returnValue('MSG1');\n        responder.and.throwError('XXX');\n        botResolve('Yes');\n        handler({body: singleMessageTemplate, env: {telegramAccessToken: 'some123AccessToken'}}).then(() => {\n          expect(logError).toHaveBeenCalledWith(jasmine.any(Error));\n        }).then(done, done.fail);\n      });\n      describe('working with promises in responders', () => {\n        var responderResolve, responderReject, responderPromise, hasResolved;\n        beforeEach(() => {\n          responderPromise = new Promise((resolve, reject) => {\n            responderResolve = resolve;\n            responderReject = reject;\n          });\n          responder.and.returnValue(responderPromise);\n\n          parser.and.returnValue('MSG1');\n        });\n        it('waits for the responders to resolve before completing the request', (done) => {\n          handler({body: singleMessageTemplate, env: {telegramAccessToken: 'some123AccessToken'}}).then(() => {\n            hasResolved = true;\n          });\n\n          botPromise.then(() => {\n            expect(hasResolved).toBeFalsy();\n          }).then(done, done.fail);\n\n          botResolve('YES');\n        });\n        it('resolves when the responder resolves', (done) => {\n          handler({body: singleMessageTemplate, env: {telegramAccessToken: 'some123AccessToken'}}).then(done, done.fail);\n\n          botPromise.then(() => {\n            responderResolve('As Promised!');\n          });\n          botResolve('YES');\n        });\n        it('logs error when the responder rejects', (done) => {\n          handler({body: singleMessageTemplate, env: {telegramAccessToken: 'some123AccessToken'}}).then(() => {\n            expect(logError).toHaveBeenCalledWith('Bomb!');\n          }).then(done, done.fail);\n\n          botPromise.then(() => {\n            responderReject('Bomb!');\n          });\n          botResolve('YES');\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/twilio/twilio-parse-spec.js":"/*global describe, it, expect, require */\n'use strict';\nvar parse = require('../../lib/twilio/parse');\nconst qs = require('querystring');\n\ndescribe('Twilio parse', () => {\n  it('returns nothing if the format is invalid', () => {\n    expect(parse(qs.stringify('string'))).toBeUndefined();\n    expect(parse()).toBeUndefined();\n    expect(parse(qs.stringify(false))).toBeUndefined();\n    expect(parse(qs.stringify(123))).toBeUndefined();\n    expect(parse(qs.stringify({}))).toBeUndefined();\n    expect(parse(qs.stringify([1, 2, 3]))).toBeUndefined();\n  });\n  it('returns nothing if the Body is undefined or missing', () => {\n    expect(parse(qs.stringify({From: '+3333333333'}))).toBeUndefined();\n    expect(parse(qs.stringify({From: '+3333333333', Body: undefined}))).toBeUndefined();\n  });\n  it('returns nothing if the From is undefined or missing', () => {\n    expect(parse(qs.stringify({Body: 'SMS Twilio'}))).toBeUndefined();\n    expect(parse(qs.stringify({From: undefined, Body: 'SMS Twilio'}))).toBeUndefined();\n  });\n  it('returns a parsed object when Body and From are present', () => {\n    var msg = qs.stringify({From: '+3333333333', Body: 'SMS Twilio'});\n    expect(parse(msg)).toEqual({ sender: '+3333333333', text: 'SMS Twilio', originalRequest: qs.parse(msg), type: 'twilio'});\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/twilio/twilio-reply-spec.js":"/*global describe, it, expect, require, jasmine */\n'use strict';\nvar reply = require('../../lib/twilio/reply'),\n  qs = require('querystring'),\n  https = require('https');\n\ndescribe('Twilio Reply', () => {\n\n  it('includes the Twilio Authorization and Content type x-www-form-urlencoded in the header', done => {\n    https.request.pipe(callOptions => {\n      var data = qs.encode({ To: '+4444444444', From: '+333333333', Body: 'SMS Twilio'});\n      expect(callOptions).toEqual(jasmine.objectContaining({\n        method: 'POST',\n        hostname: 'api.twilio.com',\n        path: '/2010-04-01/Accounts/someRandomTwilioAccountSID/Messages.json',\n        headers: {\n          'Authorization': `Basic ${new Buffer('someRandomTwilioAccountSID' + ':' + 'RandomTwilioAuthToken').toString('base64')}`,\n          'content-type': 'application/x-www-form-urlencoded',\n          'content-length': Buffer.byteLength(data)\n        },\n        body: data\n      }));\n      done();\n    });\n    reply('someRandomTwilioAccountSID', 'RandomTwilioAuthToken',\n      '+333333333', '+4444444444', 'SMS Twilio');\n  });\n\n  it('sends text messages as a string', done => {\n    https.request.pipe(callOptions => {\n      expect(qs.parse(callOptions.body)).toEqual(jasmine.objectContaining({\n        To: '+4444444444',\n        From: '+333333333',\n        Body: 'SMS Twilio'\n      }));\n      done();\n    });\n    reply('someRandomTwilioAccountSID', 'RandomTwilioAuthToken',\n      '+333333333', '+4444444444', 'SMS Twilio');\n  });\n\n  it('does not resolve before the https endpoint responds', done => {\n    https.request.pipe(done);\n    reply(\n      'someRandomTwilioAccountSID', 'RandomTwilioAuthToken',\n      '+333333333', '+4444444444', 'SMS Twilio'\n    ).then(done.fail, done.fail);\n  });\n\n  it('resolves when the https endpoint responds with 200', done => {\n    https.request.pipe(() => {\n      setTimeout(() => {\n        https.request.calls[0].respond('200', 'OK', 'SMS Twilio');\n      }, 10);\n    });\n    reply(\n      'someRandomTwilioAccountSID', 'RandomTwilioAuthToken',\n      '+333333333', '+4444444444', 'SMS Twilio'\n    ).then(done, done.fail);\n  });\n\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/twilio/twilio-setup-spec.js":"/*global require, describe, it, expect, beforeEach, jasmine*/\n'use strict';\nvar setup = require('../../lib/twilio/setup');\nconst qs = require('querystring');\n\ndescribe('Twilio setup', () => {\n  var api, bot, logError, parser, responder, botPromise, botResolve, botReject;\n  beforeEach(() => {\n    api = jasmine.createSpyObj('api', ['post', 'addPostDeployStep']);\n    botPromise = new Promise((resolve, reject) => {\n      botResolve = resolve;\n      botReject = reject;\n    });\n    bot = jasmine.createSpy().and.returnValue(botPromise);\n    logError = jasmine.createSpy();\n    parser = jasmine.createSpy();\n    responder = jasmine.createSpy();\n    setup(api, bot, logError, parser, responder);\n  });\n\n  describe('message processor', () => {\n    const messageTemplate = {body: qs.stringify({\n      To: '+4444444444',\n      From: '+333333333',\n      Body: 'SMS Twilio'\n    }), env: {\n      TWILIO_ACCOUNT_SID: 'randomTwilioAccountSID',\n      TWILIO_AUTH_TOKEN: 'randomTwilioAuthToken',\n      TWILIO_NUMBER: '+4444444444'\n    }};\n    it('wires the POST request for twilio to the message processor', () => {\n      expect(api.post.calls.count()).toEqual(1);\n      expect(api.post).toHaveBeenCalledWith('/twilio', jasmine.any(Function), { success: { contentType: 'text/xml' }});\n    });\n    describe('processing a single message', () => {\n      var handler;\n      beforeEach(() => {\n        handler = api.post.calls.argsFor(0)[1];\n      });\n      it('breaks down the message and puts it into the parser', () => {\n        handler(messageTemplate);\n        expect(parser).toHaveBeenCalledWith(qs.stringify({\n          To: '+4444444444',\n          From: '+333333333',\n          Body: 'SMS Twilio'\n        }));\n      });\n      it('passes the parsed value to the bot if a message can be parsed', (done) => {\n        parser.and.returnValue('SMS Twilio');\n        handler(messageTemplate);\n        Promise.resolve().then(() => {\n          expect(bot).toHaveBeenCalledWith('SMS Twilio', messageTemplate);\n        }).then(done, done.fail);\n      });\n      it('does not invoke the bot if the message cannot be parsed', (done) => {\n        parser.and.returnValue(false);\n        handler(messageTemplate).then((message) => {\n          expect(message).toBe('<Response></Response>');\n          expect(bot).not.toHaveBeenCalled();\n        }).then(done, done.fail);\n      });\n      it('responds when the bot resolves', (done) => {\n        parser.and.returnValue({sender: '+333333333', text: 'SMS Twilio'});\n        botResolve('SMS Twilio');\n        handler(messageTemplate).then((message) => {\n          expect(message).toBe('<Response></Response>');\n          expect(responder).toHaveBeenCalledWith('randomTwilioAccountSID', 'randomTwilioAuthToken', new Buffer('+4444444444', 'base64').toString('ascii'), '+333333333', 'SMS Twilio');\n        }).then(done, done.fail);\n      });\n      it('can work with bot responses as strings', (done) => {\n        bot.and.returnValue('SMS Twilio');\n        parser.and.returnValue({sender: '+333333333', text: 'SMS Twili'});\n        handler(messageTemplate).then(() => {\n          expect(responder).toHaveBeenCalledWith('randomTwilioAccountSID', 'randomTwilioAuthToken', new Buffer('+4444444444', 'base64').toString('ascii'), '+333333333', 'SMS Twilio');\n        }).then(done, done.fail);\n\n      });\n      it('logs error when the bot rejects without responding', (done) => {\n        parser.and.returnValue('SMS Twilio');\n\n        handler(messageTemplate).then(() => {\n          expect(responder).not.toHaveBeenCalled();\n          expect(logError).toHaveBeenCalledWith('NOT AN SMS Twilio');\n        }).then(done, done.fail);\n\n        botReject('NOT AN SMS Twilio');\n      });\n      it('logs the error when the responder throws an error', (done) => {\n        parser.and.returnValue('SMS Twilio');\n        responder.and.throwError('XXX');\n        botResolve('SMS Twilio');\n        handler({body: messageTemplate}).then(() => {\n          expect(logError).toHaveBeenCalledWith(jasmine.any(Error));\n        }).then(done, done.fail);\n      });\n      describe('working with promises in responders', () => {\n        var responderResolve, responderReject, responderPromise, hasResolved;\n        beforeEach(() => {\n          responderPromise = new Promise((resolve, reject) => {\n            responderResolve = resolve;\n            responderReject = reject;\n          });\n          responder.and.returnValue(responderPromise);\n\n          parser.and.returnValue('SMS Twilio');\n        });\n        it('waits for the responders to resolve before completing the request', (done) => {\n          handler(messageTemplate).then(() => {\n            hasResolved = true;\n          });\n\n          botPromise.then(() => {\n            expect(hasResolved).toBeFalsy();\n          }).then(done, done.fail);\n\n          botResolve('YES');\n        });\n        it('resolves when the responder resolves', (done) => {\n          handler(messageTemplate).then(done, done.fail);\n\n          botPromise.then(() => {\n            responderResolve('As Promised!');\n          });\n          botResolve('YES');\n        });\n        it('logs error when the responder rejects', (done) => {\n          handler(messageTemplate).then(() => {\n            expect(logError).toHaveBeenCalledWith('Bomb!');\n          }).then(done, done.fail);\n\n          botPromise.then(() => {\n            responderReject('Bomb!');\n          });\n          botResolve('YES');\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/viber/viber-format-message-spec.js":"/*global describe, it, expect, require */\n'use strict';\n\nconst formatMessage = require('../../lib/viber/format-message');\n\ndescribe('Viber format message', () => {\n  it('should export an object', () => {\n    expect(typeof formatMessage).toBe('object');\n  });\n\n  describe('Text', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.Text('text');\n      expect(typeof formatMessage.Text).toBe('function');\n      expect(message instanceof formatMessage.Text).toBeTruthy();\n    });\n\n    it('should throw an error if text is not provided', () => {\n      expect(() => new formatMessage.Text()).toThrowError('Text is required for the Viber Text template');\n    });\n\n    it('should generate a valid Viber template object', () => {\n      const message = new formatMessage.Text('Some text').get();\n      expect(message).toEqual({\n        type: 'text',\n        text: 'Some text'\n      });\n    });\n\n    it('should add reply keyboard', () => {\n      const message = new formatMessage\n        .Text('Some text')\n        .addReplyKeyboard(true, '#FAFAFA')\n        .get();\n      expect(message).toEqual({\n        type: 'text',\n        text: 'Some text',\n        keyboard: {\n          Type: 'keyboard',\n          DefaultHeight: true,\n          BgColor: '#FAFAFA',\n          Buttons: []\n        }\n      });\n    });\n\n    it('should add reply keyboard with reply action button', () => {\n      const message = new formatMessage.Text('Some text')\n        .addReplyKeyboard(true)\n          .addKeyboardButton('test', 'test body', 2, 1)\n        .get();\n      expect(message).toEqual({\n        type: 'text',\n        text: 'Some text',\n        keyboard: {\n          Type: 'keyboard',\n          DefaultHeight: true,\n          BgColor: '#FFFFFF',\n          Buttons: [\n            {\n              Text: 'test',\n              ActionType: 'reply',\n              ActionBody: 'test body',\n              Columns: 2,\n              Rows: 1\n            }\n          ]\n        }\n      });\n    });\n\n    it('should reply text and add reply keyboard with open-url action button', () => {\n      const message = new formatMessage.Text('Claudia.js')\n        .addReplyKeyboard()\n          .addKeyboardButton('Open Claudia.js website', 'https://claudiajs.com', 2, 1)\n        .get();\n      expect(message).toEqual({\n        type: 'text',\n        text: 'Claudia.js',\n        keyboard: {\n          Type: 'keyboard',\n          DefaultHeight: true,\n          BgColor: '#FFFFFF',\n          Buttons: [\n            {\n              Text: 'Open Claudia.js website',\n              ActionType: 'open-url',\n              ActionBody: 'https://claudiajs.com',\n              Columns: 2,\n              Rows: 1\n            }\n          ]\n        }\n      });\n    });\n  });\n\n  it('should reply text and add reply keyboard with open-url action button and button color if custom object is passed', () => {\n    const message = new formatMessage.Text('Claudia.js')\n      .addReplyKeyboard()\n        .addKeyboardButton('Open Claudia.js website', 'https://claudiajs.com', 2, 1, {\n          BgColor: '#BADA55'\n        })\n      .get();\n    expect(message).toEqual({\n      type: 'text',\n      text: 'Claudia.js',\n      keyboard: {\n        Type: 'keyboard',\n        DefaultHeight: true,\n        BgColor: '#FFFFFF',\n        Buttons: [\n          {\n            Text: 'Open Claudia.js website',\n            ActionType: 'open-url',\n            ActionBody: 'https://claudiajs.com',\n            Columns: 2,\n            Rows: 1,\n            BgColor: '#BADA55'\n          }\n        ]\n      }\n    });\n  });\n\n  describe('Photo', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.Photo('https://claudiajs.com/assets/claudiajs.svg', 'Claudia.js photo text');\n      expect(typeof formatMessage.Photo).toBe('function');\n      expect(message instanceof formatMessage.Photo).toBeTruthy();\n    });\n\n    it('should throw an error if photo url is not provided', () => {\n      expect(() => new formatMessage.Photo()).toThrowError('Photo needs to be an URL for the Viber Photo method');\n    });\n\n    it('should throw an error if photo text is provided but not string', () => {\n      expect(() => new formatMessage.Photo('https://claudiajs.com/assets/claudiajs.svg', { foo: 'bar' })).toThrowError('Text needs to be a string for Viber Photo method');\n    });\n\n    it('should generate a valid Viber template object', () => {\n      const message = new formatMessage.Photo('https://claudiajs.com/assets/claudiajs.svg', 'Claudia.js photo text').get();\n      expect(message).toEqual({\n        type: 'picture',\n        media: 'https://claudiajs.com/assets/claudiajs.svg',\n        text: 'Claudia.js photo text'\n      });\n    });\n\n    it('should generate a valid Viber template object with an empty text if it is not provided', () => {\n      const message = new formatMessage.Photo('https://claudiajs.com/assets/claudiajs.svg').get();\n      expect(message).toEqual({\n        type: 'picture',\n        media: 'https://claudiajs.com/assets/claudiajs.svg',\n        text: ''\n      });\n    });\n\n    it('should generate a valid Telegram template object with caption', () => {\n      const message = new formatMessage.Photo('https://claudiajs.com/assets/claudiajs.svg', 'Claudia.js photo text').get();\n      expect(message).toEqual({\n        type: 'picture',\n        media: 'https://claudiajs.com/assets/claudiajs.svg',\n        text: 'Claudia.js photo text'\n      });\n    });\n  });\n\n  describe('Video', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.Video('https://vimeo.com/170647056', 25600, 156);\n      expect(typeof formatMessage.Video).toBe('function');\n      expect(message instanceof formatMessage.Video).toBeTruthy();\n    });\n\n    it('should throw an error if video url is not available', () => {\n      expect(() => new formatMessage.Video()).toThrowError('Media needs to be an URL for Viber Video method');\n    });\n\n    it('should throw an error if video size is not available', () => {\n      expect(() => new formatMessage.Video('https://vimeo.com/170647056')).toThrowError('Size needs to be a Number representing size in bytes for Viber Video method');\n    });\n\n    it('should generate a valid Viber Video template object', () => {\n      const message = new formatMessage.Video('https://vimeo.com/170647056', 25600, 156).get();\n      expect(message).toEqual({\n        type: 'video',\n        media: 'https://vimeo.com/170647056',\n        size: 25600,\n        duration: 156\n      });\n    });\n  });\n\n  describe('File', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.File('https://some.file.com/address.md', 25600, 'addressing');\n      expect(typeof formatMessage.File).toBe('function');\n      expect(message instanceof formatMessage.File).toBeTruthy();\n    });\n\n    it('should throw an error if file url is not available', () => {\n      expect(() => new formatMessage.File()).toThrowError('Media needs to be an URL for the Viber File method');\n    });\n\n    it('should throw an error if file size is not available', () => {\n      expect(() => new formatMessage.File('https://some.file.com/address.md')).toThrowError('Size needs to be a Number representing size in bytes for the Viber File method');\n    });\n\n    it('should throw an error if file_name is not available', () => {\n      expect(() => new formatMessage.File('https://some.file.com/address.md', 25600)).toThrowError('File name needs to be a String representing the name of the file for the Viber File method');\n    });\n\n    it('should generate a valid Viber File template object', () => {\n      const message = new formatMessage.File('https://some.file.com/address.md', 25600, 'addressing').get();\n      expect(message).toEqual({\n        type: 'file',\n        media: 'https://some.file.com/address.md',\n        size: 25600,\n        file_name: 'addressing'\n      });\n    });\n  });\n\n  describe('Contact', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.Contact('claudia', '+333333333');\n      expect(typeof formatMessage.Contact).toBe('function');\n      expect(message instanceof formatMessage.Contact).toBeTruthy();\n    });\n\n    it('should throw an error if contact name and contact phone number are not valid', () => {\n      expect(() => new formatMessage.Contact()).toThrowError('Contact name and phone number are required for the Viber Contact template');\n    });\n\n    it('should generate a valid Viber Contact template object', () => {\n      const message = new formatMessage.Contact('claudia', '+333333333').get();\n      expect(message).toEqual({\n        type: 'contact',\n        contact: {\n          name: 'claudia',\n          phone_number: '+333333333'\n        }\n      });\n    });\n  });\n\n  describe('Location', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.Location(20, 44);\n      expect(typeof formatMessage.Location).toBe('function');\n      expect(message instanceof formatMessage.Location).toBeTruthy();\n    });\n\n    it('should throw an error if latitude and longitude are not valid', () => {\n      expect(() => new formatMessage.Location()).toThrowError('Latitude and longitude are required for the Viber Location template');\n    });\n\n    it('should generate a valid Viber Location template object', () => {\n      const message = new formatMessage.Location(20, 44).get();\n      expect(message).toEqual({\n        type: 'location',\n        location: {\n          lat: 20,\n          lon: 44\n        }\n      });\n    });\n  });\n\n  describe('Url', () => {\n    it('should be a class', () => {\n      const message = new formatMessage.Url('https://claudiajs.com');\n      expect(typeof formatMessage.Url).toBe('function');\n      expect(message instanceof formatMessage.Url).toBeTruthy();\n    });\n\n    it('should throw an error if media url is not valid', () => {\n      expect(() => new formatMessage.Url()).toThrowError('Media needs to be an URL for the Viber URL method');\n    });\n\n    it('should generate a valid Viber Url template object', () => {\n      const message = new formatMessage.Url('https://claudiajs.com').get();\n      expect(message).toEqual({\n        type: 'url',\n        media: 'https://claudiajs.com'\n      });\n    });\n  });\n\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/viber/viber-parse-spec.js":"/* global describe, it, expect, require */\n'use strict';\nvar parse = require('../../lib/viber/parse');\n\ndescribe('Viber parse', () => {\n  it('should not return anything if the format is invalid', () => {\n    expect(parse('Just a string')).toBeUndefined();\n    expect(parse()).toBeUndefined();\n    expect(parse(false)).toBeUndefined();\n    expect(parse(123)).toBeUndefined();\n    expect(parse({})).toBeUndefined();\n    expect(parse([1, 2, 3])).toBeUndefined();\n  });\n  it('should not return anything if message is missing', () => {\n    expect(parse({sender: { id: 1 }})).toBeUndefined();\n  });\n  it('should return a parsed object if message is in correct format', () => {\n    var msg = {\n      event: 'message',\n      timestamp: new Date().getTime(),\n      message_token: 123,\n      sender: {\n        id: 'ABC',\n        name: 'Claudia',\n        avatar: 'https://claudiajs.com/assets/claudiajs.png'\n      },\n      message: {\n        text: 'Hello',\n        type: 'text'\n      }\n    };\n    expect(parse(msg)).toEqual({\n      sender: msg.sender.id,\n      text: msg.message.text,\n      originalRequest: msg,\n      type: 'viber'\n    });\n  });\n  it('should return a parsed object with an empty text if message is not textual', () => {\n    var msg = {\n      event: 'message',\n      timestamp: new Date().getTime(),\n      message_token: 123,\n      sender: {\n        id: 'ABC',\n        name: 'Claudia',\n        avatar: 'https://claudiajs.com/assets/claudiajs.png'\n      },\n      message: {\n        type: 'image'\n      }\n    };\n    expect(parse(msg)).toEqual({\n      sender: msg.sender.id,\n      text: '',\n      originalRequest: msg,\n      type: 'viber'\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/viber/viber-reply-spec.js":"/*global describe, it, expect, require, jasmine, beforeEach */\nvar reply = require('../../lib/viber/reply'),\n  https = require('https');\ndescribe('Viber Reply', () => {\n  'use strict';\n  beforeEach(() =>{\n    jasmine.DEFAULT_TIMEOUT_INTERVAL = 5000;\n  });\n\n  it('should include the token in the request', done => {\n    https.request.pipe(callOptions => {\n      expect(callOptions).toEqual(jasmine.objectContaining({\n        protocol: 'https:',\n        hostname: 'chatapi.viber.com',\n        path: '/pa/send_message',\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Content-Length': 79\n        },\n        body: '{\"type\":\"text\",\"auth_token\":\"ACCESS123\",\"text\":\"Hi there\",\"receiver\":\"user123\"}'\n      }));\n      done();\n    });\n    reply('user123', 'Hi there', 'ACCESS123');\n  });\n  it('should send a string message as a text object', done => {\n    https.request.pipe(callOptions => {\n      expect(JSON.parse(callOptions.body)).toEqual({\n        type: 'text',\n        auth_token: 'ACCESS123',\n        text: 'Hi there',\n        receiver: 'user123'\n      });\n      done();\n    });\n    reply('user123', 'Hi there', 'ACCESS123');\n  });\n  describe('when an array is passed', () => {\n    it('should not send the second request until the first one completes', done => {\n      let answers = ['foo', 'bar'];\n      https.request.pipe(() => {\n        Promise.resolve().then(() => {\n          expect(https.request.calls.length).toEqual(1);\n        }).then(done);\n      });\n      reply('user123', answers, 'ACCESS123');\n    });\n    it('should send the requests in sequence', done => {\n      let answers = ['foo', 'bar'];\n      https.request.pipe(function () {\n        this.respond('200', 'OK');\n        if (https.request.calls.length === 2) {\n          expect(JSON.parse(https.request.calls[0].body[0])).toEqual({\n            type: 'text',\n            auth_token: 'ACCESS123',\n            text: 'foo',\n            receiver: 'user123'\n          });\n          expect(JSON.parse(https.request.calls[1].body[0])).toEqual({\n            type: 'text',\n            auth_token: 'ACCESS123',\n            text: 'bar',\n            receiver: 'user123'\n          });\n          done();\n        }\n      });\n      reply('user123', answers, 'ACCESS123');\n    });\n\n  });\n\n  it('should send complex messages without transforming into a text object', done => {\n    https.request.pipe(callOptions => {\n      expect(JSON.parse(callOptions.body)).toEqual({\n        auth_token: 'ACCESS123',\n        receiver: 'user123',\n        tracking_data: 123,\n        type: 'text',\n        text: 'random text message'\n      });\n      done();\n    });\n    reply('user123', {\n      tracking_data: 123,\n      type: 'text',\n      text: 'random text message'\n    }, 'ACCESS123');\n  });\n  it('should not resolve before the https endpoint responds', done => {\n    https.request.pipe(done);\n    reply('user123', {template: 'big', contents: { title: 'red'} }, 'ACCESS123').then(done.fail, done.fail);\n  });\n  it('should resolve when the https endpoint responds with 200', done => {\n    https.request.pipe(function () {\n      this.respond('200', 'OK', 'Hi there');\n    });\n    reply('user123', {template: 'big', contents: { title: 'red'} }, 'ACCESS123').then(done, done.fail);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-claudia-bot-builder/node_modules/claudia-bot-builder/spec/viber/viber-setup-spec.js":"/*global require, describe, it, expect, beforeEach, jasmine*/\n'use strict';\nvar underTest = require('../../lib/viber/setup');\ndescribe('Viber setup', () => {\n  var api, bot, logError, parser, responder, botPromise, botResolve, botReject;\n  beforeEach(() => {\n    api = jasmine.createSpyObj('api', ['post', 'addPostDeployStep']);\n    botPromise = new Promise((resolve, reject) => {\n      botResolve = resolve;\n      botReject = reject;\n    });\n    bot = jasmine.createSpy().and.returnValue(botPromise);\n    parser = jasmine.createSpy();\n    logError = jasmine.createSpy();\n    responder = jasmine.createSpy();\n    underTest(api, bot, logError, parser, responder);\n  });\n  describe('message processor', () => {\n    const singleMessageTemplate = {\n      event: 'message',\n      timestamp: 1477292830416,\n      message_token: 12345,\n      sender: {\n        id: 'abc',\n        name: 'Claudia',\n        avatar: 'https://example.com/path/to.image'\n      },\n      'message': {\n        text: 'Hello',\n        type: 'text'\n      }\n    };\n    it('shoyld wire the POST request for Viber to the message processor', () => {\n      expect(api.post.calls.count()).toEqual(1);\n      expect(api.post).toHaveBeenCalledWith('/viber', jasmine.any(Function));\n    });\n    describe('processing a single message', () => {\n      var handler;\n      beforeEach(() => {\n        handler = api.post.calls.argsFor(0)[1];\n      });\n      it('should break down the message and put it into the parser', () => {\n        handler({ body: singleMessageTemplate, env: { viberAccessToken: 'ABC' } });\n        expect(parser).toHaveBeenCalledWith(singleMessageTemplate);\n      });\n      it('should pass the parsed value to the bot if a message can be parsed', (done) => {\n        parser.and.returnValue('MSG1');\n        handler({body: singleMessageTemplate, env: {}});\n        Promise.resolve().then(() => {\n          expect(bot).toHaveBeenCalledWith('MSG1', { body: singleMessageTemplate, env: {} });\n        }).then(done, done.fail);\n      });\n      it('should not invoke the bot if the message cannot be parsed', (done) => {\n        parser.and.returnValue(false);\n        handler({body: singleMessageTemplate, env: {}}).then((message) => {\n          expect(message).toBe('ok');\n          expect(bot).not.toHaveBeenCalled();\n        }).then(done, done.fail);\n      });\n      it('should respond when the bot resolves', (done) => {\n        parser.and.returnValue({sender: 'user1', text: 'MSG1'});\n        handler({ body: singleMessageTemplate, env: { viberAccessToken: 'ABC' } }).then(() => {\n          expect(responder).toHaveBeenCalledWith('user1', 'Yes Yes', 'ABC');\n        }).then(done, done.fail);\n\n        botResolve('Yes Yes');\n      });\n      it('should work with bot responses as strings', (done) => {\n        bot.and.returnValue('Yes!');\n        parser.and.returnValue({sender: 'user1', text: 'MSG1'});\n        handler({body: singleMessageTemplate, env: {viberAccessToken: 'ABC'}}).then(() => {\n          expect(responder).toHaveBeenCalledWith('user1', 'Yes!', 'ABC');\n        }).then(done, done.fail);\n\n      });\n      it('should log an error when the bot rejects without responding', (done) => {\n        parser.and.returnValue('MSG1');\n\n        handler({body: singleMessageTemplate, env: {}}).then(() => {\n          expect(responder).not.toHaveBeenCalled();\n          expect(logError).toHaveBeenCalledWith('No No');\n        }).then(done, done.fail);\n\n        botReject('No No');\n      });\n      it('should log an error when the responder throws an error', (done) => {\n        parser.and.returnValue('MSG1');\n        responder.and.throwError('XXX');\n        botResolve('Yes');\n        handler({body: singleMessageTemplate, env: {viberAccessToken: 'ABC'}}).then(() => {\n          expect(logError).toHaveBeenCalledWith(jasmine.any(Error));\n        }).then(done, done.fail);\n      });\n      describe('should work with promises in responders', () => {\n        var responderResolve, responderReject, responderPromise, hasResolved;\n        beforeEach(() => {\n          responderPromise = new Promise((resolve, reject) => {\n            responderResolve = resolve;\n            responderReject = reject;\n          });\n          responder.and.returnValue(responderPromise);\n\n          parser.and.returnValue('MSG1');\n        });\n        it('should wait for the responders to resolve before completing the request', (done) => {\n          handler({body: singleMessageTemplate, env: {viberAccessToken: 'ABC'}}).then(() => {\n            hasResolved = true;\n          });\n\n          botPromise.then(() => {\n            expect(hasResolved).toBeFalsy();\n          }).then(done, done.fail);\n\n          botResolve('YES');\n        });\n        it('should resolve when the responder resolves', (done) => {\n          handler({body: singleMessageTemplate, env: {viberAccessToken: 'ABC'}}).then((message) => {\n            expect(message).toEqual('As Promised!');\n          }).then(done, done.fail);\n\n          botPromise.then(() => {\n            responderResolve('As Promised!');\n          });\n          botResolve('YES');\n        });\n        it('should log error when the responder rejects', (done) => {\n          handler({body: singleMessageTemplate, env: {viberAccessToken: 'ABC'}}).then(() => {\n            expect(logError).toHaveBeenCalledWith('Bomb!');\n          }).then(done, done.fail);\n\n          botPromise.then(() => {\n            responderReject('Bomb!');\n          });\n          botResolve('YES');\n        });\n      });\n    });\n\n  });\n});\n"}